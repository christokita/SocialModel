plot_data <- edge_list %>% mutate(
to = factor(to, levels = node_list$name),
from = factor(from, levels = node_list$name))
# Plot
groupsize <- ncol(avg_g)
gg_avg_adj <- ggplot(plot_data, aes(x = rev(from), y = to, fill = weight)) +
geom_raster() +
theme_bw() +
# Because we need the x and y axis to display every node,
# not just the nodes that have connections to each other,
# make sure that ggplot does not drop unused factor levels
scale_x_discrete(drop = FALSE, expand = c(0, 0)) +
scale_y_discrete(drop = FALSE, expand = c(0, 0)) +
# scale_fill_gradientn(colours = rev(brewer.pal(9,"RdYlBu")), na.value = "white", limit = c(-1.5, 1.5), oob = squish) +
scale_fill_gradientn(name = "Relative Interaction\nFrequency",
colours = brewer.pal(5,"BuPu"),
na.value = "white",
limit = c(-0.5, 0.5),
oob = squish) +
theme(axis.text = element_blank(),
axis.ticks = element_blank(),
axis.title = element_blank(),
aspect.ratio = 1,
# Hide the legend (optional)
legend.position = "right",
# legend.key.height = unit(1.275, "cm"),
legend.text = element_text(size = 8),
panel.border = element_rect(size = 1.5),
title = element_blank()) +
ggtitle(paste0("Group Size = ", groupsize))
# return graph
return(gg_avg_adj)
# return(avg_g)
})
# Subset of graphs plot for figure
png(filename = paste0("output/Networks/FIGURE_IntMat_SingleLegend_", filename, ".png"), width = 2, height = 2, units = "in", res = 600)
multiplot(plotlist = interaction_graphs[c(7)], layout = matrix(c(seq(1:length(interaction_graphs[c(1, 2, 5, 8)]))), nrow = 1, byrow=TRUE))
dev.off()
interaction_graphs <- lapply(1:length(type_groups_graphs), function(i) {
# Get graphs
graphs <- type_groups_graphs[[i]]
replicates <- length(graphs)
# For each each compute interaction matrix
# Get graph and make adjacency matrix
size_graph <- lapply(1:length(graphs), function(j) {
# Format: set diagonal, rescale, and make adj matrix
this_graph <- graphs[[j]]
diag(this_graph) <- NA
dimensions <- dim(this_graph)
labs <- colnames(this_graph)
this_graph <- as.vector(this_graph)
this_graph <- scale(this_graph)
this_graph <- matrix(data = this_graph, nrow = dimensions[1], ncol = dimensions[2])
colnames(this_graph) <- labs
rownames(this_graph) <- labs
# Calculate thresh ratio
# ind <- replicates * i + j
thresh <- as.data.frame(type_groups_threshMat[[i]][j])
thresh$ThreshRatio <- log(thresh$Thresh1 / thresh$Thresh2)
ratio <- order(thresh$ThreshRatio)
# Create order by threshold ratio
this_graph <- this_graph[ratio, ratio]
# return
return(this_graph)
})
# Avearge across all to make 'typical' adjacency matrix
avg_g <- Reduce("+", size_graph) / length(size_graph)
# Create graph object
g <- graph_from_adjacency_matrix(avg_g, mode = c("directed"), weighted = TRUE, diag = TRUE)
# Get node and edge list
node_list <- get.data.frame(g, what = "vertices")
edge_list <- get.data.frame(g, what = "edges")
# Create dataframe for plotting
plot_data <- edge_list %>% mutate(
to = factor(to, levels = node_list$name),
from = factor(from, levels = node_list$name))
# Plot
groupsize <- ncol(avg_g)
gg_avg_adj <- ggplot(plot_data, aes(x = rev(from), y = to, fill = weight)) +
geom_raster() +
theme_bw() +
# Because we need the x and y axis to display every node,
# not just the nodes that have connections to each other,
# make sure that ggplot does not drop unused factor levels
scale_x_discrete(drop = FALSE, expand = c(0, 0)) +
scale_y_discrete(drop = FALSE, expand = c(0, 0)) +
# scale_fill_gradientn(colours = rev(brewer.pal(9,"RdYlBu")), na.value = "white", limit = c(-1.5, 1.5), oob = squish) +
scale_fill_gradientn(name = "Relative Interaction\nFrequency",
colours = brewer.pal(5,"BuPu"),
na.value = "white",
limit = c(-0.5, 0.5),
oob = squish) +
theme(axis.text = element_blank(),
axis.ticks = element_blank(),
axis.title = element_blank(),
aspect.ratio = 1,
# Hide the legend (optional)
legend.position = "right",
legend.key.height = unit(0.1, "cm"),
legend.text = element_text(size = 8),
panel.border = element_rect(size = 1.5),
title = element_blank()) +
ggtitle(paste0("Group Size = ", groupsize))
# return graph
return(gg_avg_adj)
# return(avg_g)
})
# Subset of graphs plot for figure
png(filename = paste0("output/Networks/FIGURE_IntMat_SingleLegend_", filename, ".png"), width = 2, height = 2, units = "in", res = 600)
multiplot(plotlist = interaction_graphs[c(7)], layout = matrix(c(seq(1:length(interaction_graphs[c(1, 2, 5, 8)]))), nrow = 1, byrow=TRUE))
dev.off()
interaction_graphs <- lapply(1:length(type_groups_graphs), function(i) {
# Get graphs
graphs <- type_groups_graphs[[i]]
replicates <- length(graphs)
# For each each compute interaction matrix
# Get graph and make adjacency matrix
size_graph <- lapply(1:length(graphs), function(j) {
# Format: set diagonal, rescale, and make adj matrix
this_graph <- graphs[[j]]
diag(this_graph) <- NA
dimensions <- dim(this_graph)
labs <- colnames(this_graph)
this_graph <- as.vector(this_graph)
this_graph <- scale(this_graph)
this_graph <- matrix(data = this_graph, nrow = dimensions[1], ncol = dimensions[2])
colnames(this_graph) <- labs
rownames(this_graph) <- labs
# Calculate thresh ratio
# ind <- replicates * i + j
thresh <- as.data.frame(type_groups_threshMat[[i]][j])
thresh$ThreshRatio <- log(thresh$Thresh1 / thresh$Thresh2)
ratio <- order(thresh$ThreshRatio)
# Create order by threshold ratio
this_graph <- this_graph[ratio, ratio]
# return
return(this_graph)
})
# Avearge across all to make 'typical' adjacency matrix
avg_g <- Reduce("+", size_graph) / length(size_graph)
# Create graph object
g <- graph_from_adjacency_matrix(avg_g, mode = c("directed"), weighted = TRUE, diag = TRUE)
# Get node and edge list
node_list <- get.data.frame(g, what = "vertices")
edge_list <- get.data.frame(g, what = "edges")
# Create dataframe for plotting
plot_data <- edge_list %>% mutate(
to = factor(to, levels = node_list$name),
from = factor(from, levels = node_list$name))
# Plot
groupsize <- ncol(avg_g)
gg_avg_adj <- ggplot(plot_data, aes(x = rev(from), y = to, fill = weight)) +
geom_raster() +
theme_bw() +
# Because we need the x and y axis to display every node,
# not just the nodes that have connections to each other,
# make sure that ggplot does not drop unused factor levels
scale_x_discrete(drop = FALSE, expand = c(0, 0)) +
scale_y_discrete(drop = FALSE, expand = c(0, 0)) +
# scale_fill_gradientn(colours = rev(brewer.pal(9,"RdYlBu")), na.value = "white", limit = c(-1.5, 1.5), oob = squish) +
scale_fill_gradientn(name = "Relative Interaction\nFrequency",
colours = brewer.pal(5,"BuPu"),
na.value = "white",
limit = c(-0.5, 0.5),
oob = squish) +
theme(axis.text = element_blank(),
axis.ticks = element_blank(),
axis.title = element_blank(),
aspect.ratio = 1,
# Hide the legend (optional)
legend.position = "right",
legend.key.height = unit(1, "cm"),
legend.text = element_text(size = 8),
panel.border = element_rect(size = 1.5),
title = element_blank()) +
ggtitle(paste0("Group Size = ", groupsize))
# return graph
return(gg_avg_adj)
# return(avg_g)
})
# Subset of graphs plot for figure
png(filename = paste0("output/Networks/FIGURE_IntMat_SingleLegend_", filename, ".png"), width = 2, height = 2, units = "in", res = 600)
multiplot(plotlist = interaction_graphs[c(7)], layout = matrix(c(seq(1:length(interaction_graphs[c(1, 2, 5, 8)]))), nrow = 1, byrow=TRUE))
dev.off()
####################
# Load data
####################
# Load social
load("output/Rdata/Sigma0.01-Epsilon0.01-Bias1.1.Rdata")
soc_groups_graphs <- groups_graphs
soc_groups_threshMat <- groups_thresh
soc_graphs <- unlist(groups_graphs, recursive = FALSE)
soc_threshMat <- unlist(groups_thresh, recursive = FALSE)
soc_actMat <- unlist(groups_taskDist, recursive = FALSE)
type_groups_graphs <- soc_groups_graphs
type_groups_threshMat <- soc_groups_threshMat
interaction_graphs <- lapply(1:length(type_groups_graphs), function(i) {
# Get graphs
graphs <- type_groups_graphs[[i]]
replicates <- length(graphs)
# For each each compute interaction matrix
# Get graph and make adjacency matrix
size_graph <- lapply(1:length(graphs), function(j) {
# Format: set diagonal, rescale, and make adj matrix
this_graph <- graphs[[j]]
diag(this_graph) <- NA
dimensions <- dim(this_graph)
labs <- colnames(this_graph)
this_graph <- as.vector(this_graph)
this_graph <- scale(this_graph)
this_graph <- matrix(data = this_graph, nrow = dimensions[1], ncol = dimensions[2])
colnames(this_graph) <- labs
rownames(this_graph) <- labs
# Calculate thresh ratio
# ind <- replicates * i + j
thresh <- as.data.frame(type_groups_threshMat[[i]][j])
thresh$ThreshRatio <- log(thresh$Thresh1 / thresh$Thresh2)
ratio <- order(thresh$ThreshRatio)
# Create order by threshold ratio
this_graph <- this_graph[ratio, ratio]
# return
return(this_graph)
})
# Avearge across all to make 'typical' adjacency matrix
avg_g <- Reduce("+", size_graph) / length(size_graph)
# Create graph object
g <- graph_from_adjacency_matrix(avg_g, mode = c("directed"), weighted = TRUE, diag = TRUE)
# Get node and edge list
node_list <- get.data.frame(g, what = "vertices")
edge_list <- get.data.frame(g, what = "edges")
# Create dataframe for plotting
plot_data <- edge_list %>% mutate(
to = factor(to, levels = node_list$name),
from = factor(from, levels = node_list$name))
# Plot
groupsize <- ncol(avg_g)
gg_avg_adj <- ggplot(plot_data, aes(x = rev(from), y = to, fill = weight)) +
geom_raster() +
theme_bw() +
# Because we need the x and y axis to display every node,
# not just the nodes that have connections to each other,
# make sure that ggplot does not drop unused factor levels
scale_x_discrete(drop = FALSE, expand = c(0, 0)) +
scale_y_discrete(drop = FALSE, expand = c(0, 0)) +
# scale_fill_gradientn(colours = rev(brewer.pal(9,"RdYlBu")), na.value = "white", limit = c(-1.5, 1.5), oob = squish) +
scale_fill_gradientn(name = "Relative Interaction\nFrequency",
colours = brewer.pal(5,"BuPu"),
na.value = "white",
limit = c(-0.5, 0.5),
oob = squish) +
theme(axis.text = element_blank(),
axis.ticks = element_blank(),
axis.title = element_blank(),
aspect.ratio = 1,
# Hide the legend (optional)
legend.position = "right",
legend.key.height = unit(1, "cm"),
legend.text = element_text(size = 8),
panel.border = element_rect(size = 1.5),
title = element_blank()) +
ggtitle(paste0("Group Size = ", groupsize))
# return graph
return(gg_avg_adj)
# return(avg_g)
})
multiplot(plotlist = interaction_graphs, layout = matrix(c(seq(1:length(interaction_graphs))), nrow=2, byrow=TRUE))
gg_avg_adj <- ggplot(plot_data, aes(x = rev(from), y = to, fill = weight)) +
geom_raster() +
theme_bw() +
# Because we need the x and y axis to display every node,
# not just the nodes that have connections to each other,
# make sure that ggplot does not drop unused factor levels
scale_x_discrete(drop = FALSE, expand = c(0, 0)) +
scale_y_discrete(drop = FALSE, expand = c(0, 0)) +
# scale_fill_gradientn(colours = rev(brewer.pal(9,"RdYlBu")), na.value = "white", limit = c(-1.5, 1.5), oob = squish) +
scale_fill_gradientn(name = "Relative Interaction\nFrequency",
colours = brewer.pal(5,"BuPu"),
na.value = "white",
limit = c(-0.5, 0.5),
oob = squish) +
theme(axis.text = element_blank(),
axis.ticks = element_blank(),
axis.title = element_blank(),
aspect.ratio = 1,
# Hide the legend (optional)
legend.position = "none",
legend.key.height = unit(1, "cm"),
legend.text = element_text(size = 8),
panel.border = element_rect(size = 1.5),
title = element_blank()) +
ggtitle(paste0("Group Size = ", groupsize))
interaction_graphs <- lapply(1:length(type_groups_graphs), function(i) {
# Get graphs
graphs <- type_groups_graphs[[i]]
replicates <- length(graphs)
# For each each compute interaction matrix
# Get graph and make adjacency matrix
size_graph <- lapply(1:length(graphs), function(j) {
# Format: set diagonal, rescale, and make adj matrix
this_graph <- graphs[[j]]
diag(this_graph) <- NA
dimensions <- dim(this_graph)
labs <- colnames(this_graph)
this_graph <- as.vector(this_graph)
this_graph <- scale(this_graph)
this_graph <- matrix(data = this_graph, nrow = dimensions[1], ncol = dimensions[2])
colnames(this_graph) <- labs
rownames(this_graph) <- labs
# Calculate thresh ratio
# ind <- replicates * i + j
thresh <- as.data.frame(type_groups_threshMat[[i]][j])
thresh$ThreshRatio <- log(thresh$Thresh1 / thresh$Thresh2)
ratio <- order(thresh$ThreshRatio)
# Create order by threshold ratio
this_graph <- this_graph[ratio, ratio]
# return
return(this_graph)
})
# Avearge across all to make 'typical' adjacency matrix
avg_g <- Reduce("+", size_graph) / length(size_graph)
# Create graph object
g <- graph_from_adjacency_matrix(avg_g, mode = c("directed"), weighted = TRUE, diag = TRUE)
# Get node and edge list
node_list <- get.data.frame(g, what = "vertices")
edge_list <- get.data.frame(g, what = "edges")
# Create dataframe for plotting
plot_data <- edge_list %>% mutate(
to = factor(to, levels = node_list$name),
from = factor(from, levels = node_list$name))
# Plot
groupsize <- ncol(avg_g)
gg_avg_adj <- ggplot(plot_data, aes(x = rev(from), y = to, fill = weight)) +
geom_raster() +
theme_bw() +
# Because we need the x and y axis to display every node,
# not just the nodes that have connections to each other,
# make sure that ggplot does not drop unused factor levels
scale_x_discrete(drop = FALSE, expand = c(0, 0)) +
scale_y_discrete(drop = FALSE, expand = c(0, 0)) +
# scale_fill_gradientn(colours = rev(brewer.pal(9,"RdYlBu")), na.value = "white", limit = c(-1.5, 1.5), oob = squish) +
scale_fill_gradientn(name = "Relative Interaction\nFrequency",
colours = brewer.pal(5,"BuPu"),
na.value = "white",
limit = c(-0.5, 0.5),
oob = squish) +
theme(axis.text = element_blank(),
axis.ticks = element_blank(),
axis.title = element_blank(),
aspect.ratio = 1,
# Hide the legend (optional)
legend.position = "none",
legend.key.height = unit(1, "cm"),
legend.text = element_text(size = 8),
panel.border = element_rect(size = 1.5),
title = element_blank()) +
ggtitle(paste0("Group Size = ", groupsize))
# return graph
return(gg_avg_adj)
# return(avg_g)
})
multiplot(plotlist = interaction_graphs, layout = matrix(c(seq(1:length(interaction_graphs))), nrow=2, byrow=TRUE))
multiplot(plotlist = interaction_graphs[c(7)], layout = matrix(c(seq(1:length(interaction_graphs[c(1, 2, 5, 8)]))), nrow = 1, byrow=TRUE))
multiplot(plotlist = interaction_graphs, layout = matrix(c(seq(1:length(interaction_graphs))), nrow=2, byrow=TRUE))
interaction_graphs <- lapply(1:length(type_groups_graphs), function(i) {
# Get graphs
graphs <- type_groups_graphs[[i]]
replicates <- length(graphs)
# For each each compute interaction matrix
# Get graph and make adjacency matrix
size_graph <- lapply(1:length(graphs), function(j) {
# Format: set diagonal, rescale, and make adj matrix
this_graph <- graphs[[j]]
diag(this_graph) <- NA
dimensions <- dim(this_graph)
labs <- colnames(this_graph)
this_graph <- as.vector(this_graph)
this_graph <- scale(this_graph)
this_graph <- matrix(data = this_graph, nrow = dimensions[1], ncol = dimensions[2])
colnames(this_graph) <- labs
rownames(this_graph) <- labs
# Calculate thresh ratio
# ind <- replicates * i + j
thresh <- as.data.frame(type_groups_threshMat[[i]][j])
thresh$ThreshRatio <- log(thresh$Thresh1 / thresh$Thresh2)
ratio <- order(thresh$ThreshRatio)
# Create order by threshold ratio
this_graph <- this_graph[ratio, ratio]
# return
return(this_graph)
})
# Avearge across all to make 'typical' adjacency matrix
avg_g <- Reduce("+", size_graph) / length(size_graph)
# Create graph object
g <- graph_from_adjacency_matrix(avg_g, mode = c("directed"), weighted = TRUE, diag = TRUE)
# Get node and edge list
node_list <- get.data.frame(g, what = "vertices")
edge_list <- get.data.frame(g, what = "edges")
# Create dataframe for plotting
plot_data <- edge_list %>% mutate(
to = factor(to, levels = node_list$name),
from = factor(from, levels = node_list$name))
# Plot
groupsize <- ncol(avg_g)
gg_avg_adj <- ggplot(plot_data, aes(x = rev(from), y = to, fill = weight)) +
geom_raster() +
theme_bw() +
# Because we need the x and y axis to display every node,
# not just the nodes that have connections to each other,
# make sure that ggplot does not drop unused factor levels
scale_x_discrete(drop = FALSE, expand = c(0, 0)) +
scale_y_discrete(drop = FALSE, expand = c(0, 0)) +
# scale_fill_gradientn(colours = rev(brewer.pal(9,"RdYlBu")), na.value = "white", limit = c(-1.5, 1.5), oob = squish) +
scale_fill_gradientn(name = "Relative Interaction\nFrequency",
colours = brewer.pal(5,"BuPu"),
na.value = "white",
limit = c(-0.5, 0.5),
oob = squish) +
theme(axis.text = element_blank(),
axis.ticks = element_blank(),
axis.title = element_blank(),
aspect.ratio = 1,
# Hide the legend (optional)
legend.position = "none",
legend.key.height = unit(1, "cm"),
legend.text = element_text(size = 8),
panel.border = element_rect(size = 1.5)) +
ggtitle(paste0("Group Size = ", groupsize))
# return graph
return(gg_avg_adj)
# return(avg_g)
})
multiplot(plotlist = interaction_graphs, layout = matrix(c(seq(1:length(interaction_graphs))), nrow=2, byrow=TRUE))
dim(groups_graphs)
length(groups_graphs)
groups_graphs <- groups_graph[c(1:4, 8, 5, 6, 7)]
groups_graphs <- groups_graphs[c(1:4, 8, 5, 6, 7)]
soc_groups_graphs <- groups_graphs
groups_threshMat <- groups_threshMat[c(1:4, 8, 5, 6, 7)]
groups_thresh <- groups_thresh[c(1:4, 8, 5, 6, 7)]
soc_groups_graphs <- groups_graphs
soc_groups_threshMat <- groups_thresh
type_groups_graphs <- soc_groups_graphs
type_groups_threshMat <- soc_groups_threshMat
interaction_graphs <- lapply(1:length(type_groups_graphs), function(i) {
# Get graphs
graphs <- type_groups_graphs[[i]]
replicates <- length(graphs)
# For each each compute interaction matrix
# Get graph and make adjacency matrix
size_graph <- lapply(1:length(graphs), function(j) {
# Format: set diagonal, rescale, and make adj matrix
this_graph <- graphs[[j]]
diag(this_graph) <- NA
dimensions <- dim(this_graph)
labs <- colnames(this_graph)
this_graph <- as.vector(this_graph)
this_graph <- scale(this_graph)
this_graph <- matrix(data = this_graph, nrow = dimensions[1], ncol = dimensions[2])
colnames(this_graph) <- labs
rownames(this_graph) <- labs
# Calculate thresh ratio
# ind <- replicates * i + j
thresh <- as.data.frame(type_groups_threshMat[[i]][j])
thresh$ThreshRatio <- log(thresh$Thresh1 / thresh$Thresh2)
ratio <- order(thresh$ThreshRatio)
# Create order by threshold ratio
this_graph <- this_graph[ratio, ratio]
# return
return(this_graph)
})
# Avearge across all to make 'typical' adjacency matrix
avg_g <- Reduce("+", size_graph) / length(size_graph)
# Create graph object
g <- graph_from_adjacency_matrix(avg_g, mode = c("directed"), weighted = TRUE, diag = TRUE)
# Get node and edge list
node_list <- get.data.frame(g, what = "vertices")
edge_list <- get.data.frame(g, what = "edges")
# Create dataframe for plotting
plot_data <- edge_list %>% mutate(
to = factor(to, levels = node_list$name),
from = factor(from, levels = node_list$name))
# Plot
groupsize <- ncol(avg_g)
gg_avg_adj <- ggplot(plot_data, aes(x = rev(from), y = to, fill = weight)) +
geom_raster() +
theme_bw() +
# Because we need the x and y axis to display every node,
# not just the nodes that have connections to each other,
# make sure that ggplot does not drop unused factor levels
scale_x_discrete(drop = FALSE, expand = c(0, 0)) +
scale_y_discrete(drop = FALSE, expand = c(0, 0)) +
# scale_fill_gradientn(colours = rev(brewer.pal(9,"RdYlBu")), na.value = "white", limit = c(-1.5, 1.5), oob = squish) +
scale_fill_gradientn(name = "Relative Interaction\nFrequency",
colours = brewer.pal(5,"BuPu"),
na.value = "white",
limit = c(-0.5, 0.5),
oob = squish) +
theme(axis.text = element_blank(),
axis.ticks = element_blank(),
axis.title = element_blank(),
aspect.ratio = 1,
# Hide the legend (optional)
legend.position = "none",
legend.key.height = unit(1, "cm"),
legend.text = element_text(size = 8),
panel.border = element_rect(size = 1.5)) +
ggtitle(paste0("Group Size = ", groupsize))
# return graph
return(gg_avg_adj)
# return(avg_g)
})
multiplot(plotlist = interaction_graphs, layout = matrix(c(seq(1:length(interaction_graphs))), nrow=2, byrow=TRUE))
