#                          mid = "#cecece",
#                          low = "#2c7bb6",
#                          midpoint = 0,
#                          limits = c(-2, 2),
#                          oob = squish) +
#   base_breaks_x(thresh1time$t) +
#   base_breaks_y(thresh1time$Threshold) +
#   theme(aspect.ratio = 1,
#         panel.border = element_blank(),
#         panel.grid.major = element_blank(),
#         panel.grid.minor = element_blank(),
#         legend.position = "none",
#         axis.ticks.length = unit(4, "pt"),
#         axis.text = element_text(color = "black"))
# gg_thresh
gg_thresh <- ggplot(data = thresh1time,
aes(x = t, y = Threshold)) +
theme_classic(base_size = 10) +
geom_line(aes(group = Id, colour = ThreshRatio), size = 0.5) +
scale_colour_gradient2(name = "ln(Threshold Ratio)",
high = "#d7191c",
mid = "#ffffbf",
# mid = "#cecece",
low = "#2c7bb6",
midpoint = 0,
limits = c(-1, 1),
oob = squish) +
scale_y_continuous(limits = c(0, 20), breaks = seq(0,20, 5)) +
theme(aspect.ratio = 1,
panel.border = element_blank(),
panel.grid.major = element_blank(),
panel.grid.minor = element_blank(),
legend.position = "none",
axis.ticks.length = unit(4, "pt"),
axis.text = element_text(color = "black"))
gg_thresh
source('~/Documents/Research/Tarnita Lab/Social Interaction DOL/SocialModel/scripts/1_SocThreshModel_TrackThresh_OldStyle.R', echo=TRUE)
################################################################################
#
# Model incorporating both thresholds and network dynamics
#
################################################################################
rm(list = ls())
source("scripts/__Util__MASTER.R")
####################
# Set global variables
####################
# Initial paramters: Free to change
# Base parameters
Ns             <- c(50) #vector of number of individuals to simulate
m              <- 2 #number of tasks
gens           <- 30000 #number of generations to run simulation
corrStep       <- 200 #number of time steps for calculation of correlation
reps           <- 1 #number of replications per simulation (for ensemble)
# Threshold Parameters
ThreshM        <- rep(10, m) #population threshold means
ThreshSD       <- ThreshM * 0.2 #population threshold standard deviations
InitialStim    <- rep(0, m) #intital vector of stimuli
deltas         <- rep(0.6, m) #vector of stimuli increase rates
alpha          <- m #efficiency of task performance
quitP          <- 0.2 #probability of quitting task once active
# Social Network Parameters
epsilon        <- 0.01 #relative weighting of social interactions for lowering thresholds #0.01 = epsilon = phi
q              <- 1.1 #probability of interacting with individual in same state relative to others
####################
# Run simulation multiple times
####################
# Loop through group sizes
for (i in 1:length(Ns)) {
# Set group size
n <- Ns[i]
# Run Simulations
for (sim in 1:reps) {
####################
# Seed structures and intial matrices
####################
# Set initial probability matrix (P_g)
P_g <- matrix(data = rep(0, n * m), ncol = m)
# Seed task (external) stimuli
stimMat <- seedStimuls(InitialSVector = InitialStim,
gens = gens)
# Seed internal thresholds
threshMat <- seedThresholds(n = n,
m = m,
ThresholdMeans = ThreshM,
ThresholdSDs = ThreshSD)
# Start task performance
X_g <- matrix(data = rep(0, length(P_g)), ncol = ncol(P_g))
# Create cumulative task performance matrix
X_tot <- X_g
# Create cumulative adjacency matrix
g_tot <-  matrix(data = rep(0, n * n), ncol = n)
colnames(g_tot) <- paste0("v-", 1:n)
rownames(g_tot) <- paste0("v-", 1:n)
# Prep correlation tracking matrix
thresh1time <- list()
thresh2time <- list()
thresh1time[[1]] <- threshMat[,1]
thresh2time[[2]] <- threshMat[,2]
####################
# Simulate
####################
# Run simulation
for (t in 1:gens) {
# Update stimuli
for (j in 1:ncol(stimMat)) {
# update stim
stimMat[t + 1, j] <- globalStimUpdate(stimulus = stimMat[t, j],
delta = deltas[j],
alpha = alpha,
Ni = sum(X_g[ , j]),
n = n)
}
# Calculate task demand based on global stimuli
P_g <- calcThresholdDetermMat(TimeStep = t + 1, # first row is generation 0
ThresholdMatrix = threshMat,
StimulusMatrix = stimMat)
# Update task performance
X_g <- updateTaskPerformance(P_sub_g    = P_g,
TaskMat    = X_g,
QuitProb   = quitP)
# Update social network (previously this was before probability/task update)
g_adj <- temporalNetwork(X_sub_g = X_g,
bias = q)
g_tot <- g_tot + g_adj
# Adjust thresholds
threshMat <- adjustThresholdsSocial(SocialNetwork = g_adj,
ThresholdMatrix = threshMat,
X_sub_g = X_g,
epsilon = epsilon)
thresh1time[[t + 1]] <- threshMat[,1]
thresh2time[[t + 1]] <- threshMat[,2]
# Update total task performance profile
X_tot <- X_tot + X_g
}
# Print simulation completed
print(paste0("DONE: N = ", n, ", Simulation ", sim))
}
}
library(RColorBrewer)
library(scales)
library(tidyr)
library(ggthemes)
thresh1time <- do.call("rbind", thresh1time)
row.names(thresh1time) <- NULL
thresh1time <- as.data.frame(thresh1time)
thresh1time <- thresh1time %>%
mutate(t = 0:(nrow(.)-1)) %>%
gather("Id", "Threshold", 1:50)
threshMat <- threshMat %>%
as.data.frame(.) %>%
mutate(ThreshRatio = log(Thresh1 / Thresh2),
Id = row.names(.)) %>%
select(-Thresh1, -Thresh2)
thresh1time <- merge(thresh1time, threshMat, by = "Id")
# base_breaks_x <- function(x){
#   b <- pretty(x)
#   adjust_for_ticks <- max(b) * 0.0025
#   d <- data.frame(y=-Inf, yend=-Inf, x=min(b) - adjust_for_ticks, xend=max(b) + adjust_for_ticks)
#   list(geom_segment(data=d, aes(x=x, y=y, xend=xend, yend=yend),size = 1, inherit.aes=FALSE),
#        scale_x_continuous(breaks=b))
# }
# base_breaks_y <- function(x){
#   b <- pretty(x)
#   adjust_for_ticks <- max(b) * 0.0025
#   d <- data.frame(x = -Inf, xend = -Inf, y=min(b) - adjust_for_ticks, yend = max(b) + adjust_for_ticks)
#   list(geom_segment(data=d, aes(x = x, y = y, xend = xend, yend = yend), size = 1, inherit.aes = FALSE),
#        scale_y_continuous(breaks=b))
# }
#
# test <- thresh1time[thresh1time$Id %in% c("v-22", "v-20", "v-25", "v-40"),]
# gg_thresh <- ggplot(data = thresh1time,
#                     aes(x = t, y = Threshold)) +
#   theme_bw(base_size = 10) +
#   geom_line(aes(group = Id, colour = ThreshRatio), size = 0.5) +
#   scale_colour_gradient2(name = "ln(Threshold Ratio)",
#                          high = "#d7191c",
#                          mid = "#cecece",
#                          low = "#2c7bb6",
#                          midpoint = 0,
#                          limits = c(-2, 2),
#                          oob = squish) +
#   base_breaks_x(thresh1time$t) +
#   base_breaks_y(thresh1time$Threshold) +
#   theme(aspect.ratio = 1,
#         panel.border = element_blank(),
#         panel.grid.major = element_blank(),
#         panel.grid.minor = element_blank(),
#         legend.position = "none",
#         axis.ticks.length = unit(4, "pt"),
#         axis.text = element_text(color = "black"))
# gg_thresh
gg_thresh <- ggplot(data = thresh1time,
aes(x = t, y = Threshold)) +
theme_classic(base_size = 10) +
geom_line(aes(group = Id, colour = ThreshRatio), size = 0.5) +
scale_colour_gradient2(name = "ln(Threshold Ratio)",
high = "#d7191c",
mid = "#ffffbf",
# mid = "#cecece",
low = "#2c7bb6",
midpoint = 0,
limits = c(-1, 1),
oob = squish) +
scale_y_continuous(limits = c(0, 20), breaks = seq(0,20, 5)) +
theme(aspect.ratio = 1,
panel.border = element_blank(),
panel.grid.major = element_blank(),
panel.grid.minor = element_blank(),
legend.position = "none",
axis.ticks.length = unit(4, "pt"),
axis.text = element_text(color = "black"))
gg_thresh
gg_thresh <- ggplot(data = thresh1time,
aes(x = t, y = Threshold)) +
theme_classic(base_size = 10) +
geom_line(aes(group = Id, colour = ThreshRatio), size = 0.5) +
scale_colour_gradient2(name = "ln(Threshold Ratio)",
high = "#d7191c",
mid = "#ffffbf",
# mid = "#cecece",
low = "#2c7bb6",
midpoint = 0,
limits = c(-1, 1),
oob = squish) +
# scale_y_continuous(limits = c(0, 20), breaks = seq(0,20, 5)) +
theme(aspect.ratio = 1,
panel.border = element_blank(),
panel.grid.major = element_blank(),
panel.grid.minor = element_blank(),
legend.position = "none",
axis.ticks.length = unit(4, "pt"),
axis.text = element_text(color = "black"))
gg_thresh
rm(list = ls())
source("scripts/__Util__MASTER.R")
####################
# Set global variables
####################
# Initial paramters: Free to change
# Base parameters
Ns             <- c(50) #vector of number of individuals to simulate
m              <- 2 #number of tasks
gens           <- 30000 #number of generations to run simulation
corrStep       <- 200 #number of time steps for calculation of correlation
reps           <- 1 #number of replications per simulation (for ensemble)
# Threshold Parameters
ThreshM        <- rep(10, m) #population threshold means
ThreshSD       <- ThreshM * 0 #population threshold standard deviations
InitialStim    <- rep(0, m) #intital vector of stimuli
deltas         <- rep(0.6, m) #vector of stimuli increase rates
alpha          <- m #efficiency of task performance
quitP          <- 0.2 #probability of quitting task once active
# Social Network Parameters
epsilon        <- 0.01 #relative weighting of social interactions for lowering thresholds #0.01 = epsilon = phi
q              <- 1.1 #probability of interacting with individual in same state relative to others
####################
# Run simulation multiple times
####################
# Loop through group sizes
for (i in 1:length(Ns)) {
# Set group size
n <- Ns[i]
# Run Simulations
for (sim in 1:reps) {
####################
# Seed structures and intial matrices
####################
# Set initial probability matrix (P_g)
P_g <- matrix(data = rep(0, n * m), ncol = m)
# Seed task (external) stimuli
stimMat <- seedStimuls(InitialSVector = InitialStim,
gens = gens)
# Seed internal thresholds
threshMat <- seedThresholds(n = n,
m = m,
ThresholdMeans = ThreshM,
ThresholdSDs = ThreshSD)
# Start task performance
X_g <- matrix(data = rep(0, length(P_g)), ncol = ncol(P_g))
# Create cumulative task performance matrix
X_tot <- X_g
# Create cumulative adjacency matrix
g_tot <-  matrix(data = rep(0, n * n), ncol = n)
colnames(g_tot) <- paste0("v-", 1:n)
rownames(g_tot) <- paste0("v-", 1:n)
# Prep correlation tracking matrix
thresh1time <- list()
thresh2time <- list()
thresh1time[[1]] <- threshMat[,1]
thresh2time[[2]] <- threshMat[,2]
####################
# Simulate
####################
# Run simulation
for (t in 1:gens) {
# Update stimuli
for (j in 1:ncol(stimMat)) {
# update stim
stimMat[t + 1, j] <- globalStimUpdate(stimulus = stimMat[t, j],
delta = deltas[j],
alpha = alpha,
Ni = sum(X_g[ , j]),
n = n)
}
# Calculate task demand based on global stimuli
P_g <- calcThresholdDetermMat(TimeStep = t + 1, # first row is generation 0
ThresholdMatrix = threshMat,
StimulusMatrix = stimMat)
# Update task performance
X_g <- updateTaskPerformance(P_sub_g    = P_g,
TaskMat    = X_g,
QuitProb   = quitP)
# Update social network (previously this was before probability/task update)
g_adj <- temporalNetwork(X_sub_g = X_g,
bias = q)
g_tot <- g_tot + g_adj
# Adjust thresholds
threshMat <- adjustThresholdsSocial(SocialNetwork = g_adj,
ThresholdMatrix = threshMat,
X_sub_g = X_g,
epsilon = epsilon)
thresh1time[[t + 1]] <- threshMat[,1]
thresh2time[[t + 1]] <- threshMat[,2]
# Update total task performance profile
X_tot <- X_tot + X_g
}
# Print simulation completed
print(paste0("DONE: N = ", n, ", Simulation ", sim))
}
}
library(RColorBrewer)
library(scales)
library(tidyr)
library(ggthemes)
thresh1time <- do.call("rbind", thresh1time)
row.names(thresh1time) <- NULL
thresh1time <- as.data.frame(thresh1time)
thresh1time <- thresh1time %>%
mutate(t = 0:(nrow(.)-1)) %>%
gather("Id", "Threshold", 1:50)
threshMat <- threshMat %>%
as.data.frame(.) %>%
mutate(ThreshRatio = log(Thresh1 / Thresh2),
Id = row.names(.)) %>%
select(-Thresh1, -Thresh2)
thresh1time <- merge(thresh1time, threshMat, by = "Id")
# base_breaks_x <- function(x){
#   b <- pretty(x)
#   adjust_for_ticks <- max(b) * 0.0025
#   d <- data.frame(y=-Inf, yend=-Inf, x=min(b) - adjust_for_ticks, xend=max(b) + adjust_for_ticks)
#   list(geom_segment(data=d, aes(x=x, y=y, xend=xend, yend=yend),size = 1, inherit.aes=FALSE),
#        scale_x_continuous(breaks=b))
# }
# base_breaks_y <- function(x){
#   b <- pretty(x)
#   adjust_for_ticks <- max(b) * 0.0025
#   d <- data.frame(x = -Inf, xend = -Inf, y=min(b) - adjust_for_ticks, yend = max(b) + adjust_for_ticks)
#   list(geom_segment(data=d, aes(x = x, y = y, xend = xend, yend = yend), size = 1, inherit.aes = FALSE),
#        scale_y_continuous(breaks=b))
# }
#
# test <- thresh1time[thresh1time$Id %in% c("v-22", "v-20", "v-25", "v-40"),]
# gg_thresh <- ggplot(data = thresh1time,
#                     aes(x = t, y = Threshold)) +
#   theme_bw(base_size = 10) +
#   geom_line(aes(group = Id, colour = ThreshRatio), size = 0.5) +
#   scale_colour_gradient2(name = "ln(Threshold Ratio)",
#                          high = "#d7191c",
#                          mid = "#cecece",
#                          low = "#2c7bb6",
#                          midpoint = 0,
#                          limits = c(-2, 2),
#                          oob = squish) +
#   base_breaks_x(thresh1time$t) +
#   base_breaks_y(thresh1time$Threshold) +
#   theme(aspect.ratio = 1,
#         panel.border = element_blank(),
#         panel.grid.major = element_blank(),
#         panel.grid.minor = element_blank(),
#         legend.position = "none",
#         axis.ticks.length = unit(4, "pt"),
#         axis.text = element_text(color = "black"))
# gg_thresh
gg_thresh <- ggplot(data = thresh1time,
aes(x = t, y = Threshold)) +
theme_classic(base_size = 10) +
geom_line(aes(group = Id, colour = ThreshRatio), size = 0.5) +
scale_colour_gradient2(name = "ln(Threshold Ratio)",
high = "#d7191c",
mid = "#ffffbf",
# mid = "#cecece",
low = "#2c7bb6",
midpoint = 0,
limits = c(-1, 1),
oob = squish) +
# scale_y_continuous(limits = c(0, 20), breaks = seq(0,20, 5)) +
theme(aspect.ratio = 1,
panel.border = element_blank(),
panel.grid.major = element_blank(),
panel.grid.minor = element_blank(),
legend.position = "none",
axis.ticks.length = unit(4, "pt"),
axis.text = element_text(color = "black"))
gg_thresh
gg_thresh
gg_thresh
rm(list = ls())
source("scripts/__Util__MASTER.R")
library(RColorBrewer)
library(scales)
filename <- "Sigma0.05AndSigma0.01-Eps0.01-Bias1.1"
####################
# Compare entropies
####################
# Load social
load("output/Rdata/Sigma0.0-Epsilon0.01-Bias1.1.Rdata")
entropy <- unlist(groups_entropy, recursive = FALSE)
entropy <- do.call("rbind", entropy)  %>%
mutate(set = paste(n, replicate, sep = "-"))%>%
select(-Dsym, -Dtask) %>%
filter(n != 1) %>%
group_by(n) %>%
summarise(Mean = mean(Dind),
SE = sd(Dind) / sqrt(length(Dind))) %>%
mutate(Model = "Social")
# Load non-social
load("output/Rdata/Sigma0.01-FIXED-Bias1.1.Rdata")
entropy1 <- unlist(groups_entropy, recursive = FALSE)
entropy1 <- do.call("rbind", entropy1)  %>%
mutate(set = paste(n, replicate, sep = "-"))%>%
select(-Dsym, -Dtask) %>%
filter(n != 1) %>%
group_by(n) %>%
summarise(Mean = mean(Dind),
SE = sd(Dind) / sqrt(length(Dind))) %>%
mutate(Model = "Fixed_0.01")
# Load non-social
load("output/Rdata/Sigma0.05-FIXED-Bias1.1.Rdata")
entropy2 <- unlist(groups_entropy, recursive = FALSE)
entropy2 <- do.call("rbind", entropy2)  %>%
mutate(set = paste(n, replicate, sep = "-"))%>%
select(-Dsym, -Dtask) %>%
filter(n != 1) %>%
group_by(n) %>%
summarise(Mean = mean(Dind),
SE = sd(Dind) / sqrt(length(Dind))) %>%
mutate(Model = "Fixed_0.05")
# Join
entropy <- rbind(entropy, entropy1)
entropy <- rbind(entropy, entropy2)
####################
# Plot
####################
gg_entropy <- ggplot(data = entropy, aes(x = n, group = Model, color = Model, linetype = Model)) +
geom_errorbar(aes(ymin = Mean - SE, ymax = Mean + SE, color = Model),
width = 0.7) +
geom_line(aes(y = Mean)) +
geom_point(aes(y = Mean),
size = 2) +
theme_classic(base_size = 10) +
ylab("DOL Entropy") +
scale_y_continuous(limits = c(0, 1),
breaks = seq(0, 1, 0.2)) +
scale_x_continuous(breaks = unique(entropy$n)) +
scale_color_manual(name = "Model",
values = c("black", "black", "mediumseagreen"),
label = c(bquote("Fixed, " ~ sigma ~ "= 0.01"), bquote("Fixed, " ~ sigma ~ "= 0.05"), "Social")) +
scale_linetype_manual(name = "Model",
values = c("dashed", "dotted", "solid"),
label = c(bquote("Fixed, " ~ sigma ~ "= 0.01"), bquote("Fixed, " ~ sigma ~ "= 0.05"), "Social")) +
theme(legend.position = "right",
legend.title = element_text(size = 10, face = "bold"),
legend.text = element_text(size = 8),
legend.key.width = unit(0.8, "cm"),
legend.key.height = unit(0.4, "cm"),
axis.text.y = element_text(size = 10, margin = margin(5, 6, 5, -2), color = "black"),
axis.text.x = element_text(size = 10, margin = margin(6, 5, -2, 5), color = "black"),
axis.title = element_text(size = 11, margin = margin(0, 0, 0, 0)),
aspect.ratio = 1)
gg_entropy
####################
# Plot
####################
gg_entropy <- ggplot(data = entropy, aes(x = n, group = Model, color = Model)) +
geom_errorbar(aes(ymin = Mean - SE, ymax = Mean + SE, color = Model),
width = 0.7) +
geom_line(aes(y = Mean, linetype = Model)) +
geom_point(aes(y = Mean),
size = 2) +
theme_classic(base_size = 10) +
ylab("DOL Entropy") +
scale_y_continuous(limits = c(0, 1),
breaks = seq(0, 1, 0.2)) +
scale_x_continuous(breaks = unique(entropy$n)) +
scale_color_manual(name = "Model",
values = c("black", "black", "mediumseagreen"),
label = c(bquote("Fixed, " ~ sigma ~ "= 0.01"), bquote("Fixed, " ~ sigma ~ "= 0.05"), "Social")) +
scale_linetype_manual(name = "Model",
values = c("dashed", "dotted", "solid"),
label = c(bquote("Fixed, " ~ sigma ~ "= 0.01"), bquote("Fixed, " ~ sigma ~ "= 0.05"), "Social")) +
theme(legend.position = "right",
legend.title = element_text(size = 10, face = "bold"),
legend.text = element_text(size = 8),
legend.key.width = unit(0.8, "cm"),
legend.key.height = unit(0.4, "cm"),
axis.text.y = element_text(size = 10, margin = margin(5, 6, 5, -2), color = "black"),
axis.text.x = element_text(size = 10, margin = margin(6, 5, -2, 5), color = "black"),
axis.title = element_text(size = 11, margin = margin(0, 0, 0, 0)),
aspect.ratio = 1)
gg_entropy
ggsave(gg_entropy, file = paste0("output/SpecializationPlots/", filename, ".png"), height = 3, width = 4.5, units = "in", dpi = 800)
