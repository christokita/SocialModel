library(RColorBrewer)
library(scales)
p <- 1 #prob of interact
run <- "Sigma0-Epsilon0.1-Beta1.1"
# Load social networks
files <- list.files(paste0("output/Rdata/_ProcessedData/Graphs/", run, "/"), full.names = TRUE)
soc_networks <- list()
for (i in 1:length(files)) {
load(files[i])
soc_networks[[i]] <- listed_data
}
# Load threshold matrices
files <- list.files(paste0("output/Rdata/_ProcessedData/Thresh/", run, "/"), full.names = TRUE)
thresh_data <- list()
for (i in 1:length(files)) {
load(files[i])
thresh_data[[i]] <- listed_data
}
####################
# Output example graph
####################
# Set threshold max/min
thresh_limit <- 100
# Set group size and replicate
size <- 80
size <- size/5
replicate <- 1
# Get graph
example_graph <- soc_networks[[size]][[replicate]]
example_thresh <- as.data.frame(thresh_data[[size]][[replicate]])
example_thresh$Id <- row.names(example_thresh)
example_thresh$ThreshBias <- example_thresh$Thresh1 - example_thresh$Thresh2
example_thresh$ThreshBiasBounded <- example_thresh$ThreshBias
example_thresh$ThreshBiasBounded[example_thresh$ThreshBiasBounded < -thresh_limit] <- -thresh_limit
example_thresh$ThreshBiasBounded[example_thresh$ThreshBiasBounded > thresh_limit] <- thresh_limit
# If no node reaches upper or lower limits, add for coloring purposes in gephi
if (sum(example_thresh$ThreshBias == thresh_limit) == 0) {
max_row <- data.frame(Thresh1 = 50, Thresh2 = 50,
n = size * 5, sim = 0, chunk = 0,
Id = "Max", ThreshBias = thresh_limit, ThreshBiasBounded = thresh_limit)
example_thresh <- rbind(example_thresh, max_row)
}
if (sum(example_thresh$ThreshBias == -thresh_limit) == 0) {
min_row <- data.frame(Thresh1 = 50, Thresh2 = 50,
n = size * 5, sim = 0, chunk = 0,
Id = "Min", ThreshBias = -thresh_limit, ThreshBiasBounded = -thresh_limit)
example_thresh <- rbind(example_thresh, min_row)
}
# example_thresh$ThreshRatio <- log(example_thresh$Thresh1 / example_thresh$Thresh2)
# example_thresh$ThreshRatioBounded <- example_thresh$ThreshRatio
# example_thresh$ThreshRatioBounded[example_thresh$ThreshRatioBounded < -thresh_limit] <- -thresh_limit
# example_thresh$ThreshRatioBounded[example_thresh$ThreshRatioBounded > thresh_limit] <- thresh_limit
# # If no node reaches upper or lower limits, add for coloring purposes in gephi
# if (sum(example_thresh$ThreshRatioBounded == thresh_limit) == 0) {
#   max_row <- data.frame(Thresh1 = NA, Thresh2 = NA,
#                         n = NA, sim = NA, chunk = NA,
#                         Id = "Max", ThreshRatio = thresh_limit, ThreshRatioBounded = thresh_limit)
#   example_thresh <- rbind(example_thresh, max_row)
# }
# if (sum(example_thresh$ThreshRatioBounded == -thresh_limit) == 0) {
#   min_row <- data.frame(Thresh1 = NA, Thresh2 = NA,
#                         n = NA, sim = NA, chunk = NA,
#                         Id = "Min", ThreshRatio = -thresh_limit, ThreshRatioBounded = -thresh_limit)
#   example_thresh <- rbind(example_thresh, min_row)
# }
# # Calculate values expected
reweight_graph <- example_graph
not_chosen <- 1 - (( 1 / (nrow(reweight_graph) - 1)) * p)
expected_random <-  1 - not_chosen^2
reweight_graph <- (reweight_graph - expected_random) / reweight_graph
# Zero out interactions equal to or less than random
# example_graph[reweight_graph <= 0] <- 0
# Or take in those in top X percentile
percentiles <- quantile(example_graph, na.rm = TRUE)
fiftypercent <- percentiles[3]
seventyfivepercent <- percentiles[4]
example_graph[example_graph <= fiftypercent] <- 0
diag(example_graph) <- 0
# Turn into graph object to get edgelist
g <- graph_from_adjacency_matrix(example_graph, mode = "undirected", weighted = TRUE)
edgelist <- get.edgelist(g)
edgelist <- as.data.frame(edgelist)
names(edgelist) <- c("Source", "Target")
edgelist$Weight <- E(g)$weight
# Write
write.csv(edgelist, file = paste0("output/Networks/ExampleNetworks/GroupSize", 5*size, "_50th_edgelist.csv"), row.names = FALSE)
write.csv(example_thresh, file = paste0("output/Networks/ExampleNetworks/GroupSize", 5*size, "nodelist.csv"), row.names = FALSE)
source('~/Documents/Research/Tarnita Lab/Social Interaction DOL/SocialModel/scripts/Analyze_ExampleNetwork.R', echo=TRUE)
source('~/Documents/Research/Tarnita Lab/Social Interaction DOL/SocialModel/scripts/Analyze_ExampleNetwork.R', echo=TRUE)
hist(example_thresh$ThreshBias)
# Set threshold max/min
thresh_limit <- 100
# Set group size and replicate
size <- 80
size <- size/5
replicate <- 2
# Get graph
example_graph <- soc_networks[[size]][[replicate]]
example_thresh <- as.data.frame(thresh_data[[size]][[replicate]])
example_thresh$Id <- row.names(example_thresh)
example_thresh$ThreshBias <- example_thresh$Thresh1 - example_thresh$Thresh2
example_thresh$ThreshBiasBounded <- example_thresh$ThreshBias
example_thresh$ThreshBiasBounded[example_thresh$ThreshBiasBounded < -thresh_limit] <- -thresh_limit
example_thresh$ThreshBiasBounded[example_thresh$ThreshBiasBounded > thresh_limit] <- thresh_limit
# If no node reaches upper or lower limits, add for coloring purposes in gephi
if (sum(example_thresh$ThreshBias == thresh_limit) == 0) {
max_row <- data.frame(Thresh1 = 50, Thresh2 = 50,
n = size * 5, sim = 0, chunk = 0,
Id = "Max", ThreshBias = thresh_limit, ThreshBiasBounded = thresh_limit)
example_thresh <- rbind(example_thresh, max_row)
}
if (sum(example_thresh$ThreshBias == -thresh_limit) == 0) {
min_row <- data.frame(Thresh1 = 50, Thresh2 = 50,
n = size * 5, sim = 0, chunk = 0,
Id = "Min", ThreshBias = -thresh_limit, ThreshBiasBounded = -thresh_limit)
example_thresh <- rbind(example_thresh, min_row)
}
# example_thresh$ThreshRatio <- log(example_thresh$Thresh1 / example_thresh$Thresh2)
# example_thre
hist(example_thresh$ThreshBias)
replicate <- 3
# Get graph
example_graph <- soc_networks[[size]][[replicate]]
example_thresh <- as.data.frame(thresh_data[[size]][[replicate]])
example_thresh$Id <- row.names(example_thresh)
example_thresh$ThreshBias <- example_thresh$Thresh1 - example_thresh$Thresh2
example_thresh$ThreshBiasBounded <- example_thresh$ThreshBias
example_thresh$ThreshBiasBounded[example_thresh$ThreshBiasBounded < -thresh_limit] <- -thresh_limit
example_thresh$ThreshBiasBounded[example_thresh$ThreshBiasBounded > thresh_limit] <- thresh_limit
hist(example_thresh$ThreshBias)
replicate <- 5
# Get graph
example_graph <- soc_networks[[size]][[replicate]]
example_thresh <- as.data.frame(thresh_data[[size]][[replicate]])
example_thresh$Id <- row.names(example_thresh)
example_thresh$ThreshBias <- example_thresh$Thresh1 - example_thresh$Thresh2
example_thresh$ThreshBiasBounded <- example_thresh$ThreshBias
example_thresh$ThreshBiasBounded[example_thresh$ThreshBiasBounded < -thresh_limit] <- -thresh_limit
example_thresh$ThreshBiasBounded[example_thresh$ThreshBiasBounded > thresh_limit] <- thresh_limit
hist(example_thresh$ThreshBias)
rm(list = ls())
source("scripts/util/__Util__MASTER.R")
library(RColorBrewer)
library(scales)
p <- 1 #prob of interact
run <- "Sigma0-Epsilon0.1-Beta1.1"
####################
# Load and process data
####################
# Load social networks
files <- list.files(paste0("output/Rdata/_ProcessedData/Graphs/", run, "/"), full.names = TRUE)
soc_networks <- list()
for (i in 1:length(files)) {
load(files[i])
soc_networks[[i]] <- listed_data
}
# Load threshold matrices
files <- list.files(paste0("output/Rdata/_ProcessedData/Thresh/", run, "/"), full.names = TRUE)
thresh_data <- list()
for (i in 1:length(files)) {
load(files[i])
thresh_data[[i]] <- listed_data
}
####################
# Graph relative interactrion rates
####################
interaction_graphs <- lapply(1:length(soc_networks), function(i) {
# Get graphs
graphs <- soc_networks[[i]]
replicates <- length(graphs)
# For each each compute interaction matrix
# Get graph and make adjacency matrix
size_graph <- lapply(1:length(graphs), function(j) {
# Format: set diagonal, rescale, and make adj matrix
this_graph <- graphs[[j]]
diag(this_graph) <- NA
dimensions <- dim(this_graph)
labs <- colnames(this_graph)
this_graph <- as.vector(this_graph)
not_chosen <- 1 - (( 1 / (dimensions[1] - 1)) * p)
expected_random <-  1 - not_chosen^2
this_graph <- (this_graph - expected_random) / expected_random #relative to expected by random (i.e., 1 - chance of not being chosen^2)
this_graph <- matrix(data = this_graph, nrow = dimensions[1], ncol = dimensions[2])
colnames(this_graph) <- labs
rownames(this_graph) <- labs
# Calculate thresh bias
thresh <- as.data.frame(thresh_data[[i]][j])
thresh$ThreshBias <- thresh$Thresh1 - thresh$Thresh2
bias <- order(thresh$ThreshBias)
this_graph <- this_graph[bias, bias]
colnames(this_graph) <- paste0("i-", 1:dimensions[1])
rownames(this_graph) <- paste0("i-", 1:dimensions[1])
# return
return(this_graph)
})
# Avearge across all to make 'typical' adjacency matrix
avg_g <- Reduce("+", size_graph) / length(size_graph)
# Create graph object
g <- graph_from_adjacency_matrix(avg_g, mode = c("directed"), weighted = TRUE, diag = TRUE)
# Get node and edge list
node_list <- get.data.frame(g, what = "vertices")
edge_list <- get.data.frame(g, what = "edges")
# Create dataframe for plotting
plot_data <- edge_list %>% mutate(
to = factor(to, levels = node_list$name),
from = factor(from, levels = node_list$name))
# Get info for plot
groupsize <- ncol(avg_g)
if (groupsize < 20) {
breaks <- c(1, seq(5, length(unique(plot_data$to)), 5))
} else if(groupsize < 35) {
breaks <- c(1, seq(10, length(unique(plot_data$to)), 15))
} else {
breaks <- c(1, seq(20, length(unique(plot_data$to)), 20))
}
# Color palette
pal <- c('#525252','#5b5b5b','#646464','#6e6e6e','#787878','#818181','#8b8b8b',
'#959595','#a0a0a0','#a9a9a9','#b4b4b4','#bfbfbf','#c8c8c8','#d4d4d4',
'#dedede','#e9e9e9','#f4f4f4','#ffffff','#edf5f9','#dee9f2','#d3ddec',
'#c7d1e5','#bfc4de','#b7b7d7','#b0aad0','#a99ec8','#a391c1','#9e83b9',
'#9a76b1','#9569a9','#915aa1','#8c4c98','#893c8f','#852986','#810f7c')
# Plot
gg_avg_adj <- ggplot(plot_data, aes(x = from, y = to, fill = weight, color = weight)) +
geom_tile() +
theme_bw() +
# Because we need the x and y axis to display every node,
# not just the nodes that have connections to each other,
# make sure that ggplot does not drop unused factor levels
scale_x_discrete(drop = FALSE, expand = c(0, 0),
position = "top",
breaks = levels(plot_data$to)[breaks],
labels = rep("", length(levels(plot_data$to)[breaks]))) +
scale_y_discrete(drop = FALSE, expand = c(0, 0),
limits = rev(levels(plot_data$to)),
breaks = levels(plot_data$to)[breaks],
labels = rep("", length(levels(plot_data$to)[breaks]))) +
scale_fill_gradientn(name = "Relative\ninteraction\nfrequency",
colours = pal,
na.value = "white",
limit = c(-0.05, 0.05),
oob = squish) +
scale_color_gradientn(name = "Relative\ninteraction\nfrequency",
colours =  pal,
na.value = "white",
limit = c(-0.05, 0.05),
oob = squish) +
xlab("Individual") +
ylab("Individual") +
theme(aspect.ratio = 1,
# Hide the legend (optional)
legend.key.width = unit(3, "mm"),
legend.key.height = unit(6, "mm"),
legend.title = element_text(size = 7),
legend.text = element_text(size = 6),
panel.border = element_rect(size = 0.3, fill = NA, colour = "black"),
plot.title = element_blank(),
axis.text = element_blank(),
axis.title = element_blank(),
# # Minimal settings
# axis.ticks = element_blank(),
# Detailed Settings
axis.ticks = element_line(size = 0.3, colour = "black"),
legend.position = "none") +
ggtitle(paste0("Group Size = ", groupsize))
# return graph
return(gg_avg_adj)
# return(avg_g)
})
# save specific plot (only for fully detailed plot)
gg_inter <- interaction_graphs[80/5]
gg_inter
####################
simple_graphs <- lapply(1:length(soc_networks), function(i) {
# Get graphs
graphs <- soc_networks[[i]]
replicates <- length(graphs)
# For each each compute interaction matrix
# Get graph and make adjacency matrix
size_graph <- lapply(1:length(graphs), function(j) {
# Format: set diagonal, rescale, and make adj matrix
this_graph <- graphs[[j]]
diag(this_graph) <- NA
thresh <- as.data.frame(thresh_data[[i]][j])
thresh$ThreshBias <- thresh$Thresh1 - thresh$Thresh2
bias <- order(thresh$ThreshBias)
# Create order by threshold bias
this_graph <- this_graph[bias, bias]
colnames(this_graph) <- 1:nrow(this_graph)
rownames(this_graph) <- colnames(this_graph)
g <- graph.adjacency(adjmatrix = this_graph, weighted = T)
edgelist_graph <- as.data.frame(get.edgelist(g))
names(edgelist_graph) <- c("From", "To")
edgelist_graph$Weight <- E(g)$weight
edgelist_graph$Interaction <- paste0(edgelist_graph$From, "-", edgelist_graph$To)
# return
return(edgelist_graph)
})
#Calculate baseline probability of interaction
dimensions <- dim(graphs[[1]])
not_chosen <- 1 - (( 1 / (dimensions[1] - 1)) * p)
expected_random <-  1 - not_chosen^2
# Bind
all_edgelist <- do.call("rbind", size_graph)
#  Calcualte 99% CI interval of interaction rate
edgelist_sig <- all_edgelist %>%
group_by(From, To, Interaction) %>%
# filter(!is.na(Weight)) %>%
summarise(samp_mean = mean(Weight),
samp_sd = sd(Weight),
samples = length(Weight)) %>%
mutate(error = qt(0.995,df = samples-1) * samp_sd/sqrt(samples),
CI_low = samp_mean - error,
CI_high = samp_mean + error) %>%
mutate(Lower_check = CI_low > expected_random,
Higher_check = CI_high > expected_random)
# Determine if it is different than random
edgelist_sig <- as.data.frame(edgelist_sig)
edgelist_sig$DiffDirection <- 0
edgelist_sig$DiffDirection[edgelist_sig$Lower_check & edgelist_sig$Higher_check] <- 1
edgelist_sig$DiffDirection[edgelist_sig$Lower_check==FALSE & edgelist_sig$Higher_check==FALSE] <- -1
# Make graph
edgelist_sig <- edgelist_sig %>%
select(From, To, Interaction, DiffDirection) %>%
# unique(.) %>%
mutate(From = as.numeric(as.character(From)),
To = as.numeric(as.character(To))) %>%
arrange(From, To)
node_list <- unique( paste0("i-", edgelist_sig$To))
plot_data <- edgelist_sig %>%
mutate(from = paste0("i-", From),
to = paste0("i-", To)) %>%
mutate(to = factor(to, levels = rev(node_list)),
from = factor(from, levels = node_list),
weight = DiffDirection)
# Get info for plot
groupsize <- length(node_list)
if (groupsize < 30) {
breaks <- c(1, seq(5, groupsize, 5))
} else if(groupsize < 55) {
breaks <- c(1, seq(10, groupsize, 10))
} else {
breaks <- c(1, seq(20, groupsize, 20))
}
# Plot
gg_avg_adj <- ggplot(plot_data, aes(x = from, y = to, fill = weight, colour = weight)) +
geom_tile() +
theme_bw() +
# Because we need the x and y axis to display every node,
# not just the nodes that have connections to each other,
# make sure that ggplot does not drop unused factor levels
scale_x_discrete(drop = FALSE, expand = c(0, 0),
position = "top",
breaks = levels(plot_data$from)[breaks]) +
scale_y_discrete(drop = FALSE, expand = c(0, 0),
limits = levels(plot_data$to),
breaks = levels(plot_data$from)[breaks]) +
scale_fill_gradientn(name = "Relative Interaction\nFrequency",
colours = c("#9E9E9E", "#ffffff", "#79248C"),
na.value = "white",
limit = c(-1, 1),
oob = squish) +
scale_color_gradientn(name = "Relative Interaction\nFrequency",
colours = c("#9E9E9E", "#ffffff", "#79248C"),
na.value = "white",
limit = c(-1, 1),
oob = squish) +
xlab("Individual") +
ylab("Individual") +
theme(axis.text = element_blank(),
axis.title = element_blank(),
axis.ticks = element_line(size = 0.3, colour = "black"),
# Hide the legend (optional)
legend.position = "none",
legend.key.width = unit(3, "mm"),
legend.key.height = unit(6, "mm"),
legend.title = element_text(size = 7),
legend.text = element_text(size = 6),
panel.border = element_rect(size = 0.3, fill = NA, colour = "black"),
plot.title = element_blank(),
aspect.ratio = 1,
panel.grid = element_blank()) +
ggtitle(paste0("Group Size = ", groupsize))
# return graph
print(groupsize)
return(gg_avg_adj)
})
# Save single plot
gg_simp <- simple_graphs[80/5]
gg_simp
ggsave("output/Networks/RawPlots/SimpleAdjPlot_80.svg", width = 38, height = 38, units = "mm")
source('~/Documents/Research/Tarnita Lab/Social Interaction DOL/SocialModel/scripts/3_AnalyzeParaSpace.R', echo=TRUE)
rm(list = ls())
source("scripts/util/__Util__MASTER.R")
library(RColorBrewer)
library(scales)
############### Sweep across beta values ###############
####################
# Load data
####################
load("output/Rdata/_ProcessedData/Entropy/Sigma0-Epsilon0.1-Beta1.01.Rdata")
compiled_data$Model <- "Social_Beta1.01"
entropy_data <- compiled_data
rm(compiled_data)
load("output/Rdata/_ProcessedData/Entropy/Sigma0-Epsilon0.1-Beta1.05.Rdata")
compiled_data$Model <- "Social_Beta1.05"
entropy_data <- rbind(entropy_data, compiled_data)
rm(compiled_data)
load("output/Rdata/_ProcessedData/Entropy/Sigma0-Epsilon0.1-Beta1.1.Rdata")
compiled_data$Model <- "Social_Beta1.1"
entropy_data <- rbind(entropy_data, compiled_data)
rm(compiled_data)
load("output/Rdata/_ProcessedData/Entropy/Sigma0-Epsilon0.1-Beta1.2.Rdata")
compiled_data$Model <- "Social_Beta1.2"
entropy_data <- rbind(entropy_data, compiled_data)
rm(compiled_data)
####################
# Summarise data
####################
# Calculate mean and SE
entropy <- entropy_data %>%
group_by(Model, n) %>%
summarise(Mean = mean(Dind),
SE = sd(Dind) / sqrt(length(Dind)))
####################
# Plot
####################
pal <- brewer.pal(5, "Greens")[2:5]
gg_entropy <- ggplot(data = entropy, aes(x = n, colour = Model)) +
geom_line(aes(y = Mean),
size = 0.4) +
geom_errorbar(aes(ymin = Mean - SE, ymax = Mean + SE),
width = 0) +
geom_point(aes(y = Mean),
size = 0.8) +
theme_classic() +
ylab("Division of labor") +
scale_x_continuous(breaks = seq(0, 100, 20)) +
scale_color_manual(values = pal,
labels = c("1.2", "1.1"),
name = expression("Interaction bias"(Beta))) +
theme(axis.text = element_text(colour = "black", size = 6),
axis.title = element_text(size = 7, face = "italic"),
legend.position = "none",
legend.title = element_text(size = 7,
face = "bold"),
legend.text = element_text(size = 6),
legend.key.height = unit(4, "mm"),
legend.key.width = unit(5, "mm"),
axis.ticks = element_line(size = 0.3, color = "black"),
axis.line = element_line(size = 0.3, color = "black"),
aspect.ratio = 1)
gg_entropy
gg_entropy <- ggplot(data = entropy, aes(x = n, colour = Model)) +
geom_line(aes(y = Mean),
size = 0.4) +
geom_errorbar(aes(ymin = Mean - SE, ymax = Mean + SE),
width = 0) +
geom_point(aes(y = Mean),
size = 0.8) +
theme_classic() +
xlab(expression(paste("Group Size (", italic(n), ")"))) +
ylab(expression(paste("Division of labor (", italic(D{indiv}), ")"))) +
scale_x_continuous(breaks = seq(0, 100, 20)) +
scale_color_manual(values = pal,
labels = c("1.2", "1.1"),
name = expression("Interaction bias"(Beta))) +
theme(axis.text = element_text(colour = "black", size = 6),
axis.title = element_text(size = 7, face = "italic"),
legend.position = "none",
legend.title = element_text(size = 7,
face = "bold"),
legend.text = element_text(size = 6),
legend.key.height = unit(4, "mm"),
legend.key.width = unit(5, "mm"),
axis.ticks = element_line(size = 0.3, color = "black"),
axis.line = element_line(size = 0.3, color = "black"),
aspect.ratio = 1)
gg_entropy <- ggplot(data = entropy, aes(x = n, colour = Model)) +
geom_line(aes(y = Mean),
size = 0.4) +
geom_errorbar(aes(ymin = Mean - SE, ymax = Mean + SE),
width = 0) +
geom_point(aes(y = Mean),
size = 0.8) +
theme_classic() +
xlab(expression(paste("Group Size (", italic(n), ")"))) +
ylab(expression(paste("Division of labor (", italic(D[indiv]), ")"))) +
scale_x_continuous(breaks = seq(0, 100, 20)) +
scale_color_manual(values = pal,
labels = c("1.2", "1.1"),
name = expression("Interaction bias"(Beta))) +
theme(axis.text = element_text(colour = "black", size = 6),
axis.title = element_text(size = 7, face = "italic"),
legend.position = "none",
legend.title = element_text(size = 7,
face = "bold"),
legend.text = element_text(size = 6),
legend.key.height = unit(4, "mm"),
legend.key.width = unit(5, "mm"),
axis.ticks = element_line(size = 0.3, color = "black"),
axis.line = element_line(size = 0.3, color = "black"),
aspect.ratio = 1)
gg_entropy
source('~/Documents/Research/Tarnita Lab/Social Interaction DOL/SocialModel/scripts/Analyze_Entropy.R', echo=TRUE)
ggsave(gg_entropy, file = "output/SpecializationPlots/Sigma0-Beta1.1-EpsSweep.svg",
height = 48, width = 48, units = "mm")
ggsave(gg_entropy, file = "output/SpecializationPlots/Sigma0-Beta1.1-EpsSweep.svg",
height = 48.5, width = 48.5, units = "mm")
source('~/Documents/Research/Tarnita Lab/Social Interaction DOL/SocialModel/scripts/Analyze_Entropy.R', echo=TRUE)
source('~/Documents/Research/Tarnita Lab/Social Interaction DOL/SocialModel/scripts/Analyze_Entropy.R', echo=TRUE)
source('~/Documents/Research/Tarnita Lab/Social Interaction DOL/SocialModel/scripts/Analyze_Entropy.R', echo=TRUE)
source('~/Documents/Research/Tarnita Lab/Social Interaction DOL/SocialModel/scripts/Analyze_Entropy.R', echo=TRUE)
