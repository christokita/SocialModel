this_graph <- graphs[[j]]
diag(this_graph) <- NA
dimensions <- dim(this_graph)
labs <- colnames(this_graph)
this_graph <- as.vector(this_graph)
this_graph <- scale(this_graph)
this_graph <- matrix(data = this_graph, nrow = dimensions[1], ncol = dimensions[2])
colnames(this_graph) <- labs
rownames(this_graph) <- labs
# Calculate thresh ratio
ind <- replicates * i + j
thresh <- as.data.frame(soc_groups_threshMat[[i]][j])
thresh$ThreshRatio <- log(thresh$Thresh1 / thresh$Thresh2)
ratio <- order(thresh$ThreshRatio)
# Create order by threshold ratio
this_graph <- this_graph[ratio, ratio]
# return
return(this_graph)
})
# Avearge across all to make 'typical' adjacency matrix
avg_g <- Reduce("+", size_graph) / length(size_graph)
# Create graph object
g <- graph_from_adjacency_matrix(avg_g, mode = c("directed"), weighted = TRUE, diag = TRUE)
# Get node and edge list
node_list <- get.data.frame(g, what = "vertices")
edge_list <- get.data.frame(g, what = "edges")
# Create dataframe for plotting
plot_data <- edge_list %>% mutate(
to = factor(to, levels = node_list$name),
from = factor(from, levels = node_list$name))
# Plot
groupsize <- ncol(avg_g)
gg_avg_adj <- ggplot(plot_data, aes(x = from, y = to, fill = weight)) +
geom_raster() +
theme_bw() +
# Because we need the x and y axis to display every node,
# not just the nodes that have connections to each other,
# make sure that ggplot does not drop unused factor levels
scale_x_discrete(drop = FALSE, expand = c(0, 0)) +
scale_y_discrete(drop = FALSE, expand = c(0, 0)) +
# scale_fill_gradientn(colours = rev(brewer.pal(9,"RdYlBu")), na.value = "white", limit = c(-1.5, 1.5), oob = squish) +
scale_fill_gradientn(name = "Relative Interaction\nFrequency",
colours = brewer.pal(5,"BuPu"),
na.value = "white",
limit = c(-1, 1),
oob = squish) +
theme(axis.text = element_blank(),
axis.ticks = element_blank(),
axis.title = element_blank(),
aspect.ratio = 1,
# Hide the legend (optional)
legend.position = "none",
panel.border = element_rect(size = 1.5),
title = element_blank()) +
ggtitle(paste0("Group Size = ", groupsize))
# return graph
return(gg_avg_adj)
# return(avg_g)
})
multiplot(plotlist = interaction_graphs, layout = matrix(c(seq(1:length(interaction_graphs))), nrow=2, byrow=TRUE))
filename <- "Sigma0.0-Epsilon0.01-Bias1.1"
# Cutoff for threshold ratio to allow easier plotting
ThreshCutoffValue <- 10
ThreshCutoffReplacement <- Inf
ThreshCutoffReplacementColor <- 10
####################
# Load data
####################
# Load social
load("output/Rdata/Sigma0.0-Epsilon0.01-Bias1.1.Rdata")
soc_groups_graphs <- groups_graphs
soc_groups_threshMat <- groups_thresh
soc_graphs <- unlist(groups_graphs, recursive = FALSE)
soc_threshMat <- unlist(groups_thresh, recursive = FALSE)
soc_actMat <- unlist(groups_taskDist, recursive = FALSE)
social_graphs <- lapply(1:length(soc_graphs), function(i) {
# Calculated degree
degree <- rowSums(soc_graphs[[i]])
degree <- as.data.frame(degree)
degree$Id <- row.names(degree)
# Calculate thresholds
thresh <- soc_threshMat[[i]] %>%
as.data.frame(.) %>%
mutate(ThreshRatio = log(Thresh1 / Thresh2),
Id = row.names(.)) %>%
mutate(ThreshRatioRaw = ThreshRatio)
thresh$ThreshRatio[thresh$ThreshRatio > ThreshCutoffValue] <- ThreshCutoffReplacement
thresh$ThreshRatio[thresh$ThreshRatio < -ThreshCutoffValue] <- -ThreshCutoffReplacement
thresh$ThreshRatioColor <- thresh$ThreshRatio
thresh$ThreshRatioColor[thresh$ThreshRatio > ThreshCutoffValue] <- ThreshCutoffReplacementColor
thresh$ThreshRatioColor[thresh$ThreshRatio < -ThreshCutoffValue] <- -ThreshCutoffReplacementColor
# Calculate actibity
activity <- soc_actMat[[i]] %>%
as.data.frame(.) %>%
mutate(ActRatio = log(Task1 / Task2),
ActTotal = Task1 + Task2,
Id = row.names(.))
# Merge and return
mergedNodes <- merge(degree, thresh)
mergedNodes <- merge(mergedNodes, activity)
return(mergedNodes)
})
interaction_graphs <- lapply(1:length(soc_groups_graphs), function(i) {
# Get graphs
graphs <- soc_groups_graphs[[i]]
replicates <- length(graphs)
# For each each compute interaction matrix
# Get graph and make adjacency matrix
size_graph <- lapply(1:length(graphs), function(j) {
# Format: set diagonal, rescale, and make adj matrix
this_graph <- graphs[[j]]
diag(this_graph) <- NA
dimensions <- dim(this_graph)
labs <- colnames(this_graph)
this_graph <- as.vector(this_graph)
this_graph <- scale(this_graph)
this_graph <- matrix(data = this_graph, nrow = dimensions[1], ncol = dimensions[2])
colnames(this_graph) <- labs
rownames(this_graph) <- labs
# Calculate thresh ratio
ind <- replicates * i + j
thresh <- as.data.frame(soc_groups_threshMat[[i]][j])
thresh$ThreshRatio <- log(thresh$Thresh1 / thresh$Thresh2)
ratio <- order(thresh$ThreshRatio)
# Create order by threshold ratio
this_graph <- this_graph[ratio, ratio]
# return
return(this_graph)
})
# Avearge across all to make 'typical' adjacency matrix
avg_g <- Reduce("+", size_graph) / length(size_graph)
# Create graph object
g <- graph_from_adjacency_matrix(avg_g, mode = c("directed"), weighted = TRUE, diag = TRUE)
# Get node and edge list
node_list <- get.data.frame(g, what = "vertices")
edge_list <- get.data.frame(g, what = "edges")
# Create dataframe for plotting
plot_data <- edge_list %>% mutate(
to = factor(to, levels = node_list$name),
from = factor(from, levels = node_list$name))
# Plot
groupsize <- ncol(avg_g)
gg_avg_adj <- ggplot(plot_data, aes(x = from, y = to, fill = weight)) +
geom_raster() +
theme_bw() +
# Because we need the x and y axis to display every node,
# not just the nodes that have connections to each other,
# make sure that ggplot does not drop unused factor levels
scale_x_discrete(drop = FALSE, expand = c(0, 0)) +
scale_y_discrete(drop = FALSE, expand = c(0, 0)) +
# scale_fill_gradientn(colours = rev(brewer.pal(9,"RdYlBu")), na.value = "white", limit = c(-1.5, 1.5), oob = squish) +
scale_fill_gradientn(name = "Relative Interaction\nFrequency",
colours = brewer.pal(5,"BuPu"),
na.value = "white",
limit = c(-1, 1),
oob = squish) +
theme(axis.text = element_blank(),
axis.ticks = element_blank(),
axis.title = element_blank(),
aspect.ratio = 1,
# Hide the legend (optional)
legend.position = "none",
panel.border = element_rect(size = 1.5),
title = element_blank()) +
ggtitle(paste0("Group Size = ", groupsize))
# return graph
return(gg_avg_adj)
# return(avg_g)
})
multiplot(plotlist = interaction_graphs, layout = matrix(c(seq(1:length(interaction_graphs))), nrow=2, byrow=TRUE))
filename <- "Sigma0.0-Epsilon0.01-Bias1.01"
# Cutoff for threshold ratio to allow easier plotting
ThreshCutoffValue <- 10
ThreshCutoffReplacement <- Inf
ThreshCutoffReplacementColor <- 10
####################
# Load data
####################
# Load social
load("output/Rdata/Sigma0.0-Epsilon0.01-Bias1.01.Rdata")
soc_groups_graphs <- groups_graphs
soc_groups_threshMat <- groups_thresh
soc_graphs <- unlist(groups_graphs, recursive = FALSE)
soc_threshMat <- unlist(groups_thresh, recursive = FALSE)
soc_actMat <- unlist(groups_taskDist, recursive = FALSE)
social_graphs <- lapply(1:length(soc_graphs), function(i) {
# Calculated degree
degree <- rowSums(soc_graphs[[i]])
degree <- as.data.frame(degree)
degree$Id <- row.names(degree)
# Calculate thresholds
thresh <- soc_threshMat[[i]] %>%
as.data.frame(.) %>%
mutate(ThreshRatio = log(Thresh1 / Thresh2),
Id = row.names(.)) %>%
mutate(ThreshRatioRaw = ThreshRatio)
thresh$ThreshRatio[thresh$ThreshRatio > ThreshCutoffValue] <- ThreshCutoffReplacement
thresh$ThreshRatio[thresh$ThreshRatio < -ThreshCutoffValue] <- -ThreshCutoffReplacement
thresh$ThreshRatioColor <- thresh$ThreshRatio
thresh$ThreshRatioColor[thresh$ThreshRatio > ThreshCutoffValue] <- ThreshCutoffReplacementColor
thresh$ThreshRatioColor[thresh$ThreshRatio < -ThreshCutoffValue] <- -ThreshCutoffReplacementColor
# Calculate actibity
activity <- soc_actMat[[i]] %>%
as.data.frame(.) %>%
mutate(ActRatio = log(Task1 / Task2),
ActTotal = Task1 + Task2,
Id = row.names(.))
# Merge and return
mergedNodes <- merge(degree, thresh)
mergedNodes <- merge(mergedNodes, activity)
return(mergedNodes)
})
interaction_graphs <- lapply(1:length(soc_groups_graphs), function(i) {
# Get graphs
graphs <- soc_groups_graphs[[i]]
replicates <- length(graphs)
# For each each compute interaction matrix
# Get graph and make adjacency matrix
size_graph <- lapply(1:length(graphs), function(j) {
# Format: set diagonal, rescale, and make adj matrix
this_graph <- graphs[[j]]
diag(this_graph) <- NA
dimensions <- dim(this_graph)
labs <- colnames(this_graph)
this_graph <- as.vector(this_graph)
this_graph <- scale(this_graph)
this_graph <- matrix(data = this_graph, nrow = dimensions[1], ncol = dimensions[2])
colnames(this_graph) <- labs
rownames(this_graph) <- labs
# Calculate thresh ratio
ind <- replicates * i + j
thresh <- as.data.frame(soc_groups_threshMat[[i]][j])
thresh$ThreshRatio <- log(thresh$Thresh1 / thresh$Thresh2)
ratio <- order(thresh$ThreshRatio)
# Create order by threshold ratio
this_graph <- this_graph[ratio, ratio]
# return
return(this_graph)
})
# Avearge across all to make 'typical' adjacency matrix
avg_g <- Reduce("+", size_graph) / length(size_graph)
# Create graph object
g <- graph_from_adjacency_matrix(avg_g, mode = c("directed"), weighted = TRUE, diag = TRUE)
# Get node and edge list
node_list <- get.data.frame(g, what = "vertices")
edge_list <- get.data.frame(g, what = "edges")
# Create dataframe for plotting
plot_data <- edge_list %>% mutate(
to = factor(to, levels = node_list$name),
from = factor(from, levels = node_list$name))
# Plot
groupsize <- ncol(avg_g)
gg_avg_adj <- ggplot(plot_data, aes(x = from, y = to, fill = weight)) +
geom_raster() +
theme_bw() +
# Because we need the x and y axis to display every node,
# not just the nodes that have connections to each other,
# make sure that ggplot does not drop unused factor levels
scale_x_discrete(drop = FALSE, expand = c(0, 0)) +
scale_y_discrete(drop = FALSE, expand = c(0, 0)) +
# scale_fill_gradientn(colours = rev(brewer.pal(9,"RdYlBu")), na.value = "white", limit = c(-1.5, 1.5), oob = squish) +
scale_fill_gradientn(name = "Relative Interaction\nFrequency",
colours = brewer.pal(5,"BuPu"),
na.value = "white",
limit = c(-0.5, 0.5),
oob = squish) +
theme(axis.text = element_blank(),
axis.ticks = element_blank(),
axis.title = element_blank(),
aspect.ratio = 1,
# Hide the legend (optional)
legend.position = "none",
panel.border = element_rect(size = 1.5),
title = element_blank()) +
ggtitle(paste0("Group Size = ", groupsize))
# return graph
return(gg_avg_adj)
# return(avg_g)
})
png(filename = paste0("output/Networks/IntMat_", filename, ".png"), width = 5, height = 2.5, units = "in", res = 600)
multiplot(plotlist = interaction_graphs, layout = matrix(c(seq(1:length(interaction_graphs))), nrow=2, byrow=TRUE))
dev.off()
filename <- "Sigma0.0-Epsilon0.01-Bias1.05"
# Cutoff for threshold ratio to allow easier plotting
ThreshCutoffValue <- 10
ThreshCutoffReplacement <- Inf
ThreshCutoffReplacementColor <- 10
####################
# Load data
####################
# Load social
load("output/Rdata/Sigma0.0-Epsilon0.01-Bias1.05.Rdata")
soc_groups_graphs <- groups_graphs
soc_groups_threshMat <- groups_thresh
soc_graphs <- unlist(groups_graphs, recursive = FALSE)
soc_threshMat <- unlist(groups_thresh, recursive = FALSE)
soc_actMat <- unlist(groups_taskDist, recursive = FALSE)
social_graphs <- lapply(1:length(soc_graphs), function(i) {
# Calculated degree
degree <- rowSums(soc_graphs[[i]])
degree <- as.data.frame(degree)
degree$Id <- row.names(degree)
# Calculate thresholds
thresh <- soc_threshMat[[i]] %>%
as.data.frame(.) %>%
mutate(ThreshRatio = log(Thresh1 / Thresh2),
Id = row.names(.)) %>%
mutate(ThreshRatioRaw = ThreshRatio)
thresh$ThreshRatio[thresh$ThreshRatio > ThreshCutoffValue] <- ThreshCutoffReplacement
thresh$ThreshRatio[thresh$ThreshRatio < -ThreshCutoffValue] <- -ThreshCutoffReplacement
thresh$ThreshRatioColor <- thresh$ThreshRatio
thresh$ThreshRatioColor[thresh$ThreshRatio > ThreshCutoffValue] <- ThreshCutoffReplacementColor
thresh$ThreshRatioColor[thresh$ThreshRatio < -ThreshCutoffValue] <- -ThreshCutoffReplacementColor
# Calculate actibity
activity <- soc_actMat[[i]] %>%
as.data.frame(.) %>%
mutate(ActRatio = log(Task1 / Task2),
ActTotal = Task1 + Task2,
Id = row.names(.))
# Merge and return
mergedNodes <- merge(degree, thresh)
mergedNodes <- merge(mergedNodes, activity)
return(mergedNodes)
})
interaction_graphs <- lapply(1:length(soc_groups_graphs), function(i) {
# Get graphs
graphs <- soc_groups_graphs[[i]]
replicates <- length(graphs)
# For each each compute interaction matrix
# Get graph and make adjacency matrix
size_graph <- lapply(1:length(graphs), function(j) {
# Format: set diagonal, rescale, and make adj matrix
this_graph <- graphs[[j]]
diag(this_graph) <- NA
dimensions <- dim(this_graph)
labs <- colnames(this_graph)
this_graph <- as.vector(this_graph)
this_graph <- scale(this_graph)
this_graph <- matrix(data = this_graph, nrow = dimensions[1], ncol = dimensions[2])
colnames(this_graph) <- labs
rownames(this_graph) <- labs
# Calculate thresh ratio
ind <- replicates * i + j
thresh <- as.data.frame(soc_groups_threshMat[[i]][j])
thresh$ThreshRatio <- log(thresh$Thresh1 / thresh$Thresh2)
ratio <- order(thresh$ThreshRatio)
# Create order by threshold ratio
this_graph <- this_graph[ratio, ratio]
# return
return(this_graph)
})
# Avearge across all to make 'typical' adjacency matrix
avg_g <- Reduce("+", size_graph) / length(size_graph)
# Create graph object
g <- graph_from_adjacency_matrix(avg_g, mode = c("directed"), weighted = TRUE, diag = TRUE)
# Get node and edge list
node_list <- get.data.frame(g, what = "vertices")
edge_list <- get.data.frame(g, what = "edges")
# Create dataframe for plotting
plot_data <- edge_list %>% mutate(
to = factor(to, levels = node_list$name),
from = factor(from, levels = node_list$name))
# Plot
groupsize <- ncol(avg_g)
gg_avg_adj <- ggplot(plot_data, aes(x = from, y = to, fill = weight)) +
geom_raster() +
theme_bw() +
# Because we need the x and y axis to display every node,
# not just the nodes that have connections to each other,
# make sure that ggplot does not drop unused factor levels
scale_x_discrete(drop = FALSE, expand = c(0, 0)) +
scale_y_discrete(drop = FALSE, expand = c(0, 0)) +
# scale_fill_gradientn(colours = rev(brewer.pal(9,"RdYlBu")), na.value = "white", limit = c(-1.5, 1.5), oob = squish) +
scale_fill_gradientn(name = "Relative Interaction\nFrequency",
colours = brewer.pal(5,"BuPu"),
na.value = "white",
limit = c(-0.5, 0.5),
oob = squish) +
theme(axis.text = element_blank(),
axis.ticks = element_blank(),
axis.title = element_blank(),
aspect.ratio = 1,
# Hide the legend (optional)
legend.position = "none",
panel.border = element_rect(size = 1.5),
title = element_blank()) +
ggtitle(paste0("Group Size = ", groupsize))
# return graph
return(gg_avg_adj)
# return(avg_g)
})
png(filename = paste0("output/Networks/IntMat_", filename, ".png"), width = 5, height = 2.5, units = "in", res = 600)
multiplot(plotlist = interaction_graphs, layout = matrix(c(seq(1:length(interaction_graphs))), nrow=2, byrow=TRUE))
dev.off()
filename <- "Sigma0.05-Epsilon0.01-Bias1.1-Delta0.8"
rm(list = ls())
source("scripts/__Util__MASTER.R")
library(RColorBrewer)
library(scales)
library(igraph)
filename <- "Sigma0.05-Epsilon0.01-Bias1.1-Delta0.8"
# Cutoff for threshold ratio to allow easier plotting
ThreshCutoffValue <- 10
ThreshCutoffReplacement <- Inf
ThreshCutoffReplacementColor <- 10
####################
# Load data
####################
# Load social
load("output/Rdata/Sigma0.05-Epsilon0.01-Bias1.1-Delta0.8.Rdata")
soc_groups_graphs <- groups_graphs
soc_groups_threshMat <- groups_thresh
soc_graphs <- unlist(groups_graphs, recursive = FALSE)
soc_threshMat <- unlist(groups_thresh, recursive = FALSE)
soc_actMat <- unlist(groups_taskDist, recursive = FALSE)
social_graphs <- lapply(1:length(soc_graphs), function(i) {
# Calculated degree
degree <- rowSums(soc_graphs[[i]])
degree <- as.data.frame(degree)
degree$Id <- row.names(degree)
# Calculate thresholds
thresh <- soc_threshMat[[i]] %>%
as.data.frame(.) %>%
mutate(ThreshRatio = log(Thresh1 / Thresh2),
Id = row.names(.)) %>%
mutate(ThreshRatioRaw = ThreshRatio)
thresh$ThreshRatio[thresh$ThreshRatio > ThreshCutoffValue] <- ThreshCutoffReplacement
thresh$ThreshRatio[thresh$ThreshRatio < -ThreshCutoffValue] <- -ThreshCutoffReplacement
thresh$ThreshRatioColor <- thresh$ThreshRatio
thresh$ThreshRatioColor[thresh$ThreshRatio > ThreshCutoffValue] <- ThreshCutoffReplacementColor
thresh$ThreshRatioColor[thresh$ThreshRatio < -ThreshCutoffValue] <- -ThreshCutoffReplacementColor
# Calculate actibity
activity <- soc_actMat[[i]] %>%
as.data.frame(.) %>%
mutate(ActRatio = log(Task1 / Task2),
ActTotal = Task1 + Task2,
Id = row.names(.))
# Merge and return
mergedNodes <- merge(degree, thresh)
mergedNodes <- merge(mergedNodes, activity)
return(mergedNodes)
})
interaction_graphs <- lapply(1:length(soc_groups_graphs), function(i) {
# Get graphs
graphs <- soc_groups_graphs[[i]]
replicates <- length(graphs)
# For each each compute interaction matrix
# Get graph and make adjacency matrix
size_graph <- lapply(1:length(graphs), function(j) {
# Format: set diagonal, rescale, and make adj matrix
this_graph <- graphs[[j]]
diag(this_graph) <- NA
dimensions <- dim(this_graph)
labs <- colnames(this_graph)
this_graph <- as.vector(this_graph)
this_graph <- scale(this_graph)
this_graph <- matrix(data = this_graph, nrow = dimensions[1], ncol = dimensions[2])
colnames(this_graph) <- labs
rownames(this_graph) <- labs
# Calculate thresh ratio
ind <- replicates * i + j
thresh <- as.data.frame(soc_groups_threshMat[[i]][j])
thresh$ThreshRatio <- log(thresh$Thresh1 / thresh$Thresh2)
ratio <- order(thresh$ThreshRatio)
# Create order by threshold ratio
this_graph <- this_graph[ratio, ratio]
# return
return(this_graph)
})
# Avearge across all to make 'typical' adjacency matrix
avg_g <- Reduce("+", size_graph) / length(size_graph)
# Create graph object
g <- graph_from_adjacency_matrix(avg_g, mode = c("directed"), weighted = TRUE, diag = TRUE)
# Get node and edge list
node_list <- get.data.frame(g, what = "vertices")
edge_list <- get.data.frame(g, what = "edges")
# Create dataframe for plotting
plot_data <- edge_list %>% mutate(
to = factor(to, levels = node_list$name),
from = factor(from, levels = node_list$name))
# Plot
groupsize <- ncol(avg_g)
gg_avg_adj <- ggplot(plot_data, aes(x = from, y = to, fill = weight)) +
geom_raster() +
theme_bw() +
# Because we need the x and y axis to display every node,
# not just the nodes that have connections to each other,
# make sure that ggplot does not drop unused factor levels
scale_x_discrete(drop = FALSE, expand = c(0, 0)) +
scale_y_discrete(drop = FALSE, expand = c(0, 0)) +
# scale_fill_gradientn(colours = rev(brewer.pal(9,"RdYlBu")), na.value = "white", limit = c(-1.5, 1.5), oob = squish) +
scale_fill_gradientn(name = "Relative Interaction\nFrequency",
colours = brewer.pal(5,"BuPu"),
na.value = "white",
limit = c(-0.5, 0.5),
oob = squish) +
theme(axis.text = element_blank(),
axis.ticks = element_blank(),
axis.title = element_blank(),
aspect.ratio = 1,
# Hide the legend (optional)
legend.position = "none",
panel.border = element_rect(size = 1.5),
title = element_blank()) +
ggtitle(paste0("Group Size = ", groupsize))
# return graph
return(gg_avg_adj)
# return(avg_g)
})
png(filename = paste0("output/Networks/IntMat_", filename, ".png"), width = 5, height = 2.5, units = "in", res = 600)
multiplot(plotlist = interaction_graphs, layout = matrix(c(seq(1:length(interaction_graphs))), nrow=2, byrow=TRUE))
dev.off()
