axis.ticks = element_line(size = 0.3, color = "black"),
panel.border = element_rect(colour = "black", fill = NA, size = 0.3),
legend.position = "none")
gg_analytical_betaeps
gg_comp <- ggplot(entropy_data, aes(x = epsilon, y = Mean, group = Model, color = Model)) +
# geom_vline(xintercept = 0.5659957, size = 0.3, linetype = "dashed") + #analytical result for epsilon*
geom_vline(xintercept = 0.4969125, size = 0.3, linetype = "dashed", color = "grey40") + #analytical result for epsilon*
geom_vline(xintercept = 0, size = 0.3, linetype = "dashed", color = "grey40") + #analytical result for epsilon*
geom_errorbar(aes(ymin = ifelse((Mean - SD) > 0, Mean - SD, 0), ymax = Mean + SD),
width = 0,
size = 0.3) +
geom_point(aes(y = Mean),
size = 0.8) +
theme_classic() +
xlab(expression(paste("Social influence (", italic(epsilon), ")"))) +
ylab(expression(paste("Division of labor (", italic(D[indiv]), ")"))) +
scale_color_manual(name = "Thresh. limits",
values = c("#a6cee3", "#1f78b4"),
labels = c(expression(paste("[0, ", infinity, ")")), "[0, 100]")) +
# ggtitle(expression(paste(italic(epsilon), "= 0.4, ", italic(beta), "= 1.1"))) +
scale_x_continuous(breaks = seq(0, 0.6, 0.1)) +
theme(title = element_text(size = 6),
axis.text = element_text(colour = "black", size = 6),
axis.title = element_text(size = 7, face = "italic"),
legend.position = c(0.3, 0.2),
legend.title = element_text(size = 6,
face = "bold",
hjust = 5),
legend.text = element_text(size = 6),
legend.key.height = unit(2, "mm"),
legend.key.width = unit(3, "mm"),
legend.background = element_blank(),
axis.ticks = element_line(size = 0.3, color = "black"),
axis.line = element_line(size = 0.3, color = "black"),
aspect.ratio = 1)
gg_comp
################################################################################
#
# Testing whether the threshold limit is causing artifacts for high social influence
#
################################################################################
#
# Here we are testing wehther the decrease in DOL at high levels of social influence
# is due to the upper limit on threhsold values. In this simulation, we put the upper bound
# for threshold at 1000, instead of the normal 100.
rm(list = ls())
source("scripts/util/__Util__MASTER.R")
# ------------------------------ DOL by epsilon----------------------
####################
# Load and process data
####################
load('output/Rdata/_ProcessedData/Entropy/Sigma0-Beta1.1_EpsSweep-NoThreshLimit.Rdata')
high_thresh <- compiled_data %>%
mutate(Model = "high_thresh") %>%
group_by(Model, epsilon, beta) %>%
summarise(Mean = mean(Dind),
SD = sd(Dind)) %>%
as.data.frame() %>%
mutate(epsilon = round(epsilon, digits = 3))
load("output/ParameterSpace/EpsilonBetaSweep-n80.Rdata")
normal_thresh <- entropy %>%
mutate(Model = "normal_thresh") %>%
filter(beta == 1.1) %>%
select(Model, epsilon, beta, Dind_mean, Dind_SD)
names(normal_thresh) <- c("Model", "epsilon", "beta", "Mean", "SD")
eps_values <- unique(normal_thresh$epsilon)
entropy_data <- rbind(high_thresh, normal_thresh)
entropy_data <- entropy_data %>%
filter(epsilon %in% eps_values)
####################
# Plot entropy plots
####################
gg_comp <- ggplot(entropy_data, aes(x = epsilon, y = Mean, group = Model, color = Model)) +
# geom_vline(xintercept = 0.5659957, size = 0.3, linetype = "dashed") + #analytical result for epsilon*
geom_vline(xintercept = 0.4969125, size = 0.3, linetype = "dashed", color = "grey40") + #analytical result for epsilon*
geom_vline(xintercept = 0, size = 0.3, linetype = "dashed", color = "grey40") + #analytical result for epsilon*
geom_errorbar(aes(ymin = ifelse((Mean - SD) > 0, Mean - SD, 0), ymax = Mean + SD),
width = 0,
size = 0.3) +
geom_point(aes(y = Mean),
size = 0.8) +
theme_classic() +
xlab(expression(paste("Social influence (", italic(epsilon), ")"))) +
ylab(expression(paste("Division of labor (", italic(D[indiv]), ")"))) +
scale_color_manual(name = "Thresh. limits",
values = c("#a6cee3", "#1f78b4"),
labels = c(expression(paste("[0, ", infinity, ")")), "[0, 100]")) +
# ggtitle(expression(paste(italic(epsilon), "= 0.4, ", italic(beta), "= 1.1"))) +
scale_x_continuous(breaks = seq(0, 0.6, 0.1)) +
theme(title = element_text(size = 6),
axis.text = element_text(colour = "black", size = 6),
axis.title = element_text(size = 7, face = "italic"),
legend.position = c(0.3, 0.2),
legend.title = element_text(size = 6,
face = "bold",
hjust = 5),
legend.text = element_text(size = 6),
legend.key.height = unit(2, "mm"),
legend.key.width = unit(3, "mm"),
legend.background = element_blank(),
axis.ticks = element_line(size = 0.3, color = "black"),
axis.line = element_line(size = 0.3, color = "black"),
aspect.ratio = 1)
gg_comp
ggsave(gg_comp, file = "output/SpecializationPlots/ThresholdLimitComparison.png", height = 45, width = 45, units = "mm")
ggsave(gg_comp, file = "output/SpecializationPlots/ThresholdLimitComparison.svg", height = 45, width = 45, units = "mm")
# Calculate epsilon* for absolute loss of DOL (test?)
n_1 <- delta / 2 * n + 1
rm(list = ls())
####################
# Source necessary scripts/libraries
####################
source("scripts/util/__Util__MASTER.R")
library(scales)
####################
# calculate epsilon* and beta* for n = 80 with infinite threshold limit
####################
# Let's assume all individuals are doing task 1 (or are inactive)
# Set parameters
tau <- 0.2
n <- 80
m <- 2
delta <- 0.8
beta <- seq(1, 1.25, 0.0001)
freq_activ <- delta
# freq_activ <- 1 / (1+tau)
n_1 <- freq_activ * n
rm(list = ls())
####################
# Source necessary scripts/libraries
####################
source("scripts/util/__Util__MASTER.R")
library(scales)
####################
# calculate epsilon* and beta* for n = 80 with infinite threshold limit
####################
# Let's assume all individuals are doing task 1 (or are inactive)
# Set parameters
tau <- 0.2
n <- 80
m <- 2
delta <- 0.8
beta <- seq(1, 1.25, 0.0001)
freq_activ <- delta
# freq_activ <- 1 / (1+tau)
n_1 <- freq_activ * n
beta_star_value <- (delta * n) / (delta * n - m)
# Calculate epsilon* for absolute loss of DOL (test?)
n_1 <- delta / 2 * n + 1
80*0.4
n_2 <- delta / 2 * n - 1
i = 1001
beta[i]
E_01 <- n_1 / (n_1 + (n - n_1)) +  n_1 * ( (1) / (beta[i] * (n_1 - 1) + (n - n_1)) )  # expected number of interaction partners performing task 1 if i is inactive
E_02 <- n_2 / (n_2 + (n - n_2)) +  n_2 * ( (1) / (beta[i] * (n_2 - 1) + (n - n_2)) )  # expected number of interaction partners performing task 2 if i is inactive
E_11 <- 2*beta[i]*(n_1 - 1) / (beta[i] * (n_1 - 1) + (n - n_1)) # expected number of interaction partners performing task 1 if i is task 1
E_12 <- n_2 / (beta[i] * (n_1 - 1) + (n - n_1)) + n_2 * ( (1) / (beta[i] * (n_2 - 1) + (n - n_2)) )  # expected number of interaction partners performing task 1 if i is task 1
eps_delta_inac <- delta / (E_01 - E_02)
eps_delta_ac <- delta / (E_11 - E_12)
eps_star_absolute$epsilon_all[i] <- delta / (freq_activ * (E_11 - E_12) + (1 - freq_activ) * (E_01 - E_02))
eps_star_absolute <- data.frame(beta = beta,
epsilon_inac = rep(NA, length(beta)),
epsilon_ac = rep(NA, length(beta)),
# epsilon_e11_e01_ratio = rep(NA, length(beta)),
epsilon_all = rep(NA, length(beta)))
delta / (freq_activ * (E_11 - E_12) + (1 - freq_activ) * (E_01 - E_02))
for (i in 1:nrow(eps_star_test)) {
E_01 <- n_1 / (n_1 + (n - n_1)) +  n_1 * ( (1) / (beta[i] * (n_1 - 1) + (n - n_1)) )  # expected number of interaction partners performing task 1 if i is inactive
E_02 <- n_2 / (n_2 + (n - n_2)) +  n_2 * ( (1) / (beta[i] * (n_2 - 1) + (n - n_2)) )  # expected number of interaction partners performing task 2 if i is inactive
E_11 <- 2*beta[i]*(n_1 - 1) / (beta[i] * (n_1 - 1) + (n - n_1)) # expected number of interaction partners performing task 1 if i is task 1
E_12 <- n_2 / (beta[i] * (n_1 - 1) + (n - n_1)) + n_2 * ( (1) / (beta[i] * (n_2 - 1) + (n - n_2)) )  # expected number of interaction partners performing task 1 if i is task 1
eps_delta_inac <- delta / (E_01 - E_02)
eps_delta_ac <- delta / (E_11 - E_12)
eps_star_absolute$epsilon_inac[i] <- eps_01
eps_star_absolute$epsilon_ac[i] <- eps_11
eps_star_absolute$epsilon_all[i] <- delta / (freq_activ * (E_11 - E_12) + (1 - freq_activ) * (E_01 - E_02))
}
for (i in 1:nrow(eps_star_absolute)) {
E_01 <- n_1 / (n_1 + (n - n_1)) +  n_1 * ( (1) / (beta[i] * (n_1 - 1) + (n - n_1)) )  # expected number of interaction partners performing task 1 if i is inactive
E_02 <- n_2 / (n_2 + (n - n_2)) +  n_2 * ( (1) / (beta[i] * (n_2 - 1) + (n - n_2)) )  # expected number of interaction partners performing task 2 if i is inactive
E_11 <- 2*beta[i]*(n_1 - 1) / (beta[i] * (n_1 - 1) + (n - n_1)) # expected number of interaction partners performing task 1 if i is task 1
E_12 <- n_2 / (beta[i] * (n_1 - 1) + (n - n_1)) + n_2 * ( (1) / (beta[i] * (n_2 - 1) + (n - n_2)) )  # expected number of interaction partners performing task 1 if i is task 1
eps_delta_inac <- delta / (E_01 - E_02)
eps_delta_ac <- delta / (E_11 - E_12)
eps_star_absolute$epsilon_inac[i] <- eps_01
eps_star_absolute$epsilon_ac[i] <- eps_11
eps_star_absolute$epsilon_all[i] <- delta / (freq_activ * (E_11 - E_12) + (1 - freq_activ) * (E_01 - E_02))
}
for (i in 1:nrow(eps_star_absolute)) {
E_01 <- n_1 / (n_1 + (n - n_1)) +  n_1 * ( (1) / (beta[i] * (n_1 - 1) + (n - n_1)) )  # expected number of interaction partners performing task 1 if i is inactive
E_02 <- n_2 / (n_2 + (n - n_2)) +  n_2 * ( (1) / (beta[i] * (n_2 - 1) + (n - n_2)) )  # expected number of interaction partners performing task 2 if i is inactive
E_11 <- 2*beta[i]*(n_1 - 1) / (beta[i] * (n_1 - 1) + (n - n_1)) # expected number of interaction partners performing task 1 if i is task 1
E_12 <- n_2 / (beta[i] * (n_1 - 1) + (n - n_1)) + n_2 * ( (1) / (beta[i] * (n_2 - 1) + (n - n_2)) )  # expected number of interaction partners performing task 1 if i is task 1
eps_delta_inac <- delta / (E_01 - E_02)
eps_delta_ac <- delta / (E_11 - E_12)
eps_star_absolute$epsilon_inac[i] <- eps_delta_inac
eps_star_absolute$epsilon_ac[i] <- eps_delta_ac
eps_star_absolute$epsilon_all[i] <- delta / (freq_activ * (E_11 - E_12) + (1 - freq_activ) * (E_01 - E_02))
}
plot(eps_star_absolute$beta, eps_star_absolute$epsilon_all)
plot(eps_star_absolute$beta, eps_star_absolute$epsilon_inac)
plot(eps_star_absolute$beta, eps_star_absolute$epsilon_ac)
i = 2001
beta[i]
E_01 <- n_1 / (n_1 + (n - n_1)) +  n_1 * ( (1) / (beta[i] * (n_1 - 1) + (n - n_1)) )  # expected number of interaction partners performing task 1 if i is inactive
E_02 <- n_2 / (n_2 + (n - n_2)) +  n_2 * ( (1) / (beta[i] * (n_2 - 1) + (n - n_2)) )  # expected number of interaction partners performing task 2 if i is inactive
E_11 <- 2*beta[i]*(n_1 - 1) / (beta[i] * (n_1 - 1) + (n - n_1)) # expected number of interaction partners performing task 1 if i is task 1
E_12 <- n_2 / (beta[i] * (n_1 - 1) + (n - n_1)) + n_2 * ( (1) / (beta[i] * (n_2 - 1) + (n - n_2)) )  # expected number of interaction partners performing task 1 if i is task 1
eps_delta_inac <- delta / (E_01 - E_02)
n_1 <- delta - 1
n_2 <- 1
# Calculate epsilon* for absolute loss of DOL (test?)
n_1 <- delta * n - 1
n_1 <- delta * n - 1
n_2 <- 1
eps_star_absolute <- data.frame(beta = beta,
epsilon_inac = rep(NA, length(beta)),
epsilon_ac = rep(NA, length(beta)),
# epsilon_e11_e01_ratio = rep(NA, length(beta)),
epsilon_all = rep(NA, length(beta)))
for (i in 1:nrow(eps_star_absolute)) {
E_01 <- n_1 / (n_1 + (n - n_1)) +  n_1 * ( (1) / (beta[i] * (n_1 - 1) + (n - n_1)) )  # expected number of interaction partners performing task 1 if i is inactive
E_02 <- n_2 / (n_2 + (n - n_2)) +  n_2 * ( (1) / (beta[i] * (n_2 - 1) + (n - n_2)) )  # expected number of interaction partners performing task 2 if i is inactive
E_11 <- 2*beta[i]*(n_1 - 1) / (beta[i] * (n_1 - 1) + (n - n_1)) # expected number of interaction partners performing task 1 if i is task 1
E_12 <- n_2 / (beta[i] * (n_1 - 1) + (n - n_1)) + n_2 * ( (1) / (beta[i] * (n_2 - 1) + (n - n_2)) )  # expected number of interaction partners performing task 1 if i is task 1
eps_delta_inac <- delta / (E_01 - E_02)
eps_delta_ac <- delta / (E_11 - E_12)
eps_star_absolute$epsilon_inac[i] <- eps_delta_inac
eps_star_absolute$epsilon_ac[i] <- eps_delta_ac
eps_star_absolute$epsilon_all[i] <- delta / (freq_activ * (E_11 - E_12) + (1 - freq_activ) * (E_01 - E_02))
}
plot(eps_star_absolute$beta, eps_star_absolute$epsilon_ac)
plot(eps_star_absolute$beta, eps_star_absolute$epsilon_all)
# Calculate epsilon* for absolute loss of DOL (test?)
n_1 <- delta/2 * n + 1
n_2 <- delta/2 * n -1
eps_star_absolute <- data.frame(beta = beta,
epsilon_inac = rep(NA, length(beta)),
epsilon_ac = rep(NA, length(beta)),
# epsilon_e11_e01_ratio = rep(NA, length(beta)),
epsilon_all = rep(NA, length(beta)))
for (i in 1:nrow(eps_star_absolute)) {
E_01 <- n_1 / (n_1 + (n - n_1)) +  n_1 * ( (1) / (beta[i] * (n_1 - 1) + (n - n_1)) )  # expected number of interaction partners performing task 1 if i is inactive
E_02 <- n_2 / (n_2 + (n - n_2)) +  n_2 * ( (1) / (beta[i] * (n_2 - 1) + (n - n_2)) )  # expected number of interaction partners performing task 2 if i is inactive
E_11 <- 2*beta[i]*(n_1 - 1) / (beta[i] * (n_1 - 1) + (n - n_1)) # expected number of interaction partners performing task 1 if i is task 1
E_12 <- n_2 / (beta[i] * (n_1 - 1) + (n - n_1)) + n_2 * ( (1) / (beta[i] * (n_2 - 1) + (n - n_2)) )  # expected number of interaction partners performing task 1 if i is task 1
eps_delta_inac <- delta / (E_01 - E_02)
eps_delta_ac <- delta / (E_11 - E_12)
eps_star_absolute$epsilon_inac[i] <- eps_delta_inac
eps_star_absolute$epsilon_ac[i] <- eps_delta_ac
eps_star_absolute$epsilon_all[i] <- delta / (freq_activ * (E_11 - E_12) + (1 - freq_activ) * (E_01 - E_02))
}
plot(eps_star_absolute$beta, eps_star_absolute$epsilon_all)
plot(eps_star_absolute$beta, eps_star_absolute$epsilon_inac)
for (i in 1:nrow(eps_star_absolute)) {
E_01 <- n_1 / (n_1 + (n - n_1)) +  n_1 * ( (1) / (beta[i] * (n_1 - 1) + (n - n_1)) )  # expected number of interaction partners performing task 1 if i is inactive
E_02 <- n_2 / (n_2 + (n - n_2)) +  n_2 * ( (1) / (beta[i] * (n_2 - 1) + (n - n_2)) )  # expected number of interaction partners performing task 2 if i is inactive
E_11 <- 2*beta[i]*(n_1 - 1) / (beta[i] * (n_1 - 1) + (n - n_1)) # expected number of interaction partners performing task 1 if i is task 1
E_12 <- n_2 / (beta[i] * (n_1 - 1) + (n - n_1)) + n_2 * ( (1) / (beta[i] * (n_2 - 1) + (n - n_2)) )  # expected number of interaction partners performing task 1 if i is task 1
eps_delta_inac <- delta / (E_01 - E_02)
eps_delta_ac <- delta / (E_11 - E_12)
eps_star_absolute$epsilon_inac[i] <- eps_delta_inac
eps_star_absolute$epsilon_ac[i] <- eps_delta_ac
eps_star_absolute$epsilon_all[i] <- delta * eps_delta_ac + (1 - delta) * eps_delta_inac
# eps_star_absolute$epsilon_all[i] <- delta / (freq_activ * (E_11 - E_12) + (1 - freq_activ) * (E_01 - E_02))
}
plot(eps_star_absolute$beta, eps_star_absolute$epsilon_all)
for (i in 1:nrow(eps_star_absolute)) {
E_01 <- n_1 / (n_1 + (n - n_1)) +  n_1 * ( (1) / (beta[i] * (n_1 - 1) + (n - n_1)) )  # expected number of interaction partners performing task 1 if i is inactive
E_02 <- n_2 / (n_2 + (n - n_2)) +  n_2 * ( (1) / (beta[i] * (n_2 - 1) + (n - n_2)) )  # expected number of interaction partners performing task 2 if i is inactive
E_11 <- 2*beta[i]*(n_1 - 1) / (beta[i] * (n_1 - 1) + (n - n_1)) # expected number of interaction partners performing task 1 if i is task 1
E_12 <- n_2 / (beta[i] * (n_1 - 1) + (n - n_1)) + n_2 * ( (1) / (beta[i] * (n_2 - 1) + (n - n_2)) )  # expected number of interaction partners performing task 1 if i is task 1
eps_delta_inac <- delta / (E_01 - E_02)
eps_delta_ac <- delta / (E_11 - E_12)
eps_star_absolute$epsilon_inac[i] <- eps_delta_inac
eps_star_absolute$epsilon_ac[i] <- eps_delta_ac
eps_star_absolute$epsilon_all[i] <- delta * eps_delta_ac + (1 - delta) * eps_delta_inac
# eps_star_absolute$epsilon_all[i] <- delta / (freq_activ * (E_11 - E_12) + (1 - freq_activ) * (E_01 - E_02))
}
plot(eps_star_absolute$beta, eps_star_absolute$epsilon_all)
plot(eps_star_absolute$beta, eps_star_absolute$epsilon_all)
plot(eps_star_absolute$beta, eps_star_absolute$epsilon_ac)
plot(eps_star_absolute$beta, eps_star_absolute$epsilon_inac)
i
delta * eps_delta_ac + (1 - delta) * eps_delta_inac
delta / (freq_activ * (E_11 - E_12) + (1 - freq_activ) * (E_01 - E_02))
E_01 <- n_1 / (n_1 + (n - n_1)) +  n_1 * ( (1) / (beta[i] * (n_1 - 1) + (n - n_1)) )  # expected number of interaction partners performing task 1 if i is inactive
E_02 <- n_2 / (n_2 + (n - n_2)) +  n_2 * ( (1) / (beta[i] * (n_2 - 1) + (n - n_2)) )  # expected number of interaction partners performing task 2 if i is inactive
E_11 <- 2*beta[i]*(n_1 - 1) / (beta[i] * (n_1 - 1) + (n - n_1)) # expected number of interaction partners performing task 1 if i is task 1
E_12 <- n_2 / (beta[i] * (n_1 - 1) + (n - n_1)) + n_2 * ( (1) / (beta[i] * (n_2 - 1) + (n - n_2)) )  # expected number of interaction partners performing task 1 if i is task 1
eps_delta_inac <- delta / (E_01 - E_02)
eps_delta_ac <- delta / (E_11 - E_12)
eps_star_absolute$epsilon_inac[i] <- eps_delta_inac
eps_star_absolute$epsilon_ac[i] <- eps_delta_ac
delta * eps_delta_ac + (1 - delta) * eps_delta_inac
delta / (freq_activ * (E_11 - E_12) + (1 - freq_activ) * (E_01 - E_02))
i = 1
E_01 <- n_1 / (n_1 + (n - n_1)) +  n_1 * ( (1) / (beta[i] * (n_1 - 1) + (n - n_1)) )  # expected number of interaction partners performing task 1 if i is inactive
E_02 <- n_2 / (n_2 + (n - n_2)) +  n_2 * ( (1) / (beta[i] * (n_2 - 1) + (n - n_2)) )  # expected number of interaction partners performing task 2 if i is inactive
E_11 <- 2*beta[i]*(n_1 - 1) / (beta[i] * (n_1 - 1) + (n - n_1)) # expected number of interaction partners performing task 1 if i is task 1
E_12 <- n_2 / (beta[i] * (n_1 - 1) + (n - n_1)) + n_2 * ( (1) / (beta[i] * (n_2 - 1) + (n - n_2)) )  # expected number of interaction partners performing task 1 if i is task 1
eps_delta_inac <- delta / (E_01 - E_02)
eps_delta_ac <- delta / (E_11 - E_12)
delta * eps_delta_ac + (1 - delta) * eps_delta_inac
delta / (freq_activ * (E_11 - E_12) + (1 - freq_activ) * (E_01 - E_02))
################################################################################
#
# Social interaction model: calculate epsilon* (analytical calculations)
#
################################################################################
rm(list = ls())
####################
# Source necessary scripts/libraries
####################
source("scripts/util/__Util__MASTER.R")
library(scales)
####################
# calculate epsilon* and beta* for n = 80 with infinite threshold limit
####################
# Let's assume all individuals are doing task 1 (or are inactive)
# Set parameters
tau <- 0.2
n <- 80
m <- 2
delta <- 0.8
beta <- seq(1, 1.25, 0.0001)
freq_activ <- delta
# freq_activ <- 1 / (1+tau)
n_1 <- freq_activ * n
beta_star_value <- (delta * n) / (delta * n - m)
# Calculate beta* and epsilon*
beta_star <- data.frame(epsilon = seq(0, 0.6, 0.01),
beta = rep(beta_star_value, length(seq(0, 0.6, 0.01))))
eps_star <- data.frame(beta = beta,
epsilon_inac = rep(NA, length(beta)),
epsilon_ac = rep(NA, length(beta)),
# epsilon_e11_e01_ratio = rep(NA, length(beta)),
epsilon_all = rep(NA, length(beta)))
for (i in 1:nrow(eps_star)) {
E_01 <- n_1 / (n_1 + (n - n_1)) +  n_1 * ( (1) / (beta[i] * (n_1 - 1) + (n - n_1)) )  # expected number of interaction partners performing task 1 if i is inactive
E_11 <- 2*beta[i]*(n_1 - 1) / (beta[i] * (n_1 - 1) + (n - n_1)) # expected number of interaction partners performing task 1 if i is task 1
eps_01 <- delta / E_01
eps_11 <- delta / E_11
eps_star$epsilon_inac[i] <- eps_01
eps_star$epsilon_ac[i] <- eps_11
eps_star$epsilon_all[i] <- delta / (freq_activ * E_11 + (1 - freq_activ) * E_01)
}
eps_star$epsilon_all[eps_star$beta == 1.1]
# Calculate epsilon* for absolute loss of DOL (test?)
n_1 <- delta/2 * n + 10
n_2 <- delta/2 * n -10
eps_star_absolute <- data.frame(beta = beta,
epsilon_inac = rep(NA, length(beta)),
epsilon_ac = rep(NA, length(beta)),
# epsilon_e11_e01_ratio = rep(NA, length(beta)),
epsilon_all = rep(NA, length(beta)))
for (i in 1:nrow(eps_star_absolute)) {
E_01 <- n_1 / (n_1 + (n - n_1)) +  n_1 * ( (1) / (beta[i] * (n_1 - 1) + (n - n_1)) )  # expected number of interaction partners performing task 1 if i is inactive
E_02 <- n_2 / (n_2 + (n - n_2)) +  n_2 * ( (1) / (beta[i] * (n_2 - 1) + (n - n_2)) )  # expected number of interaction partners performing task 2 if i is inactive
E_11 <- 2*beta[i]*(n_1 - 1) / (beta[i] * (n_1 - 1) + (n - n_1)) # expected number of interaction partners performing task 1 if i is task 1
E_12 <- n_2 / (beta[i] * (n_1 - 1) + (n - n_1)) + n_2 * ( (1) / (beta[i] * (n_2 - 1) + (n - n_2)) )  # expected number of interaction partners performing task 1 if i is task 1
eps_delta_inac <- delta / (E_01 - E_02)
eps_delta_ac <- delta / (E_11 - E_12)
eps_star_absolute$epsilon_inac[i] <- eps_delta_inac
eps_star_absolute$epsilon_ac[i] <- eps_delta_ac
eps_star_absolute$epsilon_all[i] <- delta / (freq_activ * (E_11 - E_12) + (1 - freq_activ) * (E_01 - E_02))
eps_star_absolute$epsilon_from2[i] <- delta / (freq_activ * (E_11 - E_12) + (1 - freq_activ) * (E_01 - E_02))
}
plot(eps_star_absolute$beta, eps_star_absolute$epsilon_all)
n_1 <- delta * n -2
n_2 <- 2
eps_star_absolute <- data.frame(beta = beta,
epsilon_inac = rep(NA, length(beta)),
epsilon_ac = rep(NA, length(beta)),
# epsilon_e11_e01_ratio = rep(NA, length(beta)),
epsilon_all = rep(NA, length(beta)))
for (i in 1:nrow(eps_star_absolute)) {
E_01 <- n_1 / (n_1 + (n - n_1)) +  n_1 * ( (1) / (beta[i] * (n_1 - 1) + (n - n_1)) )  # expected number of interaction partners performing task 1 if i is inactive
E_02 <- n_2 / (n_2 + (n - n_2)) +  n_2 * ( (1) / (beta[i] * (n_2 - 1) + (n - n_2)) )  # expected number of interaction partners performing task 2 if i is inactive
E_11 <- 2*beta[i]*(n_1 - 1) / (beta[i] * (n_1 - 1) + (n - n_1)) # expected number of interaction partners performing task 1 if i is task 1
E_12 <- n_2 / (beta[i] * (n_1 - 1) + (n - n_1)) + n_2 * ( (1) / (beta[i] * (n_2 - 1) + (n - n_2)) )  # expected number of interaction partners performing task 1 if i is task 1
eps_delta_inac <- delta / (E_01 - E_02)
eps_delta_ac <- delta / (E_11 - E_12)
eps_star_absolute$epsilon_inac[i] <- eps_delta_inac
eps_star_absolute$epsilon_ac[i] <- eps_delta_ac
eps_star_absolute$epsilon_all[i] <- delta / (freq_activ * (E_11 - E_12) + (1 - freq_activ) * (E_01 - E_02))
eps_star_absolute$epsilon_from2[i] <- delta / (freq_activ * (E_11 - E_12) + (1 - freq_activ) * (E_01 - E_02))
}
plot(eps_star_absolute$beta, eps_star_absolute$epsilon_all)
eps_star$epsilon_all[eps_star$beta == 1.1]
eps_star_absolute$epsilon_all[eps_star$beta == 1.1]
n_1 <- delta * n - 4
n_2 <- 4
eps_star_absolute <- data.frame(beta = beta,
epsilon_inac = rep(NA, length(beta)),
epsilon_ac = rep(NA, length(beta)),
# epsilon_e11_e01_ratio = rep(NA, length(beta)),
epsilon_all = rep(NA, length(beta)))
for (i in 1:nrow(eps_star_absolute)) {
E_01 <- n_1 / (n_1 + (n - n_1)) +  n_1 * ( (1) / (beta[i] * (n_1 - 1) + (n - n_1)) )  # expected number of interaction partners performing task 1 if i is inactive
E_02 <- n_2 / (n_2 + (n - n_2)) +  n_2 * ( (1) / (beta[i] * (n_2 - 1) + (n - n_2)) )  # expected number of interaction partners performing task 2 if i is inactive
E_11 <- 2*beta[i]*(n_1 - 1) / (beta[i] * (n_1 - 1) + (n - n_1)) # expected number of interaction partners performing task 1 if i is task 1
E_12 <- n_2 / (beta[i] * (n_1 - 1) + (n - n_1)) + n_2 * ( (1) / (beta[i] * (n_2 - 1) + (n - n_2)) )  # expected number of interaction partners performing task 1 if i is task 1
eps_delta_inac <- delta / (E_01 - E_02)
eps_delta_ac <- delta / (E_11 - E_12)
eps_star_absolute$epsilon_inac[i] <- eps_delta_inac
eps_star_absolute$epsilon_ac[i] <- eps_delta_ac
eps_star_absolute$epsilon_all[i] <- delta / (freq_activ * (E_11 - E_12) + (1 - freq_activ) * (E_01 - E_02))
eps_star_absolute$epsilon_from2[i] <- delta / (freq_activ * (E_11 - E_12) + (1 - freq_activ) * (E_01 - E_02))
}
eps_star_absolute$epsilon_all[eps_star$beta == 1.1]
plot(eps_star_absolute$beta, eps_star_absolute$epsilon_all)
# Calculate epsilon* for absolute loss of DOL (test?)
n_1 <- delta * n - 1
n_2 <- 1
eps_star_absolute <- data.frame(beta = beta,
epsilon_inac = rep(NA, length(beta)),
epsilon_ac = rep(NA, length(beta)),
# epsilon_e11_e01_ratio = rep(NA, length(beta)),
epsilon_all = rep(NA, length(beta)))
for (i in 1:nrow(eps_star_absolute)) {
E_01 <- n_1 / (n_1 + (n - n_1)) +  n_1 * ( (1) / (beta[i] * (n_1 - 1) + (n - n_1)) )  # expected number of interaction partners performing task 1 if i is inactive
E_02 <- n_2 / (n_2 + (n - n_2)) +  n_2 * ( (1) / (beta[i] * (n_2 - 1) + (n - n_2)) )  # expected number of interaction partners performing task 2 if i is inactive
E_11 <- 2*beta[i]*(n_1 - 1) / (beta[i] * (n_1 - 1) + (n - n_1)) # expected number of interaction partners performing task 1 if i is task 1
E_12 <- n_2 / (beta[i] * (n_1 - 1) + (n - n_1)) + n_2 * ( (1) / (beta[i] * (n_2 - 1) + (n - n_2)) )  # expected number of interaction partners performing task 1 if i is task 1
eps_delta_inac <- delta / (E_01 - E_02)
eps_delta_ac <- delta / (E_11 - E_12)
eps_star_absolute$epsilon_inac[i] <- eps_delta_inac
eps_star_absolute$epsilon_ac[i] <- eps_delta_ac
eps_star_absolute$epsilon_all[i] <- delta / (freq_activ * (E_11 - E_12) + (1 - freq_activ) * (E_01 - E_02))
eps_star_absolute$epsilon_from2[i] <- delta / (freq_activ * (E_11 - E_12) + (1 - freq_activ) * (E_01 - E_02))
}
eps_star_absolute$epsilon_all[eps_star$beta == 1.1]
n*0.8
n*epsilon
n*delta*0.4
delta*epsilon
delta*0.5
delta*1
delta*1*beta
delta*1*1.1
delta*0.6*1.1
eps_star_absolute$epsilon_all[eps_star$beta == 1.2]
eps_star$epsilon_all[eps_star$beta == 1.2]
n1
n_1
n_2
beta[i
]
n_1 / (n_1 + (n - n_1)) +  n_1 * ( (1) / (beta[i] * (n_1 - 1) + (n - n_1)) )
2*beta[i]*(n_1 - 1) / (beta[i] * (n_1 - 1) + (n - n_1))
n_1 <- delta / 2 * n - 1
n_2 <- delta / 2 * n - 1
eps_star_absolute <- data.frame(beta = beta,
epsilon_inac = rep(NA, length(beta)),
epsilon_ac = rep(NA, length(beta)),
# epsilon_e11_e01_ratio = rep(NA, length(beta)),
epsilon_all = rep(NA, length(beta)))
for (i in 1:nrow(eps_star_absolute)) {
E_01 <- n_1 / (n_1 + (n - n_1)) +  n_1 * ( (1) / (beta[i] * (n_1 - 1) + (n - n_1)) )  # expected number of interaction partners performing task 1 if i is inactive
E_02 <- n_2 / (n_2 + (n - n_2)) +  n_2 * ( (1) / (beta[i] * (n_2 - 1) + (n - n_2)) )  # expected number of interaction partners performing task 2 if i is inactive
E_11 <- 2*beta[i]*(n_1 - 1) / (beta[i] * (n_1 - 1) + (n - n_1)) # expected number of interaction partners performing task 1 if i is task 1
E_12 <- n_2 / (beta[i] * (n_1 - 1) + (n - n_1)) + n_2 * ( (1) / (beta[i] * (n_2 - 1) + (n - n_2)) )  # expected number of interaction partners performing task 1 if i is task 1
eps_delta_inac <- delta / (E_01 - E_02)
eps_delta_ac <- delta / (E_11 - E_12)
eps_star_absolute$epsilon_inac[i] <- eps_delta_inac
eps_star_absolute$epsilon_ac[i] <- eps_delta_ac
eps_star_absolute$epsilon_all[i] <- delta / (freq_activ * (E_11 - E_12) + (1 - freq_activ) * (E_01 - E_02))
eps_star_absolute$epsilon_from2[i] <- delta / (freq_activ * (E_11 - E_12) + (1 - freq_activ) * (E_01 - E_02))
}
eps_star_absolute$epsilon_all[eps_star$beta == 1.2]
eps_star_absolute$epsilon_all[eps_star$beta == 1.1]
n_1 <- delta / 2 * n - 1
n_2 <- delta / 2 * n + 1
eps_star_absolute <- data.frame(beta = beta,
epsilon_inac = rep(NA, length(beta)),
epsilon_ac = rep(NA, length(beta)),
# epsilon_e11_e01_ratio = rep(NA, length(beta)),
epsilon_all = rep(NA, length(beta)))
for (i in 1:nrow(eps_star_absolute)) {
E_01 <- n_1 / (n_1 + (n - n_1)) +  n_1 * ( (1) / (beta[i] * (n_1 - 1) + (n - n_1)) )  # expected number of interaction partners performing task 1 if i is inactive
E_02 <- n_2 / (n_2 + (n - n_2)) +  n_2 * ( (1) / (beta[i] * (n_2 - 1) + (n - n_2)) )  # expected number of interaction partners performing task 2 if i is inactive
E_11 <- 2*beta[i]*(n_1 - 1) / (beta[i] * (n_1 - 1) + (n - n_1)) # expected number of interaction partners performing task 1 if i is task 1
E_12 <- n_2 / (beta[i] * (n_1 - 1) + (n - n_1)) + n_2 * ( (1) / (beta[i] * (n_2 - 1) + (n - n_2)) )  # expected number of interaction partners performing task 1 if i is task 1
eps_delta_inac <- delta / (E_01 - E_02)
eps_delta_ac <- delta / (E_11 - E_12)
eps_star_absolute$epsilon_inac[i] <- eps_delta_inac
eps_star_absolute$epsilon_ac[i] <- eps_delta_ac
eps_star_absolute$epsilon_all[i] <- delta / (freq_activ * (E_11 - E_12) + (1 - freq_activ) * (E_01 - E_02))
eps_star_absolute$epsilon_from2[i] <- delta / (freq_activ * (E_11 - E_12) + (1 - freq_activ) * (E_01 - E_02))
}
eps_star_absolute$epsilon_all[eps_star$beta == 1.1]
n_1 <- delta / 2 * n + 1
n_2 <- delta / 2 * n - 1
eps_star_absolute <- data.frame(beta = beta,
epsilon_inac = rep(NA, length(beta)),
epsilon_ac = rep(NA, length(beta)),
# epsilon_e11_e01_ratio = rep(NA, length(beta)),
epsilon_all = rep(NA, length(beta)))
for (i in 1:nrow(eps_star_absolute)) {
E_01 <- n_1 / (n_1 + (n - n_1)) +  n_1 * ( (1) / (beta[i] * (n_1 - 1) + (n - n_1)) )  # expected number of interaction partners performing task 1 if i is inactive
E_02 <- n_2 / (n_2 + (n - n_2)) +  n_2 * ( (1) / (beta[i] * (n_2 - 1) + (n - n_2)) )  # expected number of interaction partners performing task 2 if i is inactive
E_11 <- 2*beta[i]*(n_1 - 1) / (beta[i] * (n_1 - 1) + (n - n_1)) # expected number of interaction partners performing task 1 if i is task 1
E_12 <- n_2 / (beta[i] * (n_1 - 1) + (n - n_1)) + n_2 * ( (1) / (beta[i] * (n_2 - 1) + (n - n_2)) )  # expected number of interaction partners performing task 1 if i is task 1
eps_delta_inac <- delta / (E_01 - E_02)
eps_delta_ac <- delta / (E_11 - E_12)
eps_star_absolute$epsilon_inac[i] <- eps_delta_inac
eps_star_absolute$epsilon_ac[i] <- eps_delta_ac
eps_star_absolute$epsilon_all[i] <- delta / (freq_activ * (E_11 - E_12) + (1 - freq_activ) * (E_01 - E_02))
eps_star_absolute$epsilon_from2[i] <- delta / (freq_activ * (E_11 - E_12) + (1 - freq_activ) * (E_01 - E_02))
}
eps_star_absolute$epsilon_all[eps_star$beta == 1.1]
