groups_entropy     <- list()
groups_graphs      <- list()
# Loop through group sizes
for (i in 1:length(Ns)) {
# Set group size
n <- Ns[i]
# Prep lists for collection of simulation outputs from this group size
ens_taskDist    <- list()
ens_entropy     <- list()
ens_stim        <- list()
ens_thresh      <- list()
ens_graphs      <- list()
# Run Simulations
for (sim in 1:reps) {
####################
# Seed structures and intial matrices
####################
# Set initial probability matrix (P_g)
P_g <- matrix(data = rep(0, n * m), ncol = m)
# Seed task (external) stimuli
stimMat <- seed_stimuls(intitial_stim = InitialStim,
gens = gens)
# Seed internal thresholds
threshMat <- seed_thresholds(n = n,
m = m,
threshold_means = ThreshM,
threshold_sds = ThreshSD)
# Start task performance
X_g <- matrix(data = rep(0, length(P_g)), ncol = ncol(P_g))
# Create cumulative task performance matrix
X_tot <- X_g
# Create cumulative adjacency matrix
g_tot <-  matrix(data = rep(0, n * n), ncol = n)
colnames(g_tot) <- paste0("v-", 1:n)
rownames(g_tot) <- paste0("v-", 1:n)
####################
# Simulate individual run
####################
# Run simulation
for (t in 1:gens) {
# Current timestep is actually t+1 in this formulation, because first row is timestep 0
# Update stimuli
stimMat <- update_stim(stim_matrix = stimMat,
deltas = deltas,
alpha = alpha,
state_matrix = X_g,
time_step = t)
# Calculate task demand based on global stimuli
P_g <- calc_determ_thresh(time_step        = t + 1, # first row is generation 0
threshold_matrix = threshMat,
stimulus_matrix  = stimMat)
# Update task performance
X_g <- update_task_performance(task_probs   = P_g,
state_matrix = X_g,
quit_prob    = quitP)
# Update social network (previously this was before probability/task update)
g_adj <- temporalNetwork(X_sub_g = X_g,
prob_interact = p,
bias = beta)
g_tot <- g_tot + g_adj
# Adjust thresholds
threshMat <- adjust_thresholds_social_capped(social_network = g_adj,
threshold_matrix = threshMat,
state_matrix = X_g,
epsilon = epsilon,
threshold_max = 2 * ThreshM[1])
# Update total task performance profile
X_tot <- X_tot + X_g
}
####################
# Post run calculations
####################
# Calculate Entropy
entropy <- mutualEntropy(TotalStateMat = X_tot)
# Calculate total task distribution
totalTaskDist <- X_tot / gens
# Create tasktally table
stimMat <- cbind(stimMat, 0:(nrow(stimMat) - 1))
colnames(stimMat)[ncol(stimMat)] <- "t"
# Add total task distributions, entropy values, and graphs to lists
ens_taskDist[[sim]]    <- totalTaskDist
ens_entropy[[sim]]     <- entropy
ens_stim[[sim]]        <- stimMat
ens_thresh[[sim]]      <- threshMat
ens_graphs[[sim]]      <- g_tot / gens
}
# Add to list of lists
groups_taskDist[[i]]    <- ens_taskDist
groups_stim[[i]]        <- ens_stim
groups_thresh[[i]]      <- ens_thresh
groups_entropy[[i]]     <- ens_entropy
groups_graphs[[i]]      <- ens_graphs
}
g_adj
rowSums(g_adj)
colSums(g_adj)
g_adj <- matrix(data = rep(0, dimension*dimension), ncol = dimension)
X_sub_g <- X_g
X_g
colSums(X_g)
70*0.4
# get task performance of individual
task <- which(X_sub_g[i, ] == 1)
i =1
# get task performance of individual
task <- which(X_sub_g[i, ] == 1)
X-g
X_g
i = 2
# get task performance of individual
task <- which(X_sub_g[i, ] == 1)
task
# set up list of potential connections
potential <- seq(1:dimension)
dimension <- nrow(X_sub_g)
g_adj <- matrix(data = rep(0, dimension*dimension), ncol = dimension)
# get task performance of individual
task <- which(X_sub_g[i, ] == 1)
# set up list of potential connections
potential <- seq(1:dimension)
baseline_prob <- rep(1, length(potential))
potential
baseline_prob
# find which individuals are perfoming same task and relatively weight probabilities
same <- which(X_sub_g[ , task] == 1)
same
baseline_prob[same] <- baseline_prob[same] * bias
bias = 1.1
baseline_prob[same] <- baseline_prob[same] * bias
baseline_prob
potential <- potential[-i] # remove self
potential
baseline_prob <- baseline_prob[-i] # remove self
baseline_prob
connection <- sample(x = potential, size = 1, prob = baseline_prob)
sample(x = potential, size = 10, prob = baseline_prob, replace = T)
test <- sample(x = potential, size = 100, prob = baseline_prob, replace = T)
test
X_g[test]
X_g[test,]
colSums(X_g[test,])
test <- sample(x = potential, size = 1000, prob = baseline_prob, replace = T)
colSums(X_g[test,])
437/358
437-358
79*0.1
7.9*20
################################################################################
#
# Analyzing thresholds (at end point)
#
################################################################################
rm(list = ls())
source("scripts/util/__Util__MASTER.R")
library(RColorBrewer)
library(scales)
library(viridis)
library(ggridges)
p <- 1 #prob of interact
run <- "Sigma0-Epsilon0.1-Beta1.1"
####################
# Load and process data
####################
# Load Thresholds
files <- list.files(paste0("output/Rdata/_ProcessedData/Thresh/", run, "/"), full.names = TRUE)
# Loop through group sizes
group_thresh <- lapply(files, function(file) {
# Load
load(file)
# Bind
thresh_data <- as.data.frame(do.call("rbind", listed_data))
# # Summarise
# thresh_sum <- thresh_data %>%
#   mutate(run = paste0(sim, "-", chunk)) %>%
#   group_by(n, run) %>%
#   summarise(Thresh1SD = sd(Thresh1),
#             Thresh2SD = sd(Thresh2),
#             ThreshSD = (sd(Thresh1)  + sd(Thresh2)) / 2) %>%
#   select(n, ThreshSD)
return(thresh_data)
})
# Bind
all_thresh <- do.call('rbind', group_thresh)
# Format for plotting
####################
# Plot threshold distributions
####################
# Plot
pal <- brewer_pal("seq", "RdPu")
pal <- pal(9)
gg_threshvar <- ggplot(data = all_thresh,
aes(x = Thresh1, y = n, fill = n, group = n)) +
theme_invisible() +
geom_density_ridges(size = 0.2, stat = "binline", bins = 100) +
xlab(expression(paste("Threshold Value (", theta[i1, t=T], ")"))) +
ylab(expression(paste("Group Size (", italic(n), ")"))) +
scale_x_continuous(breaks = seq(0, 100, 25),
limits = c(-01, 101),
expand = c(0.03, 0)) +
scale_y_continuous(breaks = c(5, seq(25, 100, 25)),
expand = c(0.03, 0)) +
scale_fill_viridis() +
scale_color_viridis() +
theme(axis.text = element_text(colour = "black", size = 6),
axis.title = element_text(size = 7, color = "black"),
axis.title.y = element_text(size = 7, color = "black", face = 'italic'),
legend.position = "none",
axis.ticks = element_line(size = 0.2, color = "black"))
gg_threshvar
################################################################################
#
# Analyzing behavior
#
################################################################################
rm(list = ls())
source("scripts/util/__Util__MASTER.R")
library(RColorBrewer)
library(scales)
library(viridis)
library(ggridges)
####################
# Load data
####################
load("output/Rdata/_ProcessedData/TaskDist/Sigma0-Epsilon0.1-Beta1.1.Rdata")
social_data <- compiled_data
social_data$Model <- "Socially-modulated thresholds"
load("output/Rdata/_ProcessedData/TaskDist/Sigma0.05-Epsilon0-Beta1.1.Rdata")
fixed_data <- compiled_data
fixed_data$Model <- "Fixed threhsolds"
behav_data <- rbind(social_data, fixed_data) %>%
mutate(Set = paste(sim, chunk, sep = "-")) %>%
mutate(Task_bias = Task1 - Task2,
Activity = Task1 + Task2)
rm(compiled_data, social_data, fixed_data)
####################
#  Look at raw behavioral distributions
####################
behav_analysis <- behav_data %>%
filter(n %in% c(10, 25, 50, 90))
# Plot behavioral distributions
gg_behav_dist <- ggplot(data = behav_analysis, aes(x = Task1, y = Task2)) +
geom_point(size = 0.1, alpha = 0.01) +
theme_ctokita() +
facet_grid(Model~n)
gg_behav_dist
# Plot task bias vs activity level
gg_behav_act <- ggplot(data = behav_analysis, aes(x = Task_bias, y = Activity)) +
geom_point(size = 0.1, alpha = 0.01) +
theme_ctokita() +
facet_grid(Model~n)
gg_behav_act
####################
# Behavior distribution by group size
####################
# Filter to
filter_data <- behav_data %>%
filter(n %in% seq(5, 50, 5))
gg_behavvar<- ggplot(data = filter_data,
aes(x = Task1, y = n, fill = Model, group = n)) +
theme_invisible() +
geom_density_ridges2(size = 0.1, stat = "binline", bins = 100) +
xlab(expression(paste("Task 1 performance freq (", italic(x[i1]), ")"))) +
ylab(expression(paste("Group Size (", italic(n), ")"))) +
scale_x_continuous(breaks = seq(-1, 1, 0.2),
# limits = c(0, 1),
expand = c(0.03, 0)) +
scale_y_continuous(breaks = c(5, seq(10, 50, 10)),
expand = c(0.03, 0)) +
# scale_fill_viridis() +
# scale_color_viridis() +
scale_fill_manual(values = c("#a6cee3", "#1f78b4")) +
theme(axis.text = element_text(colour = "black", size = 6),
axis.title = element_text(size = 7, color = "black"),
axis.title.y = element_text(size = 7, color = "black", face = 'italic'),
legend.position = "none",
strip.text = element_text(size = 6, face = "bold"),
axis.ticks = element_line(size = 0.2, color = "black")) +
facet_grid(~Model)
gg_behavvar
####################
# Load and process data
####################
# Loop through group sizes
thresh_data <- lapply(runs, function(run) {
# List files
files <- list.files(paste0("output/Rdata/_ProcessedData/Thresh/", run, "/"), full.names = TRUE)
# Loop through group sizes
group_thresh <- lapply(files, function(file) {
# Load
load(file)
# Bind
thresh_data <- as.data.frame(do.call("rbind", listed_data))
# # Summarise
# thresh_sum <- thresh_data %>%
#   mutate(run = paste0(sim, "-", chunk)) %>%
#   group_by(n, run) %>%
#   summarise(Thresh1SD = sd(Thresh1),
#             Thresh2SD = sd(Thresh2),
#             ThreshSD = (sd(Thresh1)  + sd(Thresh2)) / 2) %>%
#   select(n, ThreshSD)
return(thresh_data)
})
# Bind
all_thresh <- do.call('rbind', group_thresh)
if (grepl(".*Epsilon0-.*", run)) {
all_thresh$Model <- "Fixed thresholds"
} else {
all_thresh$Model <- "Socially-modulated thresholds"
}
return(all_thresh)
})
rm(list = ls())
source("scripts/util/__Util__MASTER.R")
library(RColorBrewer)
library(scales)
library(viridis)
library(ggridges)
p <- 1 #prob of interact
runs <- c("Sigma0-Epsilon0.1-Beta1.1",
"Sigma0.05-Epsilon0-Beta1.1")
####################
# Load and process data
####################
# Loop through group sizes
thresh_data <- lapply(runs, function(run) {
# List files
files <- list.files(paste0("output/Rdata/_ProcessedData/Thresh/", run, "/"), full.names = TRUE)
# Loop through group sizes
group_thresh <- lapply(files, function(file) {
# Load
load(file)
# Bind
thresh_data <- as.data.frame(do.call("rbind", listed_data))
# # Summarise
# thresh_sum <- thresh_data %>%
#   mutate(run = paste0(sim, "-", chunk)) %>%
#   group_by(n, run) %>%
#   summarise(Thresh1SD = sd(Thresh1),
#             Thresh2SD = sd(Thresh2),
#             ThreshSD = (sd(Thresh1)  + sd(Thresh2)) / 2) %>%
#   select(n, ThreshSD)
return(thresh_data)
})
# Bind
all_thresh <- do.call('rbind', group_thresh)
if (grepl(".*Epsilon0-.*", run)) {
all_thresh$Model <- "Fixed thresholds"
} else {
all_thresh$Model <- "Socially-modulated thresholds"
}
return(all_thresh)
})
# bind and format
thresh_data <- as.data.frame(do.call('rbind', thresh_data))
# Plot
gg_threshvar <- ggplot(data = filter_data,
aes(x = Thresh1, y = n, fill = Model, group = n)) +
theme_invisible() +
geom_density_ridges(size = 0.1, stat = "binline", bins = 100) +
xlab(expression(paste("Threshold 1 value (", italic(theta[i1]), ")"))) +
ylab(expression(paste("Group Size (", italic(n), ")"))) +
scale_x_continuous(breaks = seq(0, 100, 25),
# limits = c(0, 1),
expand = c(0.03, 0)) +
scale_y_continuous(breaks = c(5, seq(10, 50, 10)),
expand = c(0.03, 0)) +
# scale_fill_viridis() +
# scale_color_viridis() +
scale_fill_manual(values = c("#a6cee3", "#1f78b4")) +
theme(axis.text = element_text(colour = "black", size = 6),
axis.title = element_text(size = 7, color = "black"),
axis.title.y = element_text(size = 7, color = "black", face = 'italic'),
legend.position = "none",
strip.text = element_text(size = 6, face = "bold"),
axis.ticks = element_line(size = 0.2, color = "black")) +
facet_grid(~Model)
####################
# Plot threshold distributions
####################
# Filter
filter_data <- thresh_data %>%
filter(n %in% seq(5, 50, 5))
# Plot
gg_threshvar <- ggplot(data = filter_data,
aes(x = Thresh1, y = n, fill = Model, group = n)) +
theme_invisible() +
geom_density_ridges(size = 0.1, stat = "binline", bins = 100) +
xlab(expression(paste("Threshold 1 value (", italic(theta[i1]), ")"))) +
ylab(expression(paste("Group Size (", italic(n), ")"))) +
scale_x_continuous(breaks = seq(0, 100, 25),
# limits = c(0, 1),
expand = c(0.03, 0)) +
scale_y_continuous(breaks = c(5, seq(10, 50, 10)),
expand = c(0.03, 0)) +
# scale_fill_viridis() +
# scale_color_viridis() +
scale_fill_manual(values = c("#a6cee3", "#1f78b4")) +
theme(axis.text = element_text(colour = "black", size = 6),
axis.title = element_text(size = 7, color = "black"),
axis.title.y = element_text(size = 7, color = "black", face = 'italic'),
legend.position = "none",
strip.text = element_text(size = 6, face = "bold"),
axis.ticks = element_line(size = 0.2, color = "black")) +
facet_grid(~Model)
gg_threshvar
# Plot
gg_threshvar <- ggplot(data = filter_data,
aes(x = Thresh1, y = n, fill = Model, group = n)) +
theme_invisible() +
geom_density_ridges(size = 0, stat = "binline", bins = 100) +
xlab(expression(paste("Threshold 1 value (", italic(theta[i1]), ")"))) +
ylab(expression(paste("Group Size (", italic(n), ")"))) +
scale_x_continuous(breaks = seq(0, 100, 25),
# limits = c(0, 1),
expand = c(0.03, 0)) +
scale_y_continuous(breaks = c(5, seq(10, 50, 10)),
expand = c(0.03, 0)) +
# scale_fill_viridis() +
# scale_color_viridis() +
scale_fill_manual(values = c("#a6cee3", "#1f78b4")) +
theme(axis.text = element_text(colour = "black", size = 6),
axis.title = element_text(size = 7, color = "black"),
axis.title.y = element_text(size = 7, color = "black", face = 'italic'),
legend.position = "none",
strip.text = element_text(size = 6, face = "bold"),
axis.ticks = element_line(size = 0.2, color = "black")) +
facet_grid(~Model)
gg_threshvar
rm(list = ls())
source("scripts/util/__Util__MASTER.R")
library(RColorBrewer)
library(scales)
library(viridis)
library(ggridges)
####################
# Load data
####################
load("output/Rdata/_ProcessedData/TaskDist/Sigma0-Epsilon0.1-Beta1.1.Rdata")
social_data <- compiled_data
social_data$Model <- "Socially-modulated thresholds"
load("output/Rdata/_ProcessedData/TaskDist/Sigma0.05-Epsilon0-Beta1.1.Rdata")
fixed_data <- compiled_data
fixed_data$Model <- "Fixed threhsolds"
behav_data <- rbind(social_data, fixed_data) %>%
mutate(Set = paste(sim, chunk, sep = "-")) %>%
mutate(Task_bias = Task1 - Task2,
Activity = Task1 + Task2)
rm(compiled_data, social_data, fixed_data)
####################
#  Look at raw behavioral distributions
####################
behav_analysis <- behav_data %>%
filter(n %in% c(10, 25, 50, 90))
# Plot behavioral distributions
gg_behav_dist <- ggplot(data = behav_analysis, aes(x = Task1, y = Task2)) +
geom_point(size = 0.1, alpha = 0.01) +
theme_ctokita() +
facet_grid(Model~n)
gg_behav_dist
# Plot task bias vs activity level
gg_behav_act <- ggplot(data = behav_analysis, aes(x = Task_bias, y = Activity)) +
geom_point(size = 0.1, alpha = 0.01) +
theme_ctokita() +
facet_grid(Model~n)
gg_behav_act
filter_data <- behav_data %>%
filter(n %in% seq(5, 50, 5))
gg_behavvar<- ggplot(data = filter_data,
aes(x = Task1, y = n, fill = Model, group = n)) +
theme_invisible() +
geom_density_ridges2(size = 0.1, stat = "binline", bins = 100) +
xlab(expression(paste("Task 1 performance freq (", italic(x[i1,t=T]), ")"))) +
ylab(expression(paste("Group Size (", italic(n), ")"))) +
scale_x_continuous(breaks = seq(-1, 1, 0.2),
# limits = c(0, 1),
expand = c(0.03, 0)) +
scale_y_continuous(breaks = c(5, seq(10, 50, 10)),
expand = c(0.03, 0)) +
# scale_fill_viridis() +
# scale_color_viridis() +
scale_fill_manual(values = c("#a6cee3", "#1f78b4")) +
theme(axis.text = element_text(colour = "black", size = 6),
axis.title = element_text(size = 7, color = "black"),
axis.title.y = element_text(size = 7, color = "black", face = 'italic'),
legend.position = "none",
strip.text = element_text(size = 6, face = "bold"),
axis.ticks = element_line(size = 0.2, color = "black")) +
facet_grid(~Model)
gg_behavvar
gg_behavvar<- ggplot(data = filter_data,
aes(x = Task1, y = n, fill = Model, group = n)) +
theme_invisible() +
geom_density_ridges2(size = 0.1, stat = "binline", bins = 100) +
xlab(expression(paste("Task 1 performance freq (", italic(x[i1,t]), ")"))) +
ylab(expression(paste("Group Size (", italic(n), ")"))) +
scale_x_continuous(breaks = seq(-1, 1, 0.2),
# limits = c(0, 1),
expand = c(0.03, 0)) +
scale_y_continuous(breaks = c(5, seq(10, 50, 10)),
expand = c(0.03, 0)) +
# scale_fill_viridis() +
# scale_color_viridis() +
scale_fill_manual(values = c("#a6cee3", "#1f78b4")) +
theme(axis.text = element_text(colour = "black", size = 6),
axis.title = element_text(size = 7, color = "black"),
axis.title.y = element_text(size = 7, color = "black", face = 'italic'),
legend.position = "none",
strip.text = element_text(size = 6, face = "bold"),
axis.ticks = element_line(size = 0.2, color = "black")) +
facet_grid(~Model)
gg_behavvar
source('~/Documents/Research/Tarnita Lab/Social Interaction DOL/SocialModel/scripts/Analyze_Thresholds.R', echo=TRUE)
