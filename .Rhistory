scale_x_continuous(breaks = seq(0, 100, 20)) +
scale_y_continuous(breaks = seq(0, 0.015, 0.005), limits = c(-0.0002, 0.016)) +
xlab(expression(paste("Group size (", italic(n), ")"))) +
ylab("Modularity") +
theme_ctokita() +
theme(legend.position = "none",
legend.key.height = unit(0.5, "line"))
gg_mod_gs
gg_mod_gs <- ggplot(mod_data_gs, aes(x = parameter_value, y = Modul_mean, colour = parameter, fill = parameter)) +
# geom_line(size = 0.4) +
geom_errorbar(aes(ymin = ifelse(Modul_mean - Modul_SD < 0, 0, Modul_mean - Modul_SD), ymax = Modul_mean + Modul_SD),
width = 0,
size = 0.3) +
geom_point(size = 0.8, shape = 21) +
scale_color_manual(name = "Threshold",
# values = c("#878787", "#4d4d4d")) +
values = c("#4d4d4d")) +
scale_fill_manual(name = "Threshold",
# values = c("#ffffff", "#4d4d4d")) +
values = c("#4d4d4d")) +
scale_x_continuous(breaks = seq(0, 100, 20)) +
scale_y_continuous(breaks = seq(0, 0.012, 0.004), limits = c(-0.0002, 0.016)) +
xlab(expression(paste("Group size (", italic(n), ")"))) +
ylab("Modularity") +
theme_ctokita() +
theme(legend.position = "none",
legend.key.height = unit(0.5, "line"))
gg_mod_gs
gg_mod_gs <- ggplot(mod_data_gs, aes(x = parameter_value, y = Modul_mean, colour = parameter, fill = parameter)) +
# geom_line(size = 0.4) +
geom_errorbar(aes(ymin = ifelse(Modul_mean - Modul_SD < 0, 0, Modul_mean - Modul_SD), ymax = Modul_mean + Modul_SD),
width = 0,
size = 0.3) +
geom_point(size = 0.8, shape = 21) +
scale_color_manual(name = "Threshold",
# values = c("#878787", "#4d4d4d")) +
values = c("#4d4d4d")) +
scale_fill_manual(name = "Threshold",
# values = c("#ffffff", "#4d4d4d")) +
values = c("#4d4d4d")) +
scale_x_continuous(breaks = seq(0, 100, 20)) +
scale_y_continuous(breaks = seq(0, 0.012, 0.004), limits = c(-0.0002, 0.012)) +
xlab(expression(paste("Group size (", italic(n), ")"))) +
ylab("Modularity") +
theme_ctokita() +
theme(legend.position = "none",
legend.key.height = unit(0.5, "line"))
gg_mod_gs
gg_net_mod <- grid.arrange(gg_mod_beta, gg_mod_eps, gg_mod_gs, nrow = 1)
# Together
library(gridExtra)
gg_net_mod <- grid.arrange(gg_mod_beta, gg_mod_eps, gg_mod_gs, nrow = 1)
ggsave(gg_net_mod, filename = "Output/Networks/NetworkMetrics/Modularity_parametersweep.svg",
height = 23.1, width = 1.515*95, units = "mm")
gg_mod_gs <- ggplot(mod_data_gs, aes(x = parameter_value, y = Modul_mean, colour = parameter, fill = parameter)) +
# geom_line(size = 0.4) +
geom_errorbar(aes(ymin = ifelse(Modul_mean - Modul_SD < 0, 0, Modul_mean - Modul_SD), ymax = Modul_mean + Modul_SD),
width = 0,
size = 0.3) +
geom_point(size = 0.8, shape = 21) +
scale_color_manual(name = "Threshold",
# values = c("#878787", "#4d4d4d")) +
values = c("#4d4d4d")) +
scale_fill_manual(name = "Threshold",
# values = c("#ffffff", "#4d4d4d")) +
values = c("#4d4d4d")) +
scale_x_continuous(breaks = seq(0, 100, 20)) +
scale_y_continuous(breaks = seq(0, 0.015, 0.05), limits = c(-0.0002, 0.012)) +
xlab(expression(paste("Group size (", italic(n), ")"))) +
ylab("Modularity") +
theme_ctokita() +
theme(legend.position = "none",
legend.key.height = unit(0.5, "line"))
gg_mod_gs
gg_mod_gs <- ggplot(mod_data_gs, aes(x = parameter_value, y = Modul_mean, colour = parameter, fill = parameter)) +
# geom_line(size = 0.4) +
geom_errorbar(aes(ymin = ifelse(Modul_mean - Modul_SD < 0, 0, Modul_mean - Modul_SD), ymax = Modul_mean + Modul_SD),
width = 0,
size = 0.3) +
geom_point(size = 0.8, shape = 21) +
scale_color_manual(name = "Threshold",
# values = c("#878787", "#4d4d4d")) +
values = c("#4d4d4d")) +
scale_fill_manual(name = "Threshold",
# values = c("#ffffff", "#4d4d4d")) +
values = c("#4d4d4d")) +
scale_x_continuous(breaks = seq(0, 100, 20)) +
scale_y_continuous(breaks = seq(0, 0.0015, 0.05), limits = c(-0.0002, 0.012)) +
xlab(expression(paste("Group size (", italic(n), ")"))) +
ylab("Modularity") +
theme_ctokita() +
theme(legend.position = "none",
legend.key.height = unit(0.5, "line"))
gg_mod_gs
gg_mod_gs <- ggplot(mod_data_gs, aes(x = parameter_value, y = Modul_mean, colour = parameter, fill = parameter)) +
# geom_line(size = 0.4) +
geom_errorbar(aes(ymin = ifelse(Modul_mean - Modul_SD < 0, 0, Modul_mean - Modul_SD), ymax = Modul_mean + Modul_SD),
width = 0,
size = 0.3) +
geom_point(size = 0.8, shape = 21) +
scale_color_manual(name = "Threshold",
# values = c("#878787", "#4d4d4d")) +
values = c("#4d4d4d")) +
scale_fill_manual(name = "Threshold",
# values = c("#ffffff", "#4d4d4d")) +
values = c("#4d4d4d")) +
scale_x_continuous(breaks = seq(0, 100, 20)) +
scale_y_continuous(breaks = seq(0, 0.0015, 0.005), limits = c(-0.0002, 0.012)) +
xlab(expression(paste("Group size (", italic(n), ")"))) +
ylab("Modularity") +
theme_ctokita() +
theme(legend.position = "none",
legend.key.height = unit(0.5, "line"))
gg_mod_gs
gg_mod_gs <- ggplot(mod_data_gs, aes(x = parameter_value, y = Modul_mean, colour = parameter, fill = parameter)) +
# geom_line(size = 0.4) +
geom_errorbar(aes(ymin = ifelse(Modul_mean - Modul_SD < 0, 0, Modul_mean - Modul_SD), ymax = Modul_mean + Modul_SD),
width = 0,
size = 0.3) +
geom_point(size = 0.8, shape = 21) +
scale_color_manual(name = "Threshold",
# values = c("#878787", "#4d4d4d")) +
values = c("#4d4d4d")) +
scale_fill_manual(name = "Threshold",
# values = c("#ffffff", "#4d4d4d")) +
values = c("#4d4d4d")) +
scale_x_continuous(breaks = seq(0, 100, 20)) +
scale_y_continuous(breaks = seq(0, 0.015, 0.005), limits = c(-0.0002, 0.012)) +
xlab(expression(paste("Group size (", italic(n), ")"))) +
ylab("Modularity") +
theme_ctokita() +
theme(legend.position = "none",
legend.key.height = unit(0.5, "line"))
gg_mod_gs
gg_mod_gs <- ggplot(mod_data_gs, aes(x = parameter_value, y = Modul_mean, colour = parameter, fill = parameter)) +
# geom_line(size = 0.4) +
geom_errorbar(aes(ymin = ifelse(Modul_mean - Modul_SD < 0, 0, Modul_mean - Modul_SD), ymax = Modul_mean + Modul_SD),
width = 0,
size = 0.3) +
geom_point(size = 0.8, shape = 21) +
scale_color_manual(name = "Threshold",
# values = c("#878787", "#4d4d4d")) +
values = c("#4d4d4d")) +
scale_fill_manual(name = "Threshold",
# values = c("#ffffff", "#4d4d4d")) +
values = c("#4d4d4d")) +
scale_x_continuous(breaks = seq(0, 100, 20)) +
scale_y_continuous(breaks = seq(0, 0.015, 0.005), limits = c(-0.0002, 0.011)) +
xlab(expression(paste("Group size (", italic(n), ")"))) +
ylab("Modularity") +
theme_ctokita() +
theme(legend.position = "none",
legend.key.height = unit(0.5, "line"))
gg_mod_gs
gg_net_mod <- grid.arrange(gg_mod_beta, gg_mod_eps, gg_mod_gs, nrow = 1)
ggsave(gg_net_mod, filename = "Output/Networks/NetworkMetrics/Modularity_parametersweep.svg",
height = 23.1, width = 1.515*95, units = "mm")
ggsave(gg_net_mod, filename = "Output/Networks/NetworkMetrics/Modularity_parametersweep.svg",
height = 23.1, width = 1.525*95, units = "mm")
ggsave(gg_net_mod, filename = "Output/Networks/NetworkMetrics/Modularity_parametersweep.svg",
height = 23.1, width = 1.535*95, units = "mm")
ggsave(gg_net_mod, filename = "Output/Networks/NetworkMetrics/Modularity_parametersweep.svg",
height = 23.1, width = 1.54*95, units = "mm")
ggsave(gg_net_mod, filename = "Output/Networks/NetworkMetrics/Modularity_parametersweep.svg",
height = 23.1, width = 1.545*95, units = "mm")
gg_mod_gs <- ggplot(mod_data_gs, aes(x = parameter_value, y = Modul_mean, colour = parameter, fill = parameter)) +
# geom_line(size = 0.4) +
geom_errorbar(aes(ymin = ifelse(Modul_mean - Modul_SD < 0, 0, Modul_mean - Modul_SD), ymax = Modul_mean + Modul_SD),
width = 0,
size = 0.3) +
geom_point(size = 0.8, shape = 21) +
scale_color_manual(name = "Threshold",
# values = c("#878787", "#4d4d4d")) +
values = c("#4d4d4d")) +
scale_fill_manual(name = "Threshold",
# values = c("#ffffff", "#4d4d4d")) +
values = c("#4d4d4d")) +
scale_x_continuous(breaks = seq(0, 100, 20)) +
scale_y_continuous(breaks = seq(0, 0.02, 0.01), limits = c(-0.0002, 0.031)) +
xlab(expression(paste("Group size (", italic(n), ")"))) +
ylab("Modularity") +
theme_ctokita() +
theme(legend.position = "none",
legend.key.height = unit(0.5, "line"))
gg_mod_gs
gg_mod_gs <- ggplot(mod_data_gs, aes(x = parameter_value, y = Modul_mean, colour = parameter, fill = parameter)) +
# geom_line(size = 0.4) +
geom_errorbar(aes(ymin = ifelse(Modul_mean - Modul_SD < 0, 0, Modul_mean - Modul_SD), ymax = Modul_mean + Modul_SD),
width = 0,
size = 0.3) +
geom_point(size = 0.8, shape = 21) +
scale_color_manual(name = "Threshold",
# values = c("#878787", "#4d4d4d")) +
values = c("#4d4d4d")) +
scale_fill_manual(name = "Threshold",
# values = c("#ffffff", "#4d4d4d")) +
values = c("#4d4d4d")) +
scale_x_continuous(breaks = seq(0, 100, 20)) +
scale_y_continuous(breaks = seq(0, 0.02, 0.01), limits = c(-0.0002, 0.021)) +
xlab(expression(paste("Group size (", italic(n), ")"))) +
ylab("Modularity") +
theme_ctokita() +
theme(legend.position = "none",
legend.key.height = unit(0.5, "line"))
gg_mod_gs
gg_mod_gs <- ggplot(mod_data_gs, aes(x = parameter_value, y = Modul_mean, colour = parameter, fill = parameter)) +
# geom_line(size = 0.4) +
geom_errorbar(aes(ymin = ifelse(Modul_mean - Modul_SD < 0, 0, Modul_mean - Modul_SD), ymax = Modul_mean + Modul_SD),
width = 0,
size = 0.3) +
geom_point(size = 0.8, shape = 21) +
scale_color_manual(name = "Threshold",
# values = c("#878787", "#4d4d4d")) +
values = c("#4d4d4d")) +
scale_fill_manual(name = "Threshold",
# values = c("#ffffff", "#4d4d4d")) +
values = c("#4d4d4d")) +
scale_x_continuous(breaks = seq(0, 100, 20)) +
scale_y_continuous(breaks = seq(0, 0.02, 0.01), limits = c(-0.0002, 0.02)) +
xlab(expression(paste("Group size (", italic(n), ")"))) +
ylab("Modularity") +
theme_ctokita() +
theme(legend.position = "none",
legend.key.height = unit(0.5, "line"))
gg_mod_gs
gg_net_mod <- grid.arrange(gg_mod_beta, gg_mod_eps, gg_mod_gs, nrow = 1)
ggsave(gg_net_mod, filename = "Output/Networks/NetworkMetrics/Modularity_parametersweep.svg",
height = 23.1, width = 1.515*95, units = "mm")
rm(list = ls())
source("scripts/util/__Util__MASTER.R")
library(RColorBrewer)
library(scales)
############### Sweep across beta values ###############
####################
# Load data
####################
load("output/Rdata/_ProcessedData/Entropy/Sigma0-Epsilon0.1-Beta1.01.Rdata")
compiled_data$Model <- "Social_Beta1.01"
entropy_data <- compiled_data
rm(compiled_data)
len(entropy_data)
length(entropy_data)
entropy_data[1]
entropy_data[1][1:10]
head(entropy_data[1])
entropy_data[1]
####################
# Source necessary scripts/libraries
####################
source("scripts/util/__Util__MASTER.R")
####################
# Set global variables
####################
# Initial paramters: Free to change
# Base parameters
Ns             <- c(5, 10, 20, 30, 50, 70) #vector of number of individuals to simulate
m              <- 3 #number of tasks
gens           <- 1000 #number of generations to run simulation
reps           <- 2 #number of replications per simulation (for ensemble)
# Threshold Parameters
ThreshM        <- rep(50, m) #population threshold means
ThreshSD       <- ThreshM * 0 #population threshold standard deviations
InitialStim    <- rep(0, m) #intital vector of stimuli
deltas         <- rep(0.8, m) #vector of stimuli increase rates
alpha          <- m #efficiency of task performance
quitP          <- 0.2 #probability of quitting task once active
# Social Network Parameters
p              <- 1 #baseline probablity of initiating an interaction per time step
epsilon        <- 0.1 #relative weighting of social interactions for adjusting thresholds
beta           <- 1.1 #probability of interacting with individual in same state relative to others
####################
# Run ensemble simulation
####################
# Prep meta-lists for collection of group size simulations
groups_taskDist    <- list()
groups_stim        <- list()
groups_thresh      <- list()
groups_entropy     <- list()
groups_graphs      <- list()
# Loop through group sizes
for (i in 1:length(Ns)) {
# Set group size
n <- Ns[i]
# Prep lists for collection of simulation outputs from this group size
ens_taskDist    <- list()
ens_entropy     <- list()
ens_stim        <- list()
ens_thresh      <- list()
ens_graphs      <- list()
# Run Simulations
for (sim in 1:reps) {
####################
# Seed structures and intial matrices
####################
# Set initial probability matrix (P_g)
P_g <- matrix(data = rep(0, n * m), ncol = m)
# Seed task (external) stimuli
stimMat <- seed_stimuls(intitial_stim = InitialStim,
gens = gens)
# Seed internal thresholds
threshMat <- seed_thresholds(n = n,
m = m,
threshold_means = ThreshM,
threshold_sds = ThreshSD)
# Start task performance
X_g <- matrix(data = rep(0, length(P_g)), ncol = ncol(P_g))
# Create cumulative task performance matrix
X_tot <- X_g
# Create cumulative adjacency matrix
g_tot <-  matrix(data = rep(0, n * n), ncol = n)
colnames(g_tot) <- paste0("v-", 1:n)
rownames(g_tot) <- paste0("v-", 1:n)
####################
# Simulate individual run
####################
# Run simulation
for (t in 1:gens) {
# Current timestep is actually t+1 in this formulation, because first row is timestep 0
# Update stimuli
stimMat <- update_stim(stim_matrix = stimMat,
deltas = deltas,
alpha = alpha,
state_matrix = X_g,
time_step = t)
# Calculate task demand based on global stimuli
P_g <- calc_determ_thresh(time_step        = t + 1, # first row is generation 0
threshold_matrix = threshMat,
stimulus_matrix  = stimMat)
# Update task performance
X_g <- update_task_performance(task_probs   = P_g,
state_matrix = X_g,
quit_prob    = quitP)
# Update social network (previously this was before probability/task update)
g_adj <- temporalNetwork(X_sub_g = X_g,
prob_interact = p,
bias = beta)
g_tot <- g_tot + g_adj
# Adjust thresholds
threshMat <- adjust_thresholds_social_capped(social_network = g_adj,
threshold_matrix = threshMat,
state_matrix = X_g,
epsilon = epsilon,
threshold_max = 2 * ThreshM[1])
# Update total task performance profile
X_tot <- X_tot + X_g
}
####################
# Post run calculations
####################
# Calculate Entropy
entropy <- mutualEntropy(TotalStateMat = X_tot)
# Calculate total task distribution
totalTaskDist <- X_tot / gens
# Create tasktally table
stimMat <- cbind(stimMat, 0:(nrow(stimMat) - 1))
colnames(stimMat)[ncol(stimMat)] <- "t"
# Add total task distributions, entropy values, and graphs to lists
ens_taskDist[[sim]]    <- totalTaskDist
ens_entropy[[sim]]     <- entropy
ens_stim[[sim]]        <- stimMat
ens_thresh[[sim]]      <- threshMat
ens_graphs[[sim]]      <- g_tot / gens
}
# Add to list of lists
groups_taskDist[[i]]    <- ens_taskDist
groups_stim[[i]]        <- ens_stim
groups_thresh[[i]]      <- ens_thresh
groups_entropy[[i]]     <- ens_entropy
groups_graphs[[i]]      <- ens_graphs
}
ens_entropy
groups_entropy
rm(list = ls())
####################
# Source necessary scripts/libraries
####################
source("scripts/util/__Util__MASTER.R")
library(parallel)
library(snowfall)
####################
# Choose task probabilistically
####################
update_task_performance <- function(task_probs, state_matrix, quit_prob) {
# Create possible task space
tasks <- seq(1:ncol(task_probs))
# Loop through individuals
for(row in 1:nrow(state_matrix)) {
# Inactive workers randomly sample one stimulus
if (sum(state_matrix[row, ]) == 0) {
# Sample task probability
#tasks_order <- sample(x = tasks, size = length(tasks), replace = FALSE) #random order
tasks_order <- tasks #fixed order
# Loop through tasks and go with first one that results in activity
for (task in tasks_order) {
prob <- task_probs[row, task]
activity <- sample(x = c(0, 1), size = 1, prob = c(1 - prob, prob))
if (activity == 1) {
state_matrix[row, task] <- activity
break
}
}
}
else { #active workers quit with certain probability
quit_now <- sample(x = c("yes", "no"), size = 1, prob = c(quit_prob, (1 - quit_prob)))
if (quit_now == "yes") {
state_matrix[row, ] <- 0
}
}
}
# Return
colnames(state_matrix) <- paste0("Task", 1:ncol(task_probs))
rownames(state_matrix) <- paste0("v-", 1:nrow(task_probs))
return(state_matrix)
}
# Initial paramters: Free to change
# Base parameters
n              <- 80 #group size
m              <- 2 #number of tasks
Tsteps         <- 50000 #number of time steps to run simulation
reps           <- 100 #number of replications per simulation (for ensemble)
chunk_size     <- 5 #number of simulations sent to single core
# Threshold Parameters
ThreshM        <- rep(50, m) #population threshold means
ThreshSD       <- ThreshM * 0 #population threshold standard deviations
InitialStim    <- rep(0, m) #intital vector of stimuli
deltas         <- rep(0.8, m) #vector of stimuli increase rates
alpha          <- m #efficiency of task performance
quitP          <- 0.2 #probability of quitting task once active
# Social Network Parameters
p              <- 1 #baseline probablity of initiating an interaction per time step
epsilon        <- 0.1 #relative weighting of social interactions for adjusting thresholds
betas          <- seq(1, 1.25, 0.01) #probability of interacting with individual in same state relative to others
chunk_run  <- 1:(reps / chunk_size)
run_in_parallel <- expand.grid(beta =  round(betas, digits = 3), run = chunk_run) #rounding to make sure numbers are what they appear
run_in_parallel <- run_in_parallel %>%
arrange(beta)
k = 1
# Set group size
beta <- run_in_parallel[k, 1]
chunk <- run_in_parallel[k, 2]
# Prep lists for collection of s
P_g <- matrix(data = rep(0, n * m), ncol = m)
# Seed task (external) stimuli
stimMat <- seed_stimuls(intitial_stim = InitialStim,
Tsteps = Tsteps)
# Seed internal thresholds
threshMat <- seed_thresholds(n = n,
m = m,
threshold_means = ThreshM,
threshold_sds = ThreshSD)
View(stimMat)
X_g <- matrix(data = rep(0, length(P_g)), ncol = ncol(P_g))
# Create cumulative task performance matrix
X_tot <- X_g
# Create cumulative adjacency matrix
g_tot <-  matrix(data = rep(0, n * n), ncol = n)
colnames(g_tot) <- paste0("v-", 1:n)
rownames(g_tot) <- paste0("v-", 1:n)
storage_path <- "output/test"
dir_name <- paste0("n", n,  "-Sigma", (ThreshSD/ThreshM)[1], "-Epsilon", epsilon, "_BetaSweep_stimorder")
full_path <- paste0(storage_path, dir_name)
dir.create(full_path)
sub_dirs <- c("TaskDist", "Entropy")
for (sub_dir in sub_dirs) {
dir.create(paste0(full_path, "/", sub_dir), showWarnings = FALSE)
}
chunk_run  <- 1:(reps / chunk_size)
run_in_parallel <- expand.grid(beta =  round(betas, digits = 3), run = chunk_run) #rounding to make sure numbers are what they appear
run_in_parallel <- run_in_parallel %>%
arrange(beta)
# Read files already simulated and filter out of needed parameters
already_ran <- list.files(path = paste0(full_path, "/Entropy/"))
ran_files <- lapply(already_ran, function(f) {
beta_val <- as.numeric(gsub("([\\.0-9]+)-[0-9]+\\.Rdata", "\\1", x = f, perl = TRUE))
chunk_num <- as.numeric(gsub("[\\.0-9]+-([0-9]+)\\.Rdata", "\\1", x = f, perl = TRUE))
to_return <- data.frame(beta = beta_val, run = chunk_num)
return(to_return)
})
ran_files <- do.call('rbind', ran_files)
run_in_parallel <- run_in_parallel %>%
anti_join(ran_files)
already_ran <- list.files(path = paste0(full_path, "/Entropy/"))
ran_files <- lapply(already_ran, function(f) {
beta_val <- as.numeric(gsub("([\\.0-9]+)-[0-9]+\\.Rdata", "\\1", x = f, perl = TRUE))
chunk_num <- as.numeric(gsub("[\\.0-9]+-([0-9]+)\\.Rdata", "\\1", x = f, perl = TRUE))
to_return <- data.frame(beta = beta_val, run = chunk_num)
return(to_return)
})
ran_files <- do.call('rbind', ran_files)
ran_files
is.null(ran_files)
!is.null(ran_files)
storage_path <- "output/test"
dir_name <- paste0("n", n,  "-Sigma", (ThreshSD/ThreshM)[1], "-Epsilon", epsilon, "_BetaSweep_stimorder")
full_path <- paste0(storage_path, dir_name)
dir.create(full_path)
sub_dirs <- c("TaskDist", "Entropy")
storage_path <- "output/test/"
dir_name <- paste0("n", n,  "-Sigma", (ThreshSD/ThreshM)[1], "-Epsilon", epsilon, "_BetaSweep_stimorder")
full_path <- paste0(storage_path, dir_name)
dir.create(full_path)
sub_dirs <- c("TaskDist", "Entropy")
for (sub_dir in sub_dirs) {
dir.create(paste0(full_path, "/", sub_dir), showWarnings = FALSE)
}
full_path
files <- list.files(full_path)
files
# Check if there is already some runs done
completed_runs <- data.frame(n = as.numeric(gsub(x = already_ran, "n([0-9]+)-.*", "\\1", perl = T)))
completed_runs$beta <- as.numeric(gsub(x = files, ".*-beta([\\.0-9]+).Rdata$", "\\1", perl = T))
run_in_parallel <- anti_join(run_in_parallel, completed_runs, by = c("n", "beta"))
