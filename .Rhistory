rownames(g_tot) <- paste0("v-", 1:n)
####################
# Simulate individual run
####################
# Run simulation
for (t in 1:gens) {
# Current timestep is actually t+1 in this formulation, because first row is timestep 0
# Update stimuli
stimMat <- update_stim(stim_matrix = stimMat,
deltas = deltas,
alpha = alpha,
state_matrix = X_g,
time_step = t)
# Calculate task demand based on global stimuli
P_g <- calc_determ_thresh(time_step        = t + 1, # first row is generation 0
threshold_matrix = threshMat,
stimulus_matrix  = stimMat)
# Update task performance
X_g <- update_task_performance(task_probs   = P_g,
state_matrix = X_g,
quit_prob    = quitP)
# Update social network (previously this was before probability/task update)
g_adj <- temporalNetwork(X_sub_g = X_g,
prob_interact = p,
bias = beta)
g_tot <- g_tot + g_adj
# Adjust thresholds
threshMat <- adjust_thresholds_social_capped(social_network = g_adj,
threshold_matrix = threshMat,
state_matrix = X_g,
epsilon = epsilon,
threshold_max = 2 * ThreshM[1])
# Update total task performance profile
X_tot <- X_tot + X_g
# Capture stats if it is appropriate window
if (t %in% times) {
# Get DOL
window_entropy <- mutualEntropy(X_tot)
# Bind
all_info <- matrix(data = c(n, beta, sim, t),
nrow = 1,
dimnames = list(NULL,
c("n", "sim", "chunk", "t")))
all_info <- cbind(all_info, window_entropy)
if (!exists("sim_info")) {
sim_info <- all_info
} else {
sim_info <- rbind(sim_info, all_info)
}
rm(all_info, window_entropy)
}
}
group_size_list[[sim]] <- sim_info
print(paste0("Done ", sim))
} #end of replicate simulations loop
to_return <- do.call("rbind", group_size_list)
View(to_return)
# set group size
n <- Ns[x]
# set list for collection of sim_data
group_size_list <- list()
# Run Simulations
for (sim in 1:reps) {
####################
# Seed structures and intial matrices
####################
# Set initial probability matrix (P_g)
P_g <- matrix(data = rep(0, n * m), ncol = m)
# Seed task (external) stimuli
stimMat <- seed_stimuls(intitial_stim = InitialStim,
gens = gens)
# Seed internal thresholds
threshMat <- seed_thresholds(n = n,
m = m,
threshold_means = ThreshM,
threshold_sds = ThreshSD)
# Start task performance
X_g <- matrix(data = rep(0, length(P_g)), ncol = ncol(P_g))
# Create cumulative task performance matrix
X_tot <- X_g
# Create cumulative adjacency matrix
g_tot <-  matrix(data = rep(0, n * n), ncol = n)
colnames(g_tot) <- paste0("v-", 1:n)
rownames(g_tot) <- paste0("v-", 1:n)
####################
# Simulate individual run
####################
# Run simulation
for (t in 1:gens) {
# Current timestep is actually t+1 in this formulation, because first row is timestep 0
# Update stimuli
stimMat <- update_stim(stim_matrix = stimMat,
deltas = deltas,
alpha = alpha,
state_matrix = X_g,
time_step = t)
# Calculate task demand based on global stimuli
P_g <- calc_determ_thresh(time_step        = t + 1, # first row is generation 0
threshold_matrix = threshMat,
stimulus_matrix  = stimMat)
# Update task performance
X_g <- update_task_performance(task_probs   = P_g,
state_matrix = X_g,
quit_prob    = quitP)
# Update social network (previously this was before probability/task update)
g_adj <- temporalNetwork(X_sub_g = X_g,
prob_interact = p,
bias = beta)
g_tot <- g_tot + g_adj
# Adjust thresholds
threshMat <- adjust_thresholds_social_capped(social_network = g_adj,
threshold_matrix = threshMat,
state_matrix = X_g,
epsilon = epsilon,
threshold_max = 2 * ThreshM[1])
# Update total task performance profile
X_tot <- X_tot + X_g
# Capture stats if it is appropriate window
if (t %in% times) {
# Get DOL
window_entropy <- mutualEntropy(X_tot)
# Bind
all_info <- matrix(data = c(n, beta, sim, t),
nrow = 1,
dimnames = list(NULL,
c("n", "beta", "sim", "t")))
all_info <- cbind(all_info, window_entropy)
if (!exists("sim_info")) {
sim_info <- all_info
} else {
sim_info <- rbind(sim_info, all_info)
}
rm(all_info, window_entropy)
}
}
group_size_list[[sim]] <- sim_info
print(paste0("Done ", sim))
} #end of replicate simulations loop
to_return <- do.call("rbind", group_size_list)
View(to_return)
sim_info
rm(sim_info)
# Run Simulations
for (sim in 1:reps) {
####################
# Seed structures and intial matrices
####################
# Set initial probability matrix (P_g)
P_g <- matrix(data = rep(0, n * m), ncol = m)
# Seed task (external) stimuli
stimMat <- seed_stimuls(intitial_stim = InitialStim,
gens = gens)
# Seed internal thresholds
threshMat <- seed_thresholds(n = n,
m = m,
threshold_means = ThreshM,
threshold_sds = ThreshSD)
# Start task performance
X_g <- matrix(data = rep(0, length(P_g)), ncol = ncol(P_g))
# Create cumulative task performance matrix
X_tot <- X_g
# Create cumulative adjacency matrix
g_tot <-  matrix(data = rep(0, n * n), ncol = n)
colnames(g_tot) <- paste0("v-", 1:n)
rownames(g_tot) <- paste0("v-", 1:n)
####################
# Simulate individual run
####################
# Run simulation
for (t in 1:gens) {
# Current timestep is actually t+1 in this formulation, because first row is timestep 0
# Update stimuli
stimMat <- update_stim(stim_matrix = stimMat,
deltas = deltas,
alpha = alpha,
state_matrix = X_g,
time_step = t)
# Calculate task demand based on global stimuli
P_g <- calc_determ_thresh(time_step        = t + 1, # first row is generation 0
threshold_matrix = threshMat,
stimulus_matrix  = stimMat)
# Update task performance
X_g <- update_task_performance(task_probs   = P_g,
state_matrix = X_g,
quit_prob    = quitP)
# Update social network (previously this was before probability/task update)
g_adj <- temporalNetwork(X_sub_g = X_g,
prob_interact = p,
bias = beta)
g_tot <- g_tot + g_adj
# Adjust thresholds
threshMat <- adjust_thresholds_social_capped(social_network = g_adj,
threshold_matrix = threshMat,
state_matrix = X_g,
epsilon = epsilon,
threshold_max = 2 * ThreshM[1])
# Update total task performance profile
X_tot <- X_tot + X_g
# Capture stats if it is appropriate window
if (t %in% times) {
# Get DOL
window_entropy <- mutualEntropy(X_tot)
# Bind
all_info <- matrix(data = c(n, beta, sim, t),
nrow = 1,
dimnames = list(NULL,
c("n", "beta", "sim", "t")))
all_info <- cbind(all_info, window_entropy)
if (!exists("sim_info")) {
sim_info <- all_info
} else {
sim_info <- rbind(sim_info, all_info)
}
rm(all_info, window_entropy)
}
}
group_size_list[[sim]] <- sim_info
print(paste0("Done ", sim))
rm(sim_info)
} #end of replicate simulations loop
to_return <- do.call("rbind", group_size_list)
View(to_return)
source('~/Documents/Research/Tarnita Lab/Social Interaction DOL/SocialModel/scripts/2b_Process_ClusterSimData.R', echo=TRUE)
rm(list = ls())
source("scripts/util/__Util__MASTER.R")
library(RColorBrewer)
library(scales)
rm(list = ls())
source("scripts/util/__Util__MASTER.R")
library(RColorBrewer)
library(scales)
####################
# Load data
####################
load("output/Rdata/_ProcessedData/Entropy/Sigma0-Epsilon0.1-Beta1.1.Rdata")
compiled_data$Model <- "Social_Epsilon 0.0"
entropy_data <- compiled_data
rm(compiled_data)
load("output/Rdata/_ProcessedData/Entropy/Sigma0-Epsilon0.4-Beta1.1-LongRun.Rdata")
compiled_data$Model <- "Social_Epsilon0.4"
entropy_data <- rbind(entropy_data, compiled_data)
rm(compiled_data)
####################
# Summarise data
####################
# Calculate mean and SE
entropy <- entropy_data %>%
group_by(Model, n) %>%
summarise(Mean = mean(Dind),
SD = sd(Dind),
SE = sd(Dind) / sqrt(length(Dind)))
####################
# Plot
####################
pal <- brewer.pal(5, "Greens")[c(2, 4, 5)]
gg_entropy <- ggplot(data = entropy, aes(x = n, colour = Model)) +
geom_errorbar(aes(ymin = Mean - SD, ymax = Mean + SD),
width = 0,
size = 0.3) +
geom_line(aes(y = Mean),
size = 0.4) +
geom_point(aes(y = Mean),
size = 0.8) +
theme_classic() +
xlab(expression(paste("Group Size (", italic(n), ")"))) +
ylab(expression(paste("Division of labor (", italic(D[indiv]), ")"))) +
scale_x_continuous(breaks = seq(0, 100, 20)) +
scale_color_manual(values = pal,
labels = c("1.2", "1.1"),
name = expression("Interaction bias"(Beta))) +
theme(axis.text = element_text(colour = "black", size = 6),
axis.title = element_text(size = 7, face = "italic"),
legend.position = "none",
legend.title = element_text(size = 7,
face = "bold"),
legend.text = element_text(size = 6),
legend.key.height = unit(4, "mm"),
legend.key.width = unit(5, "mm"),
axis.ticks = element_line(size = 0.3, color = "black"),
axis.line = element_line(size = 0.3, color = "black"),
aspect.ratio = 1)
gg_entropy
####################
# Load data
####################
load("output/Rdata/_ProcessedData/Entropy/Sigma0-Epsilon0.4-Beta1.1.Rdata")
compiled_data$Model <- "Social_Epsilon 0.0"
load("output/Rdata/_ProcessedData/Entropy/Sigma0-Epsilon0.4-Beta1.1.Rdata")
compiled_data$Model <- "Social_Epsilon 0.0"
entropy_data <- compiled_data
rm(compiled_data)
load("output/Rdata/_ProcessedData/Entropy/Sigma0-Epsilon0.4-Beta1.1-LongRun.Rdata")
compiled_data$Model <- "Social_Epsilon0.4"
entropy_data <- rbind(entropy_data, compiled_data)
rm(compiled_data)
####################
# Summarise data
####################
# Calculate mean and SE
entropy <- entropy_data %>%
group_by(Model, n) %>%
summarise(Mean = mean(Dind),
SD = sd(Dind),
SE = sd(Dind) / sqrt(length(Dind)))
####################
# Plot
####################
pal <- brewer.pal(5, "Greens")[c(2, 4, 5)]
gg_entropy <- ggplot(data = entropy, aes(x = n, colour = Model)) +
geom_errorbar(aes(ymin = Mean - SD, ymax = Mean + SD),
width = 0,
size = 0.3) +
geom_line(aes(y = Mean),
size = 0.4) +
geom_point(aes(y = Mean),
size = 0.8) +
theme_classic() +
xlab(expression(paste("Group Size (", italic(n), ")"))) +
ylab(expression(paste("Division of labor (", italic(D[indiv]), ")"))) +
scale_x_continuous(breaks = seq(0, 100, 20)) +
scale_color_manual(values = pal,
labels = c("1.2", "1.1"),
name = expression("Interaction bias"(Beta))) +
theme(axis.text = element_text(colour = "black", size = 6),
axis.title = element_text(size = 7, face = "italic"),
legend.position = "none",
legend.title = element_text(size = 7,
face = "bold"),
legend.text = element_text(size = 6),
legend.key.height = unit(4, "mm"),
legend.key.width = unit(5, "mm"),
axis.ticks = element_line(size = 0.3, color = "black"),
axis.line = element_line(size = 0.3, color = "black"),
aspect.ratio = 1)
gg_entropy
Sys.sleep()
Sys.sleep(1)
Sys.sleep(1)
rm(list = ls())
source("scripts/util/__Util__MASTER.R")
####################
# Load and process data
####################
# Load DOL values
load("output/AnalyticalResults/CalculateNstar-50_Sigma0-Epsilon0.1.Rdata")
source('~/Documents/Research/Tarnita Lab/Social Interaction DOL/SocialModel/scripts/supp_analysis/Check_TheshLimit_TrackThresh.R', echo=TRUE)
source('~/Documents/Research/Tarnita Lab/Social Interaction DOL/SocialModel/scripts/supp_analysis/Check_TheshLimit_TrackThresh.R', echo=TRUE)
# Normal threshold limit
load("output/ThresholdTime/ThresholdLimits/ThreshMax-100.Rdata")
gg_threshtime_100 <- ggplot(thresh_time, aes(x = t, y = Threshold, group = Id)) +
geom_line(size = 0.1, alpha = 0.1, colour = "#1f78b4") +
scale_x_continuous(name = expression(paste("Time step (", italic(t), ")")),
breaks = seq(0, 50000, 10000),
labels = c("", "10,000", "", "30,000", "", "50,000"),
expand = c(0, 0)) +
scale_y_continuous(name = expression(paste("Task 1 threshold (", italic(theta[i1,t]), ")")),
limits = c(0, 100),
breaks = seq(0, 100, 50)) +
theme_ctokita() +
theme(axis.title.y = element_blank(),
axis.text.x = element_text(hjust = 0.8))
gg_threshtime_100
ggsave(gg_threshtime_100, file = "output/ThresholdTime/ThresholdLimits/Max-100.png", height = 26, width = 40, units = "mm", dpi = 400)
# High threshold limit
load("output/ThresholdTime/ThresholdLimits/ThreshMax-1000.Rdata")
gg_threshtime_1000 <- ggplot(thresh_time, aes(x = t, y = Threshold, group = Id)) +
geom_line(size = 0.1, alpha = 0.1, colour = "#8bbeda") +
scale_x_continuous(name = expression(paste("Time step (", italic(t), ")")),
breaks = seq(0, 50000, 10000),
labels = c("", "10,000", "", "30,000", "", "50,000"),
expand = c(0, 0)) +
scale_y_continuous(name = expression(paste("Task 1 threshold (", italic(theta[i1,t]), ")")),
limits = c(0, 1000),
breaks = seq(0, 1000, 500),
label = comma) +
theme_ctokita() +
theme(axis.title.y = element_blank(),
axis.text.x = element_text(hjust = 0.8))
gg_threshtime_1000
ggsave(gg_threshtime_1000, file = "output/ThresholdTime/ThresholdLimits/Max-1000.png", height = 26, width = 42, units = "mm")
# ------------------------------ Thresholds over time  ------------------------------
####################
# Load normal threshold limit (epsilon = 0.4, beta = 1.1)
####################
library(scales)
load("output/ThresholdTime/ThresholdLimits/ThreshMax-1000.Rdata")
gg_threshtime_1000 <- ggplot(thresh_time, aes(x = t, y = Threshold, group = Id)) +
geom_line(size = 0.1, alpha = 0.1, colour = "#8bbeda") +
scale_x_continuous(name = expression(paste("Time step (", italic(t), ")")),
breaks = seq(0, 50000, 10000),
labels = c("", "10,000", "", "30,000", "", "50,000"),
expand = c(0, 0)) +
scale_y_continuous(name = expression(paste("Task 1 threshold (", italic(theta[i1,t]), ")")),
limits = c(0, 1000),
breaks = seq(0, 1000, 500),
label = comma) +
theme_ctokita() +
theme(axis.title.y = element_blank(),
axis.text.x = element_text(hjust = 0.8))
gg_threshtime_1000
ggsave(gg_threshtime_1000, file = "output/ThresholdTime/ThresholdLimits/Max-1000.png", height = 26, width = 42, units = "mm")
gg_threshtime_1000 <- ggplot(thresh_time, aes(x = t, y = Threshold, group = Id)) +
geom_line(size = 0.1, alpha = 0.15, colour = "#8bbeda") +
scale_x_continuous(name = expression(paste("Time step (", italic(t), ")")),
breaks = seq(0, 50000, 10000),
labels = c("", "10,000", "", "30,000", "", "50,000"),
expand = c(0, 0)) +
scale_y_continuous(name = expression(paste("Task 1 threshold (", italic(theta[i1,t]), ")")),
limits = c(0, 1000),
breaks = seq(0, 1000, 500),
label = comma) +
theme_ctokita() +
theme(axis.title.y = element_blank(),
axis.text.x = element_text(hjust = 0.8))
gg_threshtime_1000
ggsave(gg_threshtime_1000, file = "output/ThresholdTime/ThresholdLimits/Max-1000.png", height = 26, width = 42, units = "mm")
library(scales)
# Normal threshold limit
load("output/ThresholdTime/ThresholdLimits/ThreshMax-100.Rdata")
gg_threshtime_100 <- ggplot(thresh_time, aes(x = t, y = Threshold, group = Id)) +
geom_line(size = 0.1, alpha = 0.1, colour = "#1f78b4") +
scale_x_continuous(name = expression(paste("Time step (", italic(t), ")")),
breaks = seq(0, 50000, 10000),
labels = c("", "10,000", "", "30,000", "", "50,000"),
expand = c(0, 0)) +
scale_y_continuous(name = expression(paste("Task 1 threshold (", italic(theta[i1,t]), ")")),
limits = c(0, 100),
breaks = seq(0, 100, 50)) +
theme_ctokita() +
theme(axis.title.y = element_blank(),
axis.text.x = element_text(hjust = 0.8))
gg_threshtime_100
ggsave(gg_threshtime_100, file = "output/ThresholdTime/ThresholdLimits/Max-100.png", height = 26, width = 40, units = "mm", dpi = 500)
# High threshold limit
load("output/ThresholdTime/ThresholdLimits/ThreshMax-1000.Rdata")
gg_threshtime_1000 <- ggplot(thresh_time, aes(x = t, y = Threshold, group = Id)) +
geom_line(size = 0.1, alpha = 0.15, colour = "#8bbeda") +
scale_x_continuous(name = expression(paste("Time step (", italic(t), ")")),
breaks = seq(0, 50000, 10000),
labels = c("", "10,000", "", "30,000", "", "50,000"),
expand = c(0, 0)) +
scale_y_continuous(name = expression(paste("Task 1 threshold (", italic(theta[i1,t]), ")")),
limits = c(0, 1000),
breaks = seq(0, 1000, 500),
label = comma) +
theme_ctokita() +
theme(axis.title.y = element_blank(),
axis.text.x = element_text(hjust = 0.8))
gg_threshtime_1000
ggsave(gg_threshtime_1000, file = "output/ThresholdTime/ThresholdLimits/Max-1000.png", height = 26, width = 42, units = "mm", , dpi = 500)
gg_threshtime_100 <- ggplot(thresh_time, aes(x = t, y = Threshold, group = Id)) +
geom_line(size = 0.1, alpha = 0.1, colour = "#1f78b4") +
scale_x_continuous(name = expression(paste("Time step (", italic(t), ")")),
breaks = seq(0, 50000, 10000),
labels = c("", "10,000", "", "30,000", "", "50,000"),
expand = c(0, 0)) +
scale_y_continuous(name = expression(paste("Task 1 threshold (", italic(theta[i1,t]), ")")),
limits = c(0, 100),
breaks = seq(0, 100, 50)) +
theme_ctokita() +
theme(axis.title.y = element_blank(),
axis.text.x = element_text(hjust = 0.6))
gg_threshtime_100
# Normal threshold limit
load("output/ThresholdTime/ThresholdLimits/ThreshMax-100.Rdata")
gg_threshtime_100 <- ggplot(thresh_time, aes(x = t, y = Threshold, group = Id)) +
geom_line(size = 0.1, alpha = 0.1, colour = "#1f78b4") +
scale_x_continuous(name = expression(paste("Time step (", italic(t), ")")),
breaks = seq(0, 50000, 10000),
labels = c("", "10,000", "", "30,000", "", "50,000"),
expand = c(0, 0)) +
scale_y_continuous(name = expression(paste("Task 1 threshold (", italic(theta[i1,t]), ")")),
limits = c(0, 100),
breaks = seq(0, 100, 50)) +
theme_ctokita() +
theme(axis.title.y = element_blank(),
axis.text.x = element_text(hjust = 0.65))
gg_threshtime_100
library(scales)
# Normal threshold limit
load("output/ThresholdTime/ThresholdLimits/ThreshMax-100.Rdata")
gg_threshtime_100 <- ggplot(thresh_time, aes(x = t, y = Threshold, group = Id)) +
geom_line(size = 0.1, alpha = 0.1, colour = "#1f78b4") +
scale_x_continuous(name = expression(paste("Time step (", italic(t), ")")),
breaks = seq(0, 50000, 10000),
labels = c("", "10,000", "", "30,000", "", "50,000"),
expand = c(0, 0)) +
scale_y_continuous(name = expression(paste("Task 1 threshold (", italic(theta[i1,t]), ")")),
limits = c(0, 100),
breaks = seq(0, 100, 50)) +
theme_ctokita() +
theme(axis.title.y = element_blank(),
axis.text.x = element_text(hjust = 0.7))
gg_threshtime_100
ggsave(gg_threshtime_100, file = "output/ThresholdTime/ThresholdLimits/Max-100.png", height = 26, width = 40, units = "mm", dpi = 500)
# High threshold limit
load("output/ThresholdTime/ThresholdLimits/ThreshMax-1000.Rdata")
gg_threshtime_1000 <- ggplot(thresh_time, aes(x = t, y = Threshold, group = Id)) +
geom_line(size = 0.1, alpha = 0.15, colour = "#8bbeda") +
scale_x_continuous(name = expression(paste("Time step (", italic(t), ")")),
breaks = seq(0, 50000, 10000),
labels = c("", "10,000", "", "30,000", "", "50,000"),
expand = c(0, 0)) +
scale_y_continuous(name = expression(paste("Task 1 threshold (", italic(theta[i1,t]), ")")),
limits = c(0, 1000),
breaks = seq(0, 1000, 500),
label = comma) +
theme_ctokita() +
theme(axis.title.y = element_blank(),
axis.text.x = element_text(hjust = 0.7))
gg_threshtime_1000
ggsave(gg_threshtime_1000, file = "output/ThresholdTime/ThresholdLimits/Max-1000.png", height = 26, width = 42, units = "mm", dpi = 500)
