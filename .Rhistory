scale_y_continuous(breaks = seq(0, 1, 0.2),
expand = c(0,0)) +
scale_fill_gradientn(colours = pal, name = "Behavioral\nspecialization",
limits = c(0, 1)) +
scale_colour_gradientn(colours = pal, name = "Behavioral\nspecialization",
limits = c(0, 1)) +
ylab(expression(epsilon)) +
theme(axis.text = element_text(colour = "black", size = 6),
axis.title = element_text(size = 7),
legend.title = element_text(size = 7,
face = "bold"),
legend.text = element_text(size = 6),
legend.key.height = unit(5, "mm"),
legend.key.width = unit(2, "mm"),
axis.ticks = element_line(size = 0.3),
panel.background = element_rect(fill = NA, size = 0.3),
aspect.ratio = 1)
gg_eps
ggsave(gg_eps, file = "output/ParameterSpace/Plots/EpsilonGroupSizeSpace.png", height = 45, units = "mm", dpi = 400)
rm(list = ls())
source("scripts/util/__Util__MASTER.R")
library(RColorBrewer)
library(scales)
####################
# Load Data: epsilon
####################
directory <- "output/Rdata/_GroupSizeEpsilonSweep_Sigma0-Beta1.1/"
# List files
files <- list.files(directory, full.names = TRUE)
for (file in files) {
load(file)
epsilon <- as.numeric(gsub(".*epsilon([\\.0-9]+).Rdata", "\\1", file, perl = TRUE))
entropy_sum$epsilon <- epsilon
if (!exists("entropy")) {
entropy <- entropy_sum
} else {
entropy <- rbind(entropy, entropy_sum)
}
}
save(entropy, file = "output/ParameterSpace/GroupSizeEpsilonSweep_Sigma0-Beta1.1.Rdata")
################################################################################
#
# Entropy across parameter
#
################################################################################
rm(list = ls())
source("scripts/util/__Util__MASTER.R")
library(RColorBrewer)
library(scales)
####################
# Load Data: epsilon
####################
directory <- "output/Rdata/_GroupSizeEpsilonSweep_Sigma0-Beta1.1/"
# List files
files <- list.files(directory, full.names = TRUE)
for (file in files) {
load(file)
epsilon <- as.numeric(gsub(".*epsilon([\\.0-9]+).Rdata", "\\1", file, perl = TRUE))
entropy_sum$epsilon <- epsilon
if (!exists("entropy")) {
entropy <- entropy_sum
} else {
entropy <- rbind(entropy, entropy_sum)
}
}
rm(list = ls())
source("scripts/util/__Util__MASTER.R")
library(RColorBrewer)
library(scales)
####################
# Load Data: epsilon
####################
directory <- "output/Rdata/_GroupSizeEpsilonSweep_Sigma0-Beta1.1/"
# List files
files <- list.files(directory, full.names = TRUE)
####################
# Load Data: epsilon
####################
directory <- "output/Rdata/GroupSizeEpsilonSweep_Sigma0-Beta1.1/"
# List files
files <- list.files(directory, full.names = TRUE)
for (file in files) {
load(file)
epsilon <- as.numeric(gsub(".*epsilon([\\.0-9]+).Rdata", "\\1", file, perl = TRUE))
entropy_sum$epsilon <- epsilon
if (!exists("entropy")) {
entropy <- entropy_sum
} else {
entropy <- rbind(entropy, entropy_sum)
}
}
save(entropy, file = "output/ParameterSpace/GroupSizeEpsilonSweep_Sigma0-Beta1.1.Rdata")
rm(list = ls())
####################
# Source necessary scripts/libraries
####################
source("scripts/util/__Util__MASTER.R")
library(RColorBrewer)
library(scales)
####################
# Load data
####################
load("output/ParameterSpace/GroupSizeEpsilonSweep_Sigma0-Beta1.1.Rdata")
####################
# Plot: Epsilon sweep
####################
pal <- brewer_pal("seq", "YlGnBu")
pal <- pal(9)
gg_eps <- ggplot(data = entropy, aes(x = n, y = epsilon, fill = Dind_mean, colour = Dind_mean)) +
geom_tile() +
theme_bw() +
scale_x_continuous(breaks = seq(0, 100, 20),
expand = c(0,0)) +
scale_y_continuous(breaks = seq(0, 1, 0.2),
expand = c(0,0)) +
scale_fill_gradientn(colours = pal, name = "Behavioral\nspecialization",
limits = c(0, 1)) +
scale_colour_gradientn(colours = pal, name = "Behavioral\nspecialization",
limits = c(0, 1)) +
ylab(expression(epsilon)) +
theme(axis.text = element_text(colour = "black", size = 6),
axis.title = element_text(size = 7),
legend.title = element_text(size = 7,
face = "bold"),
legend.text = element_text(size = 6),
legend.key.height = unit(5, "mm"),
legend.key.width = unit(2, "mm"),
axis.ticks = element_line(size = 0.3),
panel.background = element_rect(fill = NA, size = 0.3),
aspect.ratio = 1)
gg_eps
gg_eps <- ggplot(data = entropy, aes(x = n, y = epsilon, fill = Dind_mean, colour = Dind_mean)) +
geom_tile() +
theme_bw() +
scale_x_continuous(breaks = seq(0, 100, 20),
expand = c(0,0)) +
scale_y_continuous(breaks = seq(0, 0.4, 0.2),
expand = c(0,0)) +
scale_fill_gradientn(colours = pal, name = "Behavioral\nspecialization",
limits = c(0, 1)) +
scale_colour_gradientn(colours = pal, name = "Behavioral\nspecialization",
limits = c(0, 1)) +
ylab(expression(epsilon)) +
theme(axis.text = element_text(colour = "black", size = 6),
axis.title = element_text(size = 7),
legend.title = element_text(size = 7,
face = "bold"),
legend.text = element_text(size = 6),
legend.key.height = unit(5, "mm"),
legend.key.width = unit(2, "mm"),
axis.ticks = element_line(size = 0.3),
panel.background = element_rect(fill = NA, size = 0.3),
aspect.ratio = 1)
gg_eps
gg_eps <- ggplot(data = entropy, aes(x = n, y = epsilon, fill = Dind_mean, colour = Dind_mean)) +
geom_tile() +
theme_bw() +
scale_x_continuous(breaks = seq(0, 100, 20),
expand = c(0,0)) +
scale_y_continuous(breaks = seq(0, 1, 0.2),
expand = c(0,0),
limits = c(0, 0.5)) +
scale_fill_gradientn(colours = pal, name = "Behavioral\nspecialization",
limits = c(0, 1)) +
scale_colour_gradientn(colours = pal, name = "Behavioral\nspecialization",
limits = c(0, 1)) +
ylab(expression(epsilon)) +
theme(axis.text = element_text(colour = "black", size = 6),
axis.title = element_text(size = 7),
legend.title = element_text(size = 7,
face = "bold"),
legend.text = element_text(size = 6),
legend.key.height = unit(5, "mm"),
legend.key.width = unit(2, "mm"),
axis.ticks = element_line(size = 0.3),
panel.background = element_rect(fill = NA, size = 0.3),
aspect.ratio = 1)
gg_eps
gg_eps <- ggplot(data = entropy, aes(x = n, y = epsilon, fill = Dind_mean, colour = Dind_mean)) +
geom_tile() +
theme_bw() +
scale_x_continuous(breaks = seq(0, 100, 20),
expand = c(0,0)) +
scale_y_continuous(breaks = seq(0, 1, 0.2),
expand = c(0,0),
limits = c(0, 0.55)) +
scale_fill_gradientn(colours = pal, name = "Behavioral\nspecialization",
limits = c(0, 1)) +
scale_colour_gradientn(colours = pal, name = "Behavioral\nspecialization",
limits = c(0, 1)) +
ylab(expression(epsilon)) +
theme(axis.text = element_text(colour = "black", size = 6),
axis.title = element_text(size = 7),
legend.title = element_text(size = 7,
face = "bold"),
legend.text = element_text(size = 6),
legend.key.height = unit(5, "mm"),
legend.key.width = unit(2, "mm"),
axis.ticks = element_line(size = 0.3),
panel.background = element_rect(fill = NA, size = 0.3),
aspect.ratio = 1)
gg_eps
gg_eps <- ggplot(data = entropy, aes(x = n, y = epsilon, fill = Dind_mean, colour = Dind_mean)) +
geom_tile() +
theme_bw() +
scale_x_continuous(breaks = seq(0, 100, 20),
expand = c(0,0)) +
scale_y_continuous(breaks = seq(0, 1, 0.2),
expand = c(0,0),
limits = c(0, 0.6)) +
scale_fill_gradientn(colours = pal, name = "Behavioral\nspecialization",
limits = c(0, 1)) +
scale_colour_gradientn(colours = pal, name = "Behavioral\nspecialization",
limits = c(0, 1)) +
ylab(expression(epsilon)) +
theme(axis.text = element_text(colour = "black", size = 6),
axis.title = element_text(size = 7),
legend.title = element_text(size = 7,
face = "bold"),
legend.text = element_text(size = 6),
legend.key.height = unit(5, "mm"),
legend.key.width = unit(2, "mm"),
axis.ticks = element_line(size = 0.3),
panel.background = element_rect(fill = NA, size = 0.3),
aspect.ratio = 1)
gg_eps
length(seq(0, 0.6, 0.025))
length(seq(5, 100, 5))
20*25
length(seq(1, 1.25, 0.01))
epsilons       <- seq(0, 0.6, 0.025) #relative weighting of social interactions for adjusting thresholds
################################################################################
#
# Social interaction model: Sweep epsilon and group size parameter space
#
################################################################################
rm(list = ls())
####################
# Source necessary scripts/libraries
####################
source("scripts/util/__Util__MASTER.R")
library(parallel)
library(snowfall)
####################
# Set global variables
####################
# Initial paramters: Free to change
# Base parameters
Ns             <- seq(5, 100, 5) #vector of number of individuals to simulate
m              <- 2 #number of tasks
gens           <- 50000 #number of generations to run simulation
reps           <- 100 #number of replications per simulation (for ensemble)
# Threshold Parameters
ThreshM        <- rep(50, m) #population threshold means
ThreshSD       <- ThreshM * 0 #population threshold standard deviations
InitialStim    <- rep(0, m) #intital vector of stimuli
deltas         <- rep(0.8, m) #vector of stimuli increase rates
alpha          <- m #efficiency of task performance
quitP          <- 0.2 #probability of quitting task once active
# Social Network Parameters
p              <- 0.5 #baseline probablity of initiating an interaction per time step
epsilons       <- seq(0, 0.6, 0.025) #relative weighting of social interactions for adjusting thresholds
beta           <- 1.1 #probability of interacting with individual in same state relative to others
####################
# Prep for Parallelization
####################
# Create parameter combinations for parallelization
run_in_parallel <- expand.grid(n = Ns, epsilon = epsilons)
run_in_parallel <- run_in_parallel %>%
arrange(n)
################################################################################
#
# Social interaction model: Sweep beta and group size parameter space
#
################################################################################
rm(list = ls())
####################
# Source necessary scripts/libraries
####################
source("scripts/util/__Util__MASTER.R")
library(parallel)
library(snowfall)
####################
# Set global variables
####################
# Initial paramters: Free to change
# Base parameters
Ns             <- seq(5, 100, 5) #vector of number of individuals to simulate
m              <- 2 #number of tasks
gens           <- 50000 #number of generations to run simulation
reps           <- 100 #number of replications per simulation (for ensemble)
# Threshold Parameters
ThreshM        <- rep(50, m) #population threshold means
ThreshSD       <- ThreshM * 0 #population threshold standard deviations
InitialStim    <- rep(0, m) #intital vector of stimuli
deltas         <- rep(0.8, m) #vector of stimuli increase rates
alpha          <- m #efficiency of task performance
quitP          <- 0.2 #probability of quitting task once active
# Social Network Parameters
p              <- 0.5 #baseline probablity of initiating an interaction per time step
epsilon        <- 0.1 #relative weighting of social interactions for adjusting thresholds
betas          <- seq(1, 1.25, 0.01) #probability of interacting with individual in same state relative to others
####################
# Prep for Parallelization
####################
# Create parameter combinations for parallelization
run_in_parallel <- expand.grid(n = Ns, beta = betas)
run_in_parallel <- run_in_parallel %>%
arrange(n)
################################################################################
#
# Social interaction model: Sweep epsilon and group size parameter space
#
################################################################################
rm(list = ls())
####################
# Source necessary scripts/libraries
####################
source("scripts/util/__Util__MASTER.R")
library(parallel)
library(snowfall)
####################
# Set global variables
####################
# Initial paramters: Free to change
# Base parameters
Ns             <- seq(5, 100, 5) #vector of number of individuals to simulate
m              <- 2 #number of tasks
gens           <- 50000 #number of generations to run simulation
reps           <- 100 #number of replications per simulation (for ensemble)
# Threshold Parameters
ThreshM        <- rep(50, m) #population threshold means
ThreshSD       <- ThreshM * 0 #population threshold standard deviations
InitialStim    <- rep(0, m) #intital vector of stimuli
deltas         <- rep(0.8, m) #vector of stimuli increase rates
alpha          <- m #efficiency of task performance
quitP          <- 0.2 #probability of quitting task once active
# Social Network Parameters
p              <- 0.5 #baseline probablity of initiating an interaction per time step
epsilons       <- seq(0, 0.6, 0.025) #relative weighting of social interactions for adjusting thresholds
beta           <- 1.1 #probability of interacting with individual in same state relative to others
####################
# Prep for Parallelization
####################
# Create parameter combinations for parallelization
run_in_parallel <- expand.grid(n = Ns, epsilon = epsilons)
run_in_parallel <- run_in_parallel %>%
arrange(n)
26*20
epsilons       <- seq(0, 0.6, 0.02) #relative weighting of social interactions for adjusting thresholds
####################
# Prep for Parallelization
####################
# Create parameter combinations for parallelization
run_in_parallel <- expand.grid(n = Ns, epsilon = epsilons)
run_in_parallel <- run_in_parallel %>%
arrange(n)
################################################################################
#
# Social interaction model: Sweep epsilon and group size parameter space
#
################################################################################
rm(list = ls())
####################
# Source necessary scripts/libraries
####################
source("scripts/util/__Util__MASTER.R")
library(parallel)
library(snowfall)
####################
# Set global variables
####################
# Initial paramters: Free to change
# Base parameters
Ns             <- seq(5, 100, 5) #vector of number of individuals to simulate
m              <- 2 #number of tasks
gens           <- 50000 #number of generations to run simulation
reps           <- 100 #number of replications per simulation (for ensemble)
# Threshold Parameters
ThreshM        <- rep(50, m) #population threshold means
ThreshSD       <- ThreshM * 0 #population threshold standard deviations
InitialStim    <- rep(0, m) #intital vector of stimuli
deltas         <- rep(0.8, m) #vector of stimuli increase rates
alpha          <- m #efficiency of task performance
quitP          <- 0.2 #probability of quitting task once active
# Social Network Parameters
p              <- 0.5 #baseline probablity of initiating an interaction per time step
epsilons       <- seq(0, 0.6, 0.025) #relative weighting of social interactions for adjusting thresholds
beta           <- 1.1 #probability of interacting with individual in same state relative to others
0.6/5
epsilons       <- seq(0, 0.125, 0.025) #relative weighting of social interactions for adjusting thresholds
epsilons       <- seq(0, 0.1, 0.025) #relative weighting of social interactions for adjusting thresholds
epsilons       <- seq(0, 0.125, 0.025) #relative weighting of social interactions for adjusting thresholds
epsilons       <- seq(0.0, 0.125, 0.025) #relative weighting of social interactions for adjusting thresholds
6*0.025
epsilons       <- seq(0.15, 0.3, 0.025) #relative weighting of social interactions for adjusting thresholds
epsilons       <- seq(0.15, 0.275, 0.025) #relative weighting of social interactions for adjusting thresholds
epsilons       <- seq(0.3, 0.425, 0.05) #relative weighting of social interactions for adjusting thresholds
epsilons       <- seq(0.3, 0.425, 0.025) #relative weighting of social interactions for adjusting thresholds
0.6/5
epsilons       <- seq(0.0, 0.1, 0.025) #relative weighting of social interactions for adjusting thresholds
epsilons       <- seq(0.1, 0.175, 0.025) #relative weighting of social interactions for adjusting thresholds
epsilons       <- seq(0.0, 0.1, 0.025) #relative weighting of social interactions for adjusting thresholds
length(seq(0, 0.6, 0.0254))
length(seq(0, 0.6, 0.025))
epsilons       <- seq(0.0, 0.1, 0.025) #relative weighting of social interactions for adjusting thresholds
epsilons       <- seq(0.125, 0.12, 0.025) #relative weighting of social interactions for adjusting thresholds
epsilons       <- seq(0.125, 0.2, 0.025) #relative weighting of social interactions for adjusting thresholds
epsilons       <- seq(0.125, 0.225, 0.025) #relative weighting of social interactions for adjusting thresholds
seq(0, 0.6, 0.025)
epsilons       <- seq(0.25, 0.425, 0.025) #relative weighting of social interactions for adjusting thresholds
epsilons       <- seq(0.25, 0.35, 0.025) #relative weighting of social interactions for adjusting thresholds
epsilons       <- seq(0.375, 0.475, 0.025) #relative weighting of social interactions for adjusting thresholds
epsilons       <- seq(0.5, 0.6, 0.025) #relative weighting of social interactions for adjusting thresholds
rm(list = ls())
source("scripts/util/__Util__MASTER.R")
library(RColorBrewer)
library(scales)
load("output/Rdata/_ProcessedData/Entropy/Sigma0-Epsilon0.1-Beta1.1.Rdata")
compiled_data$Model <- "Social_Beta1.1"
entropy_data <- rbind(entropy_data, compiled_data)
rm(compiled_data)
####################
# Only beta = 1.1
####################
select_entropy <- entropy %>%
filter(beta = 1.1)
################################################################################
#
# Comparing various specialization plots
#
################################################################################
rm(list = ls())
source("scripts/util/__Util__MASTER.R")
library(RColorBrewer)
library(scales)
############### Sweep across beta values ###############
####################
# Load data
####################
load("output/Rdata/_ProcessedData/Entropy/Sigma0-Epsilon0.1-Beta1.01.Rdata")
compiled_data$Model <- "Social_Beta1.01"
entropy_data <- compiled_data
rm(compiled_data)
load("output/Rdata/_ProcessedData/Entropy/Sigma0-Epsilon0.1-Beta1.05.Rdata")
compiled_data$Model <- "Social_Beta1.05"
entropy_data <- rbind(entropy_data, compiled_data)
rm(compiled_data)
load("output/Rdata/_ProcessedData/Entropy/Sigma0-Epsilon0.1-Beta1.1.Rdata")
compiled_data$Model <- "Social_Beta1.1"
entropy_data <- rbind(entropy_data, compiled_data)
rm(compiled_data)
load("output/Rdata/_ProcessedData/Entropy/Sigma0-Epsilon0.1-Beta1.2.Rdata")
compiled_data$Model <- "Social_Beta1.2"
entropy_data <- rbind(entropy_data, compiled_data)
rm(compiled_data)
####################
# Summarise data
####################
# Calculate mean and SE
entropy <- entropy_data %>%
group_by(Model, n) %>%
summarise(Mean = mean(Dind),
SE = sd(Dind) / sqrt(length(Dind)))
####################
# Only beta = 1.1
####################
select_entropy <- entropy %>%
filter(beta = 1.1)
####################
# Only beta = 1.1
####################
select_entropy <- entropy %>%
filter(beta == 1.1)
View(entropy)
####################
# Only beta = 1.1
####################
select_entropy <- entropy %>%
filter(Model == Social_Beta1.1)
View(entropy)
####################
# Only beta = 1.1
####################
select_entropy <- entropy %>%
filter(Model == "Social_Beta1.1")
gg_solo <- ggplot(data = select_entropy, aes(x = n, colour = Model)) +
geom_line(aes(y = Mean),
size = 0.4) +
geom_errorbar(aes(ymin = Mean - SE, ymax = Mean + SE),
width = 0) +
geom_point(aes(y = Mean),
size = 1) +
theme_classic() +
ylab("Division of Labor") +
scale_x_continuous(breaks = seq(0, 100, 20)) +
scale_color_manual(values = "#636363",
name = expression("Interaction bias"(Beta))) +
theme(axis.text = element_text(colour = "black", size = 6),
axis.title = element_text(size = 7),
legend.position = "none",
legend.title = element_text(size = 7,
face = "bold"),
legend.text = element_text(size = 6),
legend.key.height = unit(4, "mm"),
legend.key.width = unit(5, "mm"),
axis.ticks = element_line(size = 0.3),
axis.line = element_line(size = 0.3),
aspect.ratio = 1)
gg_solo
ggsave(gg_solo, filename = "output/SpecializationPlots/Beta1.1.svg", width = 45, height = 45, units = "mm")
ggsave(gg_solo, filename = "output/SpecializationPlots/Beta1.1.svg", width = 60, height = 60, units = "mm")
