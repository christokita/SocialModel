scale_fill_gradientn(name = "Relative Interaction\nFrequency",
colours = c("#8a8a8a", "#ffffff", "#88419d"),
na.value = "white",
limit = c(-1, 1),
# limit = c(0.95, 1.05),
oob = squish) +
theme(axis.text = element_blank(),
axis.ticks = element_blank(),
axis.title = element_blank(),
aspect.ratio = 1,
# Hide the legend (optional)
legend.position = "none",
legend.key.height = unit(0.38, "in"),
panel.border = element_rect(size = 1.5),
panel.grid = element_blank(),
title = element_blank()) +
ggtitle(paste0("Group Size = ", groupsize))
# return graph
return(gg_avg_adj)
# return(avg_g)
})
filename <- "Sigma0.0-Epsilon0.01-Bias1.1"
multiplot(plotlist = interaction_sign_graphs, layout = matrix(c(seq(1:length(interaction_sign_graphs))), nrow=2, byrow=TRUE))
###### Fixed Sigma 05 ######
# Only color by significantly different than random
type_groups_graphs <- fix_groups_graphs_sigma05
type_groups_threshMat <- fix_groups_threshMat_sigma05
interaction_sign_graphs <- lapply(1:length(type_groups_graphs), function(i) {
# Get graphs
graphs <- type_groups_graphs[[i]]
replicates <- length(graphs)
# For each each compute interaction matrix
# Get graph and make adjacency matrix
size_graph <- lapply(1:length(graphs), function(j) {
# Format: set diagonal, rescale, and make adj matrix
this_graph <- graphs[[j]]
diag(this_graph) <- NA
thresh <- as.data.frame(type_groups_threshMat[[i]][j])
thresh$ThreshRatio <- log(thresh$Thresh1 / thresh$Thresh2)
ratio <- order(thresh$ThreshRatio)
# Create order by threshold ratio
this_graph <- this_graph[ratio, ratio]
colnames(this_graph) <- 1:nrow(this_graph)
rownames(this_graph) <- colnames(this_graph)
g <- graph.adjacency(adjmatrix = this_graph, weighted = T)
edgelist_graph <- as.data.frame(get.edgelist(g))
names(edgelist_graph) <- c("From", "To")
edgelist_graph$Weight <- E(g)$weight
edgelist_graph$Interaction <- paste0(edgelist_graph$From, "-", edgelist_graph$To)
# return
return(edgelist_graph)
})
#Calculate baseline probability of interaction
dimensions <- dim(graphs[[1]])
not_chosen <- 1 - ( 1 / (dimensions[1] - 1) )
expected_random <-  1 - not_chosen^2
# Bind
all_edgelist <- do.call("rbind", size_graph)
# Get pvalues of interaction rate relative to expected by random
nonNA_edgelist <- all_edgelist %>%
group_by(Interaction) %>%
filter(!is.na(Weight)) %>%
mutate(pvalue = t.test(x = Weight, mu = expected_random)[3])
# Get the CI for those that are significantly different and then determine if greater or less than expected
sigDiff_edgelist <- nonNA_edgelist %>%
mutate(Significant = pvalue < 0.05) %>%
filter(Significant == TRUE) %>%
group_by(Interaction) %>%
mutate(CImin = t.test(x = Weight, mu = expected_random)[[4]][1] - expected_random,
CImax = t.test(x = Weight, mu = expected_random)[[4]][1] - expected_random) %>%
mutate(DiffDirection = ifelse(test = CImin > 0 & CImax > 0, yes = 1, no = -1)) %>%
select(Interaction, DiffDirection) %>%
unique(.)
# Merge back together and then form graph
calc_edgelist <- merge(all_edgelist, sigDiff_edgelist, all = TRUE)
calc_edgelist$DiffDirection[is.na(calc_edgelist$DiffDirection) & !is.na(calc_edgelist$Weight)] <- 0
calc_edgelist <- calc_edgelist %>%
select(From, To, Interaction, DiffDirection) %>%
unique(.) %>%
mutate(From = as.numeric(as.character(From)),
To = as.numeric(as.character(To))) %>%
arrange(From, To)
avg_g <- matrix(data = calc_edgelist$DiffDirection, nrow = dimensions[1], byrow = T)
colnames(avg_g) <- paste0("t-", 1:dimensions[1])
rownames(avg_g) <- paste0("t-", 1:dimensions[1])
# Create graph object
g <- graph_from_adjacency_matrix(avg_g, mode = c("directed"), weighted = TRUE, diag = TRUE)
# Get node and edge list
node_list <- get.data.frame(g, what = "vertices")
edge_list <- get.data.frame(g, what = "edges")
# Create dataframe for plotting
plot_data <- edge_list %>% mutate(
to = factor(to, levels = rev(node_list$name)),
from = factor(from, levels = node_list$name))
# Plot
groupsize <- ncol(avg_g)
gg_avg_adj <- ggplot(plot_data, aes(x = from, y = to, fill = weight)) +
geom_raster() +
theme_bw() +
# Because we need the x and y axis to display every node,
# not just the nodes that have connections to each other,
# make sure that ggplot does not drop unused factor levels
scale_x_discrete(drop = FALSE, expand = c(0, 0)) +
scale_y_discrete(drop = FALSE, expand = c(0, 0)) +
# scale_fill_gradientn(colours = rev(brewer.pal(9,"RdYlBu")), na.value = "white", limit = c(-1.5, 1.5), oob = squish) +
scale_fill_gradientn(name = "Relative Interaction\nFrequency",
colours = c("#8a8a8a", "#ffffff", "#88419d"),
na.value = "white",
limit = c(-1, 1),
# limit = c(0.95, 1.05),
oob = squish) +
theme(axis.text = element_blank(),
axis.ticks = element_blank(),
axis.title = element_blank(),
aspect.ratio = 1,
# Hide the legend (optional)
legend.position = "none",
legend.key.height = unit(0.38, "in"),
panel.border = element_rect(size = 1.5),
panel.grid = element_blank(),
title = element_blank()) +
ggtitle(paste0("Group Size = ", groupsize))
# return graph
return(gg_avg_adj)
# return(avg_g)
})
# Plot : SIGNED interaction matrices
# png(filename = paste0("output/Networks/RawPlots/SignedIntMat_", filename, ".png"), width = 5, height = 2.5, units = "in", res = 600)
multiplot(plotlist = interaction_sign_graphs, layout = matrix(c(seq(1:length(interaction_sign_graphs))), nrow=2, byrow=TRUE))
interaction_sign_graphs <- lapply(1:length(type_groups_graphs), function(i) {
# Get graphs
graphs <- type_groups_graphs[[i]]
replicates <- length(graphs)
# For each each compute interaction matrix
# Get graph and make adjacency matrix
size_graph <- lapply(1:length(graphs), function(j) {
# Format: set diagonal, rescale, and make adj matrix
this_graph <- graphs[[j]]
diag(this_graph) <- NA
thresh <- as.data.frame(type_groups_threshMat[[i]][j])
thresh$ThreshRatio <- log(thresh$Thresh1 / thresh$Thresh2)
ratio <- order(thresh$ThreshRatio)
# Create order by threshold ratio
this_graph <- this_graph[ratio, ratio]
colnames(this_graph) <- 1:nrow(this_graph)
rownames(this_graph) <- colnames(this_graph)
g <- graph.adjacency(adjmatrix = this_graph, weighted = T)
edgelist_graph <- as.data.frame(get.edgelist(g))
names(edgelist_graph) <- c("From", "To")
edgelist_graph$Weight <- E(g)$weight
edgelist_graph$Interaction <- paste0(edgelist_graph$From, "-", edgelist_graph$To)
# return
return(edgelist_graph)
})
#Calculate baseline probability of interaction
dimensions <- dim(graphs[[1]])
not_chosen <- 1 - ( ( 1 / (dimensions[1] - 1) ) * 0.5)
expected_random <-  1 - not_chosen^2
# Bind
all_edgelist <- do.call("rbind", size_graph)
# Get pvalues of interaction rate relative to expected by random
nonNA_edgelist <- all_edgelist %>%
group_by(Interaction) %>%
filter(!is.na(Weight)) %>%
mutate(pvalue = t.test(x = Weight, mu = expected_random)[3])
# Get the CI for those that are significantly different and then determine if greater or less than expected
sigDiff_edgelist <- nonNA_edgelist %>%
mutate(Significant = pvalue < 0.05) %>%
filter(Significant == TRUE)
if (nrow(sigDiff_edgelist) > 0) {
sigDiff_edgelist <- sigDiff_edgelist %>%
group_by(Interaction) %>%
mutate(CImin = t.test(x = Weight, mu = expected_random)[[4]][1] - expected_random,
CImax = t.test(x = Weight, mu = expected_random)[[4]][1] - expected_random) %>%
mutate(DiffDirection = ifelse(test = CImin > 0 & CImax > 0, yes = 1, no = -1)) %>%
select(Interaction, DiffDirection) %>%
unique(.)
} else {
sigDiff_edgelist <- sigDiff_edgelist %>%
mutate(DiffDirection = NA) %>%
select(Interaction, DiffDirection) %>%
unique(.)
}
# Merge back together and then form graph
calc_edgelist <- merge(all_edgelist, sigDiff_edgelist, all = TRUE)
calc_edgelist$DiffDirection[is.na(calc_edgelist$DiffDirection) & !is.na(calc_edgelist$Weight)] <- 0
calc_edgelist <- calc_edgelist %>%
select(From, To, Interaction, DiffDirection) %>%
unique(.) %>%
mutate(From = as.numeric(as.character(From)),
To = as.numeric(as.character(To))) %>%
arrange(From, To)
avg_g <- matrix(data = calc_edgelist$DiffDirection, nrow = dimensions[1], byrow = T)
colnames(avg_g) <- paste0("t-", 1:dimensions[1])
rownames(avg_g) <- paste0("t-", 1:dimensions[1])
# Create graph object
g <- graph_from_adjacency_matrix(avg_g, mode = c("directed"), weighted = TRUE, diag = TRUE)
# Get node and edge list
node_list <- get.data.frame(g, what = "vertices")
edge_list <- get.data.frame(g, what = "edges")
# Create dataframe for plotting
plot_data <- edge_list %>% mutate(
to = factor(to, levels = rev(node_list$name)),
from = factor(from, levels = node_list$name))
# Plot
groupsize <- ncol(avg_g)
gg_avg_adj <- ggplot(plot_data, aes(x = from, y = to, fill = weight)) +
geom_raster() +
theme_bw() +
# Because we need the x and y axis to display every node,
# not just the nodes that have connections to each other,
# make sure that ggplot does not drop unused factor levels
scale_x_discrete(drop = FALSE, expand = c(0, 0)) +
scale_y_discrete(drop = FALSE, expand = c(0, 0)) +
# scale_fill_gradientn(colours = rev(brewer.pal(9,"RdYlBu")), na.value = "white", limit = c(-1.5, 1.5), oob = squish) +
scale_fill_gradientn(name = "Relative Interaction\nFrequency",
colours = c("#8a8a8a", "#ffffff", "#88419d"),
na.value = "white",
limit = c(-1, 1),
# limit = c(0.95, 1.05),
oob = squish) +
theme(axis.text = element_blank(),
axis.ticks = element_blank(),
axis.title = element_blank(),
aspect.ratio = 1,
# Hide the legend (optional)
legend.position = "none",
legend.key.height = unit(0.38, "in"),
panel.border = element_rect(size = 1.5),
panel.grid = element_blank(),
title = element_blank()) +
ggtitle(paste0("Group Size = ", groupsize))
# return graph
return(gg_avg_adj)
# return(avg_g)
})
multiplot(plotlist = interaction_sign_graphs, layout = matrix(c(seq(1:length(interaction_sign_graphs))), nrow=2, byrow=TRUE))
multiplot(plotlist = interaction_sign_graphs[c(2, 4, 6, 8)], layout = matrix(c(seq(1:length(interaction_sign_graphs[c(1, 2, 5, 8)]))), nrow = 1, byrow=TRUE))
multiplot(plotlist = interaction_sign_graphs[c(7)], layout = matrix(c(seq(1:length(interaction_sign_graphs[c(1, 2, 5, 8)]))), nrow = 1, byrow=TRUE))
###### Social ######
# Only color by significantly different than random
type_groups_graphs <- soc_groups_graphs
type_groups_threshMat <- soc_groups_threshMat
interaction_sign_graphs <- lapply(1:length(type_groups_graphs), function(i) {
# Get graphs
graphs <- type_groups_graphs[[i]]
replicates <- length(graphs)
# For each each compute interaction matrix
# Get graph and make adjacency matrix
size_graph <- lapply(1:length(graphs), function(j) {
# Format: set diagonal, rescale, and make adj matrix
this_graph <- graphs[[j]]
diag(this_graph) <- NA
thresh <- as.data.frame(type_groups_threshMat[[i]][j])
thresh$ThreshRatio <- log(thresh$Thresh1 / thresh$Thresh2)
ratio <- order(thresh$ThreshRatio)
# Create order by threshold ratio
this_graph <- this_graph[ratio, ratio]
colnames(this_graph) <- 1:nrow(this_graph)
rownames(this_graph) <- colnames(this_graph)
g <- graph.adjacency(adjmatrix = this_graph, weighted = T)
edgelist_graph <- as.data.frame(get.edgelist(g))
names(edgelist_graph) <- c("From", "To")
edgelist_graph$Weight <- E(g)$weight
edgelist_graph$Interaction <- paste0(edgelist_graph$From, "-", edgelist_graph$To)
# return
return(edgelist_graph)
})
#Calculate baseline probability of interaction
dimensions <- dim(graphs[[1]])
not_chosen <- 1 - ( ( 1 / (dimensions[1] - 1) ) * 0.5)
expected_random <-  1 - not_chosen^2
# Bind
all_edgelist <- do.call("rbind", size_graph)
# Get pvalues of interaction rate relative to expected by random
nonNA_edgelist <- all_edgelist %>%
group_by(Interaction) %>%
filter(!is.na(Weight)) %>%
mutate(pvalue = t.test(x = Weight, mu = expected_random)[3])
# Get the CI for those that are significantly different and then determine if greater or less than expected
sigDiff_edgelist <- nonNA_edgelist %>%
mutate(Significant = pvalue < 0.05) %>%
filter(Significant == TRUE)
if (nrow(sigDiff_edgelist) > 0) {
sigDiff_edgelist <- sigDiff_edgelist %>%
group_by(Interaction) %>%
mutate(CImin = t.test(x = Weight, mu = expected_random)[[4]][1] - expected_random,
CImax = t.test(x = Weight, mu = expected_random)[[4]][1] - expected_random) %>%
mutate(DiffDirection = ifelse(test = CImin > 0 & CImax > 0, yes = 1, no = -1)) %>%
select(Interaction, DiffDirection) %>%
unique(.)
} else {
sigDiff_edgelist <- sigDiff_edgelist %>%
mutate(DiffDirection = NA) %>%
select(Interaction, DiffDirection) %>%
unique(.)
}
# Merge back together and then form graph
calc_edgelist <- merge(all_edgelist, sigDiff_edgelist, all = TRUE)
calc_edgelist$DiffDirection[is.na(calc_edgelist$DiffDirection) & !is.na(calc_edgelist$Weight)] <- 0
calc_edgelist <- calc_edgelist %>%
select(From, To, Interaction, DiffDirection) %>%
unique(.) %>%
mutate(From = as.numeric(as.character(From)),
To = as.numeric(as.character(To))) %>%
arrange(From, To)
avg_g <- matrix(data = calc_edgelist$DiffDirection, nrow = dimensions[1], byrow = T)
colnames(avg_g) <- paste0("t-", 1:dimensions[1])
rownames(avg_g) <- paste0("t-", 1:dimensions[1])
# Create graph object
g <- graph_from_adjacency_matrix(avg_g, mode = c("directed"), weighted = TRUE, diag = TRUE)
# Get node and edge list
node_list <- get.data.frame(g, what = "vertices")
edge_list <- get.data.frame(g, what = "edges")
# Create dataframe for plotting
plot_data <- edge_list %>% mutate(
to = factor(to, levels = rev(node_list$name)),
from = factor(from, levels = node_list$name))
# Plot
groupsize <- ncol(avg_g)
gg_avg_adj <- ggplot(plot_data, aes(x = from, y = to, fill = weight)) +
geom_raster() +
theme_bw() +
# Because we need the x and y axis to display every node,
# not just the nodes that have connections to each other,
# make sure that ggplot does not drop unused factor levels
scale_x_discrete(drop = FALSE, expand = c(0, 0)) +
scale_y_discrete(drop = FALSE, expand = c(0, 0)) +
# scale_fill_gradientn(colours = rev(brewer.pal(9,"RdYlBu")), na.value = "white", limit = c(-1.5, 1.5), oob = squish) +
scale_fill_gradientn(name = "Relative Interaction\nFrequency",
colours = c("#8a8a8a", "#ffffff", "#88419d"),
na.value = "white",
limit = c(-1, 1),
# limit = c(0.95, 1.05),
oob = squish) +
theme(axis.text = element_blank(),
axis.ticks = element_blank(),
axis.title = element_blank(),
aspect.ratio = 1,
# Hide the legend (optional)
legend.position = "none",
legend.key.height = unit(0.38, "in"),
panel.border = element_rect(size = 1.5),
panel.grid = element_blank(),
title = element_blank()) +
ggtitle(paste0("Group Size = ", groupsize))
# return graph
return(gg_avg_adj)
# return(avg_g)
})
multiplot(plotlist = interaction_sign_graphs[c(7)], layout = matrix(c(seq(1:length(interaction_sign_graphs[c(1, 2, 5, 8)]))), nrow = 1, byrow=TRUE))
####################
# Load data
####################
# Load social
load("output/Rdata/Sigma0.0-Epsilon0.01-Bias1.1.Rdata")
soc_groups_graphs <- groups_graphs
soc_groups_threshMat <- groups_thresh
soc_graphs <- unlist(groups_graphs, recursive = FALSE)
soc_threshMat <- unlist(groups_thresh, recursive = FALSE)
soc_actMat <- unlist(groups_taskDist, recursive = FALSE)
social_graphs <- lapply(1:length(soc_graphs), function(i) {
# Calculated degree
degree <- rowSums(soc_graphs[[i]])
degree <- as.data.frame(degree)
degree$Id <- row.names(degree)
# Calculate thresholds
thresh <- soc_threshMat[[i]] %>%
as.data.frame(.) %>%
mutate(ThreshRatio = log(Thresh1 / Thresh2),
Id = row.names(.)) %>%
mutate(ThreshRatioRaw = ThreshRatio)
thresh$ThreshRatio[thresh$ThreshRatio > ThreshCutoffValue] <- ThreshCutoffReplacement
thresh$ThreshRatio[thresh$ThreshRatio < -ThreshCutoffValue] <- -ThreshCutoffReplacement
thresh$ThreshRatioColor <- thresh$ThreshRatio
thresh$ThreshRatioColor[thresh$ThreshRatio > ThreshCutoffValue] <- ThreshCutoffReplacementColor
thresh$ThreshRatioColor[thresh$ThreshRatio < -ThreshCutoffValue] <- -ThreshCutoffReplacementColor
# Calculate actibity
activity <- soc_actMat[[i]] %>%
as.data.frame(.) %>%
mutate(ActRatio = log(Task1 / Task2),
ActTotal = Task1 + Task2,
Id = row.names(.))
# Merge and return
mergedNodes <- merge(degree, thresh)
mergedNodes <- merge(mergedNodes, activity)
return(mergedNodes)
})
social_graphs <- do.call("rbind", social_graphs)
# Load fixed
load("output/Rdata/Sigma0.05-FIXED-Bias1.1.Rdata")
fix_groups_graphs <- groups_graphs
fix_groups_threshMat <- groups_thresh
fix_graphs <- unlist(groups_graphs, recursive = FALSE)
fix_threshMat <- unlist(groups_thresh, recursive = FALSE)
fix_actMat <- unlist(groups_taskDist, recursive = FALSE)
###### Network "dispersion" (? - standard deviation over mean degree) ######
soc_dispersion <- lapply(soc_graphs, function(graph) {
# Group size
n <- nrow(graph)
# Degrees
degrees <- rowSums(graph)
deg_mean <- mean(degrees)
deg_sd <- sd(degrees)
# compile and return
to_return <- data.frame(n = n, DegreeMean = deg_mean, DegreeSD = deg_sd)
})
dispersion <- do.call("rbind", soc_dispersion)
dispersion <- dispersion %>%
mutate(Dispersion = DegreeSD / DegreeMean)
dispersionSummary <- dispersion %>%
mutate(Model = "Social") %>%
group_by(n, Model) %>%
summarise(Dispersion = mean(Dispersion),
DegreeMean = mean(DegreeMean),
DegreeSD = mean(DegreeSD))
fixed_dispersion <- lapply(fix_graphs, function(graph) {
# Group size
n <- nrow(graph)
# Degrees
degrees <- rowSums(graph)
deg_mean <- mean(degrees)
deg_sd <- sd(degrees)
# compile and return
to_return <- data.frame(n = n, DegreeMean = deg_mean, DegreeSD = deg_sd)
})
fixed_dispersion <- do.call("rbind", fixed_dispersion)
fixed_dispersion <- fixed_dispersion %>%
mutate(Dispersion = DegreeSD / DegreeMean)
fixed_dispersionSummary <- fixed_dispersion %>%
mutate(Model = "Fixed") %>%
group_by(n, Model) %>%
summarise(Dispersion = mean(Dispersion),
DegreeMean = mean(DegreeMean),
DegreeSD = mean(DegreeSD))
dispersionSummary <- rbind(dispersionSummary, fixed_dispersionSummary)
rm(fixed_dispersion, fixed_dispersionSummary)
gg_dispersion <- ggplot(data = dispersionSummary, aes(x = n, y = Dispersion, group = Model, color = Model)) +
geom_line(aes(linetype = Model)) +
geom_point(size = 2) +
theme_classic(base_size = 10) +
scale_color_manual(values = c("black", "mediumseagreen")) +
scale_linetype_manual(values = c("dashed", "solid")) +
theme(aspect.ratio = 1,
axis.text = element_text(color = "black"))
gg_dispersion
###### Network homophily ######
weighted_ratios <- lapply(1:length(soc_graphs), function(i) {
# Social
# Get graph and thresh matrix for simulation
graph <- soc_graphs[[i]]
thresh <- as.data.frame(soc_threshMat[[i]])
# Calculate thresh ratio
threshRatio <- log(thresh$Thresh1 / thresh$Thresh2)
# Calculate weighted neighbor sum for each individual
weighted_sum <- graph %*% threshRatio
# Calculate weighted neighbor sum for each individual
strength <- rowSums(graph)
disparity <- rowSums((graph / strength)^2)
# Construct dataframe to return
to_return <- data.frame(Id = row.names(weighted_sum),
n = length(weighted_sum),
ThreshRatio = threshRatio,
WeightNeighbor = weighted_sum,
Disparity = disparity,
Model = "Social")
row.names(to_return) <- NULL
# Fixed
# Get graph and thresh matrix for simulation
graph <- fix_graphs[[i]]
thresh <- as.data.frame(fix_threshMat[[i]])
# Calculate thresh ratio
threshRatio <- log(thresh$Thresh1 / thresh$Thresh2)
# Calculate weighted neighbor sum for each individual
weighted_sum <- graph %*% threshRatio
# Calculate weighted neighbor sum for each individual
strength <- rowSums(graph)
disparity <- rowSums((graph / strength)^2)
# Construct dataframe to return
to_return2 <- data.frame(Id = row.names(weighted_sum),
n = length(weighted_sum),
ThreshRatio = threshRatio,
WeightNeighbor = weighted_sum,
Disparity = disparity,
Model = "Fixed")
row.names(to_return) <- NULL
# Return
to_return$Model <- as.character(to_return$Model)
to_return <- rbind(to_return, to_return2)
return(to_return)
})
weighted_ratios <- do.call("rbind", weighted_ratios)
test <- weighted_ratios %>% filter(Model == "Social")
gg_weighted_ratios <- ggplot(data = test, aes(x = ThreshRatio, y = WeightNeighbor)) +
geom_point() +
theme_classic(base_size = 10) +
theme(aspect.ratio = 1,
axis.text = element_text(color = "black"))  +
facet_wrap(~n, scales = "free_y")
gg_weighted_ratios
weighted_summary <- weighted_ratios %>%
group_by(n, Model) %>%
summarise(CorrelationThresholds = cor(ThreshRatio, WeightNeighbor))
gg_weighted_corr <- ggplot(data = weighted_summary, aes(x = n, y = CorrelationThresholds, group = Model, color = Model)) +
geom_line(aes(linetype = Model)) +
geom_point(size = 2) +
theme_classic(base_size = 10) +
scale_color_manual(values = c("black", "mediumseagreen")) +
scale_linetype_manual(values = c("dashed", "solid")) +
theme(aspect.ratio = 1,
axis.text = element_text(color = "black"))
gg_weighted_corr
