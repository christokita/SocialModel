completed_runs$D <- as.numeric(gsub(x = files, "^Delta([\\.0-9]+)-.*$", "\\1", perl = T))
completed_runs$S <- as.numeric(gsub(x = files, "^.*-Sigma([\\.0-9]+)-.*$", "\\1", perl = T))
parameter_values <- anti_join(parameter_values, completed_runs, by = c("n", "D", "S"))
rm(list = ls())
####################
# Source necessary scripts/libraries
####################
source("scripts/util/__Util__MASTER.R")
library(parallel)
library(snowfall)
####################
# Set global variables
####################
# Initial paramters: Free to change
# Base parameters
Ns             <- seq(5, 100, 5) #vector of number of individuals to simulate
m              <- 2 #number of tasks
gens           <- 50000 #number of generations to run simulation
reps           <- 100 #number of replications per simulation (for ensemble)
# Threshold Parameters
ThreshM        <- rep(50, m) #population threshold means
InitialStim    <- rep(0, m) #intital vector of stimuli
Sigmas         <- c(0.01, 0.025, 0.05, 0.075, 0.1, 0.15, 0.25, 0.5)
delta_values   <- seq(0.5, 0.8, 0.1) #vector of stimuli increase rates
alpha          <- m #efficiency of task performance
quitP          <- 0.2 #probability of quitting task once active
# Social Network Parameters
p              <- 1 #baseline probablity of initiating an interaction per time step
epsilon        <- 0 #relative weighting of social interactions for adjusting thresholds
beta           <- 1.1 #probability of interacting with individual in same state relative to others
####################
# Prep for Parallelization
####################
# Create directory for depositing data
# storage_path <- "/scratch/gpfs/ctokita/"
# dir_name <-"FixedThreshold-SigmaDeltaSweep"
storage_path <- "output/"
dir_name <-"FixedThreshold-SigmaDeltaSweep/Rdata/"
full_path <- paste0(storage_path, dir_name, "/")
dir.create(full_path, showWarnings = FALSE)
# Prepare table for values to be iterated over
parameter_values <- expand.grid(n = Ns, D = delta_values, S = Sigmas)
# Check if file already exists
files <- list.files(full_path)
completed_runs <- data.frame(n = as.numeric(gsub(x = files, "^.*-n([0-9]+)\\.Rdata$", "\\1", perl = T)))
completed_runs$D <- as.numeric(gsub(x = files, "^Delta([\\.0-9]+)-.*$", "\\1", perl = T))
completed_runs$S <- as.numeric(gsub(x = files, "^.*-Sigma([\\.0-9]+)-.*$", "\\1", perl = T))
parameter_values <- anti_join(parameter_values, completed_runs, by = c("n", "D", "S"))
View(parameter_values)
parameter_values_noN <- parameter_values %>%
select(D, S) %>%
unique()
View(parameter_values_noN)
# Prepare table for values to be iterated over
parameter_values <- expand.grid(n = Ns, D = delta_values, S = Sigmas)
# Check if file already exists
files <- list.files(full_path)
completed_runs <- data.frame(n = as.numeric(gsub(x = files, "^.*-n([0-9]+)\\.Rdata$", "\\1", perl = T)))
completed_runs$D <- as.numeric(gsub(x = files, "^Delta([\\.0-9]+)-.*$", "\\1", perl = T))
completed_runs$S <- as.numeric(gsub(x = files, "^.*-Sigma([\\.0-9]+)-.*$", "\\1", perl = T))
parameter_values_withN <- anti_join(parameter_values, completed_runs, by = c("n", "D", "S"))
parameter_values <- parameter_values_withN %>%
select(D, S) %>%
unique()
k = 1
# Set threshold variation
ThreshSD <- ThreshM * parameter_values[k, "S"]
# Set deltas
deltas <- rep(parameter_values[k, "D"], m)
ThreshSD
deltas
View(parameter_values_noN)
# Set group sizes needed for that parameter combo
Ns <- unique(parameter_values_withN$n[parameter_values_withN$D == deltas[1] & parameter_values_withN$S == ThreshSD[1]])
Ns
View(parameter_values_withN)
# Set group sizes needed for that parameter combo
Ns <- unique(parameter_values_withN$n[parameter_values_withN$D == parameter_values[k, "S"] & parameter_values_withN$S == parameter_values[k, "D"])
# LOOP 2: loop through group sizes
for (i in 1:length(Ns)) {
# Set group size
n <- Ns[i]
# Prep lists for collection of simulation outputs from this group size
ens_taskDist    <- list()
ens_entropy     <- list()
ens_thresh      <- list()
ens_graphs      <- list()
# LOOP 3: Loop through replicates
for (sim in 1:reps) {
####################
# Seed structures and intial matrices
####################
# Set initial probability matrix (P_g)
P_g <- matrix(data = rep(0, n * m), ncol = m)
# Seed task (external) stimuli
stimMat <- seed_stimuls(intitial_stim = InitialStim,
gens = gens)
# Seed internal thresholds
threshMat <- seed_thresholds(n = n,
m = m,
threshold_means = ThreshM,
threshold_sds = ThreshSD)
# Start task performance
X_g <- matrix(data = rep(0, length(P_g)), ncol = ncol(P_g))
# Create cumulative task performance matrix
X_tot <- X_g
# Create cumulative adjacency matrix
g_tot <-  matrix(data = rep(0, n * n), ncol = n)
colnames(g_tot) <- paste0("v-", 1:n)
rownames(g_tot) <- paste0("v-", 1:n)
####################
# Simulate individual run
####################
# Run simulation
for (t in 1:gens) {
# Current timestep is actually t+1 in this formulation, because first row is timestep 0
# Update stimuli
stimMat <- update_stim(stim_matrix = stimMat,
deltas = deltas,
alpha = alpha,
state_matrix = X_g,
time_step = t)
# Calculate task demand based on global stimuli
P_g <- calc_determ_thresh(time_step        = t + 1, # first row is generation 0
threshold_matrix = threshMat,
stimulus_matrix  = stimMat)
# Update task performance
X_g <- update_task_performance(task_probs   = P_g,
state_matrix = X_g,
quit_prob    = quitP)
# Update social network (previously this was before probability/task update)
g_adj <- temporalNetwork(X_sub_g = X_g,
prob_interact = p,
bias = beta)
g_tot <- g_tot + g_adj
# Adjust thresholds
threshMat <- adjust_thresholds_social_capped(social_network = g_adj,
threshold_matrix = threshMat,
state_matrix = X_g,
epsilon = epsilon,
threshold_max = 100)
# Update total task performance profile
X_tot <- X_tot + X_g
}
####################
# Post run calculations
####################
# Calculate Entropy
entropy <- as.data.frame(mutualEntropy(TotalStateMat = X_tot))
entropy$n <- n
entropy$replicate <- sim
entropy$sigma <- ThreshSD[1] / ThreshM[1]
entropy$delta <- deltas[1]
# Calculate total task distribution
total_task_dist <- as.data.frame(X_tot / gens)
total_task_dist$n <- n
total_task_dist$replicate <- sim
total_task_dist$sigma <- ThreshSD[1] / ThreshM[1]
total_task_dist$delta <- deltas[1]
# Add total task distributions, entropy values, and graphs to lists
ens_taskDist[[sim]]    <- total_task_dist
ens_entropy[[sim]]     <- entropy
}
# Bind and save
task_distributions <- do.call("rbind", ens_taskDist)
entropies <- do.call("rbind", ens_entropy)
save(task_distributions, entropies, file = paste0(full_path, "Delta", deltas[1],
"-Sigma", ThreshSD[1]/ThreshM[1],
"-n", n, ".Rdata"))
# Return all_clear
rm(ens_taskDist, ens_entropy)
Sys.sleep(1)
}
})
sfStop()
# Set group sizes needed for that parameter combo
Ns <- unique(parameter_values_withN$n[parameter_values_withN$D == parameter_values[k, "S"] & parameter_values_withN$S == parameter_values[k, "D"]])
parameter_values_withN$n
parameter_values_withN$D == parameter_values[k, "S"]
parameter_values[k, "S"]
View(parameter_values_noN)
View(parameter_values_withN)
# Set group sizes needed for that parameter combo
Ns <- unique(parameter_values_withN$n[parameter_values_withN$D == parameter_values[k, "D"] & parameter_values_withN$S == parameter_values[k, "S"]])
View(parameter_values_withN)
View(parameter_values_noN)
k = 3
# Set threshold variation
ThreshSD <- ThreshM * parameter_values[k, "S"]
# Set deltas
deltas <- rep(parameter_values[k, "D"], m)
# Set group sizes needed for that parameter combo
Ns <- unique(parameter_values_withN$n[parameter_values_withN$D == parameter_values[k, "D"] & parameter_values_withN$S == parameter_values[k, "S"]])
rm(list = ls())
source("scripts/util/__Util__MASTER.R")
####################
# Load and bind data
####################
files <- list.files("output/FixedThreshold-SigmaDeltaSweep/Rdata/", pattern = ".Rdata", full.names = T)
for (file in files) {
load(file)
if (!exists("entropy")) {
entropy <- entropies
} else {
entropy <- rbind(entropy, entropies)
}
}
####################
# Summarise
####################
entropy_total <- entropy %>%
mutate(sigma = as.factor(sigma)) %>%
group_by(sigma, delta, n) %>%
summarise(Mean = mean(Dind),
SE = sd(Dind) / sqrt(length(Dind)),
test = length(Dind))
entropy_total$delta_label <- factor(entropy_total$delta,
levels = c(0.5, 0.6, 0.7, 0.8),
labels = c(expression(paste(delta, "=", 0.5)),
expression(paste(delta, "=", 0.6)),
expression(paste(delta, "=", 0.7)),
expression(paste(delta, "=", 0.8))))
###################
# Plot
####################
library(RColorBrewer)
library(scales)
pal <- brewer.pal(9, "BuPu")[4:9]
# Line plots
gg_deltas <- ggplot(data = entropy_total, aes(x = n, y = Mean, colour = sigma, group = sigma)) +
geom_line(size = 0.2) +
geom_errorbar(aes(ymax = Mean + SE, ymin = Mean - SE), size = 0.2, width = 0) +
geom_point(size = 0.6) +
scale_y_continuous(limits = c(0, 1)) +
# scale_color_gradient(low = "#9ebcda", high = "#4d004b", limit = c(0, 0.15), breaks = seq(0, 0.15, 0.05)) +
# scale_color_manual(name = expression(paste("Threshold\nvariation (", sigma, ")")),
#                    values = pal) +
xlab("Group size (n)") +
ylab(expression(paste("Division of labor (", 'D'[indiv], ")"))) +
facet_grid(~delta_label, labeller = label_parsed) +
theme_ctokita()
gg_deltas
# heat map
entropy_map <- entropy_total %>%
mutate(n = factor(n, levels = unique(entropy_total$n))) %>%
filter(delta == 0.8)
pal <- brewer_pal("seq", "Greys")
pal <- pal(9)
pal <- c("#f0f0f0", "#252525")
gg_deltamap <- ggplot(data = entropy_map, aes(x = n, y = sigma, fill = Mean, colour = Mean)) +
geom_tile() +
scale_fill_gradientn(colours = pal, name = expression(paste("Division of\nlabor (", 'D'[indiv], ")")),
limits = c(0, 0.5)) +
scale_colour_gradientn(colours = pal,expression(paste("Division of\nlabor (", 'D'[indiv], ")")),
limits = c(0, 0.5)) +
xlab("Group size (n)") +
scale_x_discrete(breaks = c(5, seq(10, 100, 10))) +
ylab(expression(paste("Threshold variation (", sigma[j], ")"))) +
# facet_grid(~delta, labeller = label_parsed) +
theme_ctokita() +
theme(aspect.ratio = 1)
gg_deltamap
pal <- brewer_pal("seq", "BuPu")
pal <- pal(9)
gg_deltamap <- ggplot(data = entropy_map, aes(x = n, y = sigma, fill = Mean, colour = Mean)) +
geom_tile() +
scale_fill_gradientn(colours = pal, name = expression(paste("Division of\nlabor (", 'D'[indiv], ")")),
limits = c(0, 0.5)) +
scale_colour_gradientn(colours = pal,expression(paste("Division of\nlabor (", 'D'[indiv], ")")),
limits = c(0, 0.5)) +
xlab("Group size (n)") +
scale_x_discrete(breaks = c(5, seq(10, 100, 10))) +
ylab(expression(paste("Threshold variation (", sigma[j], ")"))) +
# facet_grid(~delta, labeller = label_parsed) +
theme_ctokita() +
theme(aspect.ratio = 1)
gg_deltamap
# Line plots
gg_deltas <- ggplot(data = entropy_total, aes(x = n, y = Mean, colour = sigma, group = sigma)) +
geom_line(size = 0.2) +
geom_errorbar(aes(ymax = Mean + SE, ymin = Mean - SE), size = 0.2, width = 0) +
geom_point(size = 0.6) +
scale_y_continuous(limits = c(0, 1)) +
# scale_color_gradient(low = "#9ebcda", high = "#4d004b", limit = c(0, 0.15), breaks = seq(0, 0.15, 0.05)) +
# scale_color_manual(name = expression(paste("Threshold\nvariation (", sigma, ")")),
#                    values = pal) +
xlab("Group size (n)") +
ylab(expression(paste("Division of labor (", 'D'[indiv], ")"))) +
facet_grid(~delta_label, labeller = label_parsed) +
theme_ctokita()
gg_deltas
pal <- brewer_pal("seq", "Blues")
pal <- pal(9)
gg_deltamap <- ggplot(data = entropy_map, aes(x = n, y = sigma, fill = Mean, colour = Mean)) +
geom_tile() +
scale_fill_gradientn(colours = pal, name = expression(paste("Division of\nlabor (", 'D'[indiv], ")")),
limits = c(0, 0.5)) +
scale_colour_gradientn(colours = pal,expression(paste("Division of\nlabor (", 'D'[indiv], ")")),
limits = c(0, 0.5)) +
xlab("Group size (n)") +
scale_x_discrete(breaks = c(5, seq(10, 100, 10))) +
ylab(expression(paste("Threshold variation (", sigma[j], ")"))) +
# facet_grid(~delta, labeller = label_parsed) +
theme_ctokita() +
theme(aspect.ratio = 1)
gg_deltamap
ggsave(gg_deltamap, filename = "output/FixedThreshold-SigmaDeltaSweep/FixedThresholdDeltaSigma_HeatMap.svg",
width = 55, height = 45, units = "mm", dpi = 400)
gg_deltamap <- ggplot(data = entropy_map, aes(x = n, y = sigma, fill = Mean, colour = Mean)) +
geom_tile() +
scale_fill_gradientn(colours = pal, name = expression(paste("Division of\nlabor (", 'D'[indiv], ")")),
limits = c(0, 0.5)) +
scale_colour_gradientn(colours = pal,expression(paste("Division of\nlabor (", 'D'[indiv], ")")),
limits = c(0, 0.5)) +
xlab("Group size (n)") +
scale_x_discrete(breaks = c(5, seq(20, 100, 20))) +
ylab(expression(paste("Threshold variation (", sigma[j], ")"))) +
# facet_grid(~delta, labeller = label_parsed) +
theme_ctokita() +
theme(aspect.ratio = 1)
gg_deltamap
ggsave(gg_deltamap, filename = "output/FixedThreshold-SigmaDeltaSweep/FixedThresholdDeltaSigma_HeatMap.svg",
width = 55, height = 45, units = "mm", dpi = 400)
ggsave(gg_deltamap, filename = "output/FixedThreshold-SigmaDeltaSweep/FixedThresholdDeltaSigma_HeatMap.svg",
height = 45, units = "mm", dpi = 400)
gg_deltamap <- ggplot(data = entropy_map, aes(x = n, y = sigma, fill = Mean, colour = Mean)) +
geom_tile() +
scale_fill_gradientn(colours = pal, name = expression(paste("Division of\nlabor (", 'D'[indiv], ")")),
limits = c(0, 0.5)) +
scale_colour_gradientn(colours = pal,expression(paste("Division of\nlabor (", 'D'[indiv], ")")),
limits = c(0, 0.5)) +
xlab("Group size (n)") +
scale_x_discrete(breaks = c(5, seq(20, 100, 20))) +
ylab(expression(paste("Threshold variation (", sigma, ")"))) +
# facet_grid(~delta, labeller = label_parsed) +
theme_ctokita() +
theme(aspect.ratio = 1)
gg_deltamap
ggsave(gg_deltamap, filename = "output/FixedThreshold-SigmaDeltaSweep/FixedThresholdDeltaSigma_HeatMap.svg",
height = 45, units = "mm", dpi = 400)
source('~/Documents/Research/Tarnita Lab/Social Interaction DOL/SocialModel/scripts/2b_Process_ClusterSimData.R', echo=TRUE)
####################
# Load and process data
####################
load('output/Rdata/_ProcessedData/Entropy/Sigma0-Beta1.1_EpsSweep-HighThreshLimit.Rdata')
high_thresh <- compiled_data %>%
mutate(Model = "high_thresh") %>%
group_by(Model, epsilon, beta) %>%
summarise(Mean = mean(Dind),
SD = sd(Dind)) %>%
as.data.frame()
load("output/ParameterSpace/EpsilonBetaSweep-n80.Rdata")
normal_thresh <- entropy %>%
mutate(Model = "normal_thresh") %>%
filter(beta == 1.1) %>%
select(Model, epsilon, beta, Dind_mean, Dind_SD)
names(normal_thresh) <- c("Model", "epsilon", "beta", "Mean", "SD")
eps_values <- unique(normal_thresh$epsilon)
entropy_data <- rbind(high_thresh, normal_thresh)
entropy_data <- entropy_data %>%
filter(epsilon %in% eps_values)
####################
# Plot entropy plots
####################
gg_comp <- ggplot(entropy_data, aes(x = epsilon, y = Mean, group = Model, color = Model)) +
geom_errorbar(aes(ymin = ifelse((Mean - SD) > 0, Mean - SD, 0), ymax = Mean + SD),
width = 0,
size = 0.3) +
geom_point(aes(y = Mean),
size = 0.8) +
theme_classic() +
xlab(expression(paste("Group Size (", italic(n), ")"))) +
ylab(expression(paste("Division of labor (", italic(D[indiv]), ")"))) +
scale_color_manual(name = "Thresh. limits",
values = c("#a6cee3", "#1f78b4"),
labels = c("[0, 1,000]", "[0, 100]")) +
# ggtitle(expression(paste(italic(epsilon), "= 0.4, ", italic(beta), "= 1.1"))) +
scale_x_continuous(breaks = seq(0, 0.6, 0.1)) +
theme(title = element_text(size = 6),
axis.text = element_text(colour = "black", size = 6),
axis.title = element_text(size = 7, face = "italic"),
legend.position = c(0.3, 0.2),
legend.title = element_text(size = 6,
face = "bold",
hjust = 5),
legend.text = element_text(size = 6),
legend.key.height = unit(2, "mm"),
legend.key.width = unit(3, "mm"),
legend.background = element_blank(),
axis.ticks = element_line(size = 0.3, color = "black"),
axis.line = element_line(size = 0.3, color = "black"),
aspect.ratio = 1)
gg_comp
ggsave(gg_comp, file = "output/SpecializationPlots/ThresholdLimitComparison.svg", height = 45, width = 45, units = "mm")
ggsave(gg_comp, file = "output/SpecializationPlots/ThresholdLimitComparison.png", height = 45, width = 45, units = "mm")
load("output/ParameterSpace/EpsilonBetaSweep-n80.Rdata")
normal_thresh <- entropy %>%
mutate(Model = "normal_thresh") %>%
filter(beta == 1.1) %>%
select(Model, epsilon, beta, Dind_mean, Dind_SD)
names(normal_thresh) <- c("Model", "epsilon", "beta", "Mean", "SD")
eps_values <- unique(normal_thresh$epsilon)
entropy_data <- rbind(high_thresh, normal_thresh)
####################
# Plot entropy plots
####################
gg_comp <- ggplot(entropy_data, aes(x = epsilon, y = Mean, group = Model, color = Model)) +
geom_errorbar(aes(ymin = ifelse((Mean - SD) > 0, Mean - SD, 0), ymax = Mean + SD),
width = 0,
size = 0.3) +
geom_point(aes(y = Mean),
size = 0.8) +
theme_classic() +
xlab(expression(paste("Group Size (", italic(n), ")"))) +
ylab(expression(paste("Division of labor (", italic(D[indiv]), ")"))) +
scale_color_manual(name = "Thresh. limits",
values = c("#a6cee3", "#1f78b4"),
labels = c("[0, 1,000]", "[0, 100]")) +
# ggtitle(expression(paste(italic(epsilon), "= 0.4, ", italic(beta), "= 1.1"))) +
scale_x_continuous(breaks = seq(0, 0.6, 0.1)) +
theme(title = element_text(size = 6),
axis.text = element_text(colour = "black", size = 6),
axis.title = element_text(size = 7, face = "italic"),
legend.position = c(0.3, 0.2),
legend.title = element_text(size = 6,
face = "bold",
hjust = 5),
legend.text = element_text(size = 6),
legend.key.height = unit(2, "mm"),
legend.key.width = unit(3, "mm"),
legend.background = element_blank(),
axis.ticks = element_line(size = 0.3, color = "black"),
axis.line = element_line(size = 0.3, color = "black"),
aspect.ratio = 1)
gg_comp
# ------------------------------ DOL by epsilon----------------------
####################
# Load and process data
####################
load('output/Rdata/_ProcessedData/Entropy/Sigma0-Beta1.1_EpsSweep-HighThreshLimit.Rdata')
high_thresh <- compiled_data %>%
mutate(Model = "high_thresh") %>%
group_by(Model, epsilon, beta) %>%
summarise(Mean = mean(Dind),
SD = sd(Dind)) %>%
as.data.frame()
load("output/ParameterSpace/EpsilonBetaSweep-n80.Rdata")
normal_thresh <- entropy %>%
mutate(Model = "normal_thresh") %>%
filter(beta == 1.1) %>%
select(Model, epsilon, beta, Dind_mean, Dind_SD)
names(normal_thresh) <- c("Model", "epsilon", "beta", "Mean", "SD")
eps_values <- unique(normal_thresh$epsilon)
entropy_data <- rbind(high_thresh, normal_thresh)
eps_values
View(high_thresh)
entropy_data <- entropy_data %>%
filter(epsilon %in% eps_values)
View(entropy_data)
View(high_thresh)
high_thresh <- compiled_data %>%
mutate(Model = "high_thresh") %>%
group_by(Model, epsilon, beta) %>%
summarise(Mean = mean(Dind),
SD = sd(Dind)) %>%
as.data.frame() %>%
mutate(epsilon = round(epsilon, digits = 3))
load("output/ParameterSpace/EpsilonBetaSweep-n80.Rdata")
normal_thresh <- entropy %>%
mutate(Model = "normal_thresh") %>%
filter(beta == 1.1) %>%
select(Model, epsilon, beta, Dind_mean, Dind_SD)
names(normal_thresh) <- c("Model", "epsilon", "beta", "Mean", "SD")
eps_values <- unique(normal_thresh$epsilon)
entropy_data <- rbind(high_thresh, normal_thresh)
entropy_data <- entropy_data %>%
filter(epsilon %in% eps_values)
View(entropy_data)
####################
# Plot entropy plots
####################
gg_comp <- ggplot(entropy_data, aes(x = epsilon, y = Mean, group = Model, color = Model)) +
geom_errorbar(aes(ymin = ifelse((Mean - SD) > 0, Mean - SD, 0), ymax = Mean + SD),
width = 0,
size = 0.3) +
geom_point(aes(y = Mean),
size = 0.8) +
theme_classic() +
xlab(expression(paste("Group Size (", italic(n), ")"))) +
ylab(expression(paste("Division of labor (", italic(D[indiv]), ")"))) +
scale_color_manual(name = "Thresh. limits",
values = c("#a6cee3", "#1f78b4"),
labels = c("[0, 1,000]", "[0, 100]")) +
# ggtitle(expression(paste(italic(epsilon), "= 0.4, ", italic(beta), "= 1.1"))) +
scale_x_continuous(breaks = seq(0, 0.6, 0.1)) +
theme(title = element_text(size = 6),
axis.text = element_text(colour = "black", size = 6),
axis.title = element_text(size = 7, face = "italic"),
legend.position = c(0.3, 0.2),
legend.title = element_text(size = 6,
face = "bold",
hjust = 5),
legend.text = element_text(size = 6),
legend.key.height = unit(2, "mm"),
legend.key.width = unit(3, "mm"),
legend.background = element_blank(),
axis.ticks = element_line(size = 0.3, color = "black"),
axis.line = element_line(size = 0.3, color = "black"),
aspect.ratio = 1)
gg_comp
ggsave(gg_comp, file = "output/SpecializationPlots/ThresholdLimitComparison.png", height = 45, width = 45, units = "mm")
ggsave(gg_comp, file = "output/SpecializationPlots/ThresholdLimitComparison.svg", height = 45, width = 45, units = "mm")
