entropy <- mutualEntropy(TotalStateMat = X_tot)
entropy <- transform(entropy, n = n, replicate = sim)
# Calculate total task distribution
# totalTaskDist <- X_tot / rowSums(X_tot)
totalTaskDist <- X_tot / gens
totalTaskDist <- transform(totalTaskDist, Inactive = gens - rowSums(X_tot), n = n, replicate = sim)
# Create tasktally table
taskTally <- do.call("rbind", taskTally)
# Create tasktally table
stimMat <- transform(stimMat, n = n, replicate = sim)
# Create tasktally table
taskCorr <- transform(taskCorr, replicate = sim)
# Add total task distributions, entropy values, and graphs to lists
ens_taskDist[[sim]]  <- totalTaskDist
ens_entropy[[sim]]   <- entropy
ens_taskCorr[[sim]]  <- taskCorr
ens_taskTally[[sim]] <- taskTally
ens_taskStep[[sim]]  <- taskStep
ens_stim[[sim]]      <- stimMat
ens_thresh[[sim]]    <- threshMat
ens_graphs[[sim]]    <- g_tot / gens
# Print simulation completed
print(paste0("DONE: N = ", n, ", Simulation ", sim))
}
####################
# Seed structures and intial matrices
####################
# Set initial probability matrix (P_g)
P_g <- matrix(data = rep(0, n * m), ncol = m)
# Seed task (external) stimuli
stimMat <- seed_stimuls(intitial_stim = InitialStim,
gens = gens)
# Seed internal thresholds
threshMat <- seed_thresholds(n = n,
m = m,
threshold_means = ThreshM,
threshold_sds = ThreshSD)
# Start task performance
X_g <- matrix(data = rep(0, length(P_g)), ncol = ncol(P_g))
# Create cumulative task performance matrix
X_tot <- X_g
# Create cumulative adjacency matrix
g_tot <-  matrix(data = rep(0, n * n), ncol = n)
colnames(g_tot) <- paste0("v-", 1:n)
rownames(g_tot) <- paste0("v-", 1:n)
# Prep lists for data collection within simulation
taskTally <- list()
thresh1time <- list()
thresh2time <- list()
thresh1time[[1]] <- threshMat[ ,1]
thresh2time[[1]] <- threshMat[ ,2]
####################
# Simulate individual run
####################
# Run simulation
for (t in 1:gens) {
# Current timestep is actually t+1 in this formulation, because first row is timestep 0
# Update stimuli
stimMat <- update_stim(stim_matrix = stimMat,
deltas = deltas,
alpha = alpha,
state_matrix = X_g,
time_step = t)
# Calculate task demand based on global stimuli
P_g <- calc_determ_thresh(time_step        = t + 1, # first row is generation 0
threshold_matrix = threshMat,
stimulus_matrix  = stimMat)
# Update task performance
X_g <- update_task_performance(task_probs   = P_g,
state_matrix = X_g,
quit_prob    = quitP)
# Update social network (previously this was before probability/task update)
g_adj <- temporalNetwork(X_sub_g = X_g,
prob_interact = p,
bias = beta)
g_tot <- g_tot + g_adj
# Adjust thresholds
threshMat <- adjust_thresholds_social_capped(social_network = g_adj,
threshold_matrix = threshMat,
state_matrix = X_g,
epsilon = epsilon,
threshold_max = 2 * ThreshM[1])
# Capture threshold values
thresh1time[[t + 1]] <- threshMat[,1]
thresh2time[[t + 1]] <- threshMat[,2]
# Update total task performance profile
X_tot <- X_tot + X_g
# Capture current task performance tally
tally <- matrix(c(t, colSums(X_g)), ncol = ncol(X_g) + 1)
colnames(tally) <- c("t", colnames(X_g))
taskTally[[t]] <- tally
}
tail(stimMat)
tail(taskTally)
1/5
time_step
time_step = 100
time_step = t
no_of_stim <- ncol(threshold_matrix)
stim_this_step <- as.matrix(stimulus_matrix[time_step, 1:no_of_stim])
stim_this_step
threshold_prob <- lapply(1:ncol(threshold_matrix), function(j) {
# Check if stimulus exceeds threshold
thresh_result <-  stim_this_step[j] > threshold_matrix[ , j]
return(as.numeric(thresh_result))
})
threshold_prob
threshMat
stim_this_step
stim_this_step[1]
j = 1
stim_this_step[j] > threshold_matrix[ , j]
stim_this_step[j]
threshold_matrix[ , j]
threshold_matrix
tasks <- seq(1:ncol(task_probs))
task_probs   = P_g
P_g
state_matrix = X_g
state_matrix
quit_prob    = quitP
tasks <- seq(1:ncol(task_probs))
tasks
row = 1
tasks_order <- sample(x = tasks, size = length(tasks), replace = FALSE)
task = 1
prob <- task_probs[row, task]
activity <- sample(x = c(0, 1), size = 1, prob = c(1 - prob, prob))
activity
task_probs
quit_now <- sample(x = c("yes", "no"), size = 1, prob = c(quit_prob, (1 - quit_prob)))
quit_now <- sample(x = c("yes", "no"), size = 1, prob = c(quit_prob, (1 - quit_prob)))
quit_now <- sample(x = c("yes", "no"), size = 1, prob = c(quit_prob, (1 - quit_prob)))
quit_now <- sample(x = c("yes", "no"), size = 1, prob = c(quit_prob, (1 - quit_prob)))
quit_now <- sample(x = c("yes", "no"), size = 1, prob = c(quit_prob, (1 - quit_prob)))
quit_now <- sample(x = c("yes", "no"), size = 1, prob = c(quit_prob, (1 - quit_prob)))
quit_now <- sample(x = c("yes", "no"), size = 1, prob = c(quit_prob, (1 - quit_prob)))
quit_now <- sample(x = c("yes", "no"), size = 1, prob = c(quit_prob, (1 - quit_prob)))
quit_now <- sample(x = c("yes", "no"), size = 1, prob = c(quit_prob, (1 - quit_prob)))
quit_now <- sample(x = c("yes", "no"), size = 1, prob = c(quit_prob, (1 - quit_prob)))
quit_now <- sample(x = c("yes", "no"), size = 1, prob = c(quit_prob, (1 - quit_prob)))
quit_now <- sample(x = c("yes", "no"), size = 1, prob = c(quit_prob, (1 - quit_prob)))
quit_now <- sample(x = c("yes", "no"), size = 1, prob = c(quit_prob, (1 - quit_prob)))
quit_now <- sample(x = c("yes", "no"), size = 1, prob = c(quit_prob, (1 - quit_prob)))
quit_now <- sample(x = c("yes", "no"), size = 1, prob = c(quit_prob, (1 - quit_prob)))
quit_now <- sample(x = c("yes", "no"), size = 1, prob = c(quit_prob, (1 - quit_prob)))
quit_now <- sample(x = c("yes", "no"), size = 1, prob = c(quit_prob, (1 - quit_prob)))
quit_now <- sample(x = c("yes", "no"), size = 1, prob = c(quit_prob, (1 - quit_prob)))
quit_now <- sample(x = c("yes", "no"), size = 1, prob = c(quit_prob, (1 - quit_prob)))
quit_now <- sample(x = c("yes", "no"), size = 1, prob = c(quit_prob, (1 - quit_prob)))
quit_now <- sample(x = c("yes", "no"), size = 1, prob = c(quit_prob, (1 - quit_prob)))
quit_now <- sample(x = c("yes", "no"), size = 1, prob = c(quit_prob, (1 - quit_prob)))
quit_now <- sample(x = c("yes", "no"), size = 1, prob = c(quit_prob, (1 - quit_prob)))
quit_now <- sample(x = c("yes", "no"), size = 1, prob = c(quit_prob, (1 - quit_prob)))
quit_now <- sample(x = c("yes", "no"), size = 1, prob = c(quit_prob, (1 - quit_prob)))
X_sub_g
t
update_task_performance(task_probs   = P_g,
state_matrix = X_g,
quit_prob    = quitP)
update_task_performance(task_probs   = P_g,
state_matrix = X_g,
quit_prob    = quitP)
update_task_performance(task_probs   = P_g,
state_matrix = X_g,
quit_prob    = quitP)
update_task_performance(task_probs   = P_g,
state_matrix = X_g,
quit_prob    = quitP)
update_task_performance(task_probs   = P_g,
state_matrix = X_g,
quit_prob    = quitP)
update_task_performance(task_probs   = P_g,
state_matrix = X_g,
quit_prob    = quitP)
update_task_performance(task_probs   = P_g,
state_matrix = X_g,
quit_prob    = quitP)
update_task_performance(task_probs   = P_g,
state_matrix = X_g,
quit_prob    = quitP)
update_task_performance(task_probs   = P_g,
state_matrix = X_g,
quit_prob    = quitP)
update_task_performance(task_probs   = P_g,
state_matrix = X_g,
quit_prob    = quitP)
update_task_performance(task_probs   = P_g,
state_matrix = X_g,
quit_prob    = quitP)
update_task_performance(task_probs   = P_g,
state_matrix = X_g,
quit_prob    = quitP)
update_task_performance(task_probs   = P_g,
state_matrix = X_g,
quit_prob    = quitP)
update_task_performance(task_probs   = P_g,
state_matrix = X_g,
quit_prob    = quitP)
update_task_performance(task_probs   = P_g,
state_matrix = X_g,
quit_prob    = quitP)
update_task_performance(task_probs   = P_g,
state_matrix = X_g,
quit_prob    = quitP)
update_task_performance(task_probs   = P_g,
state_matrix = X_g,
quit_prob    = quitP)
update_task_performance(task_probs   = P_g,
state_matrix = X_g,
quit_prob    = quitP)
update_task_performance(task_probs   = P_g,
state_matrix = X_g,
quit_prob    = quitP)
update_task_performance(task_probs   = P_g,
state_matrix = X_g,
quit_prob    = quitP)
X_g
update_task_performance(task_probs   = P_g,
state_matrix = X_g,
quit_prob    = quitP)
update_task_performance(task_probs   = P_g,
state_matrix = X_g,
quit_prob    = quitP)
update_task_performance(task_probs   = P_g,
state_matrix = X_g,
quit_prob    = quitP)
update_task_performance(task_probs   = P_g,
state_matrix = X_g,
quit_prob    = quitP)
update_task_performance(task_probs   = P_g,
state_matrix = X_g,
quit_prob    = quitP)
update_task_performance(task_probs   = P_g,
state_matrix = X_g,
quit_prob    = quitP)
update_task_performance(task_probs   = P_g,
state_matrix = X_g,
quit_prob    = quitP)
update_task_performance(task_probs   = P_g,
state_matrix = X_g,
quit_prob    = quitP)
update_task_performance(task_probs   = P_g,
state_matrix = X_g,
quit_prob    = quitP)
update_task_performance(task_probs   = P_g,
state_matrix = X_g,
quit_prob    = quitP)
update_task_performance(task_probs   = P_g,
state_matrix = X_g,
quit_prob    = quitP)
update_task_performance(task_probs   = P_g,
state_matrix = X_g,
quit_prob    = quitP)
update_task_performance(task_probs   = P_g,
state_matrix = X_g,
quit_prob    = quitP)
update_task_performance(task_probs   = P_g,
state_matrix = X_g,
quit_prob    = quitP)
X_g <- matrix(data = rep(0, length(P_g)), ncol = ncol(P_g))
P_g
update_task_performance(task_probs   = P_g,
state_matrix = X_g,
quit_prob    = quitP)
update_task_performance(task_probs   = P_g,
state_matrix = X_g,
quit_prob    = quitP)
update_task_performance(task_probs   = P_g,
state_matrix = X_g,
quit_prob    = quitP)
update_task_performance(task_probs   = P_g,
state_matrix = X_g,
quit_prob    = quitP)
update_task_performance(task_probs   = P_g,
state_matrix = X_g,
quit_prob    = quitP)
update_task_performance(task_probs   = P_g,
state_matrix = X_g,
quit_prob    = quitP)
update_task_performance(task_probs   = P_g,
state_matrix = X_g,
quit_prob    = quitP)
update_task_performance(task_probs   = P_g,
state_matrix = X_g,
quit_prob    = quitP)
update_task_performance(task_probs   = P_g,
state_matrix = X_g,
quit_prob    = quitP)
update_task_performance(task_probs   = P_g,
state_matrix = X_g,
quit_prob    = quitP)
update_task_performance(task_probs   = P_g,
state_matrix = X_g,
quit_prob    = quitP)
update_task_performance(task_probs   = P_g,
state_matrix = X_g,
quit_prob    = quitP)
update_task_performance(task_probs   = P_g,
state_matrix = X_g,
quit_prob    = quitP)
update_task_performance(task_probs   = P_g,
state_matrix = X_g,
quit_prob    = quitP)
update_task_performance(task_probs   = P_g,
state_matrix = X_g,
quit_prob    = quitP)
update_task_performance(task_probs   = P_g,
state_matrix = X_g,
quit_prob    = quitP)
update_task_performance(task_probs   = P_g,
state_matrix = X_g,
quit_prob    = quitP)
update_task_performance(task_probs   = P_g,
state_matrix = X_g,
quit_prob    = quitP)
update_task_performance(task_probs   = P_g,
state_matrix = X_g,
quit_prob    = quitP)
update_task_performance(task_probs   = P_g,
state_matrix = X_g,
quit_prob    = quitP)
update_task_performance(task_probs   = P_g,
state_matrix = X_g,
quit_prob    = quitP)
update_task_performance(task_probs   = P_g,
state_matrix = X_g,
quit_prob    = quitP)
update_task_performance(task_probs   = P_g,
state_matrix = X_g,
quit_prob    = quitP)
update_task_performance(task_probs   = P_g,
state_matrix = X_g,
quit_prob    = quitP)
update_task_performance(task_probs   = P_g,
state_matrix = X_g,
quit_prob    = quitP)
update_task_performance(task_probs   = P_g,
state_matrix = X_g,
quit_prob    = quitP)
update_task_performance(task_probs   = P_g,
state_matrix = X_g,
quit_prob    = quitP)
update_task_performance(task_probs   = P_g,
state_matrix = X_g,
quit_prob    = quitP)
update_task_performance(task_probs   = P_g,
state_matrix = X_g,
quit_prob    = quitP)
update_task_performance(task_probs   = P_g,
state_matrix = X_g,
quit_prob    = quitP)
update_task_performance(task_probs   = P_g,
state_matrix = X_g,
quit_prob    = quitP)
X_g <- update_task_performance(task_probs   = P_g,
state_matrix = X_g,
quit_prob    = quitP)
X_g
social_network = g_adj
threshold_matrix = threshMat
state_matrix = X_g
epsilon = epsilon
threshold_max = 2 * ThreshM[1]
active_neighbors <- t(social_network) %*% state_matrix #active neighbors by category
active_count
active_neighbors
state_matrix
social_network
total_neighbors <- rowSums(active_neighbors) #total active neigh
total_neighbors
not_sums <- total_neighbors - active_neighbors
not_sums
total_neighbors
active_neighbors
not_sums
active_neighbors
net_effect <- not_sums - active_neighbors
net_effect
net_effect <- net_effect * epsilon
net_effect
threshold_matrix + net_effect
threshold_matrix
n = 20
P_g <- matrix(data = rep(0, n * m), ncol = m)
# Seed task (external) stimuli
stimMat <- seed_stimuls(intitial_stim = InitialStim,
gens = gens)
# Seed internal thresholds
threshMat <- seed_thresholds(n = n,
m = m,
threshold_means = ThreshM,
threshold_sds = ThreshSD)
# Start task performance
X_g <- matrix(data = rep(0, length(P_g)), ncol = ncol(P_g))
# Create cumulative task performance matrix
X_tot <- X_g
# Create cumulative adjacency matrix
g_tot <-  matrix(data = rep(0, n * n), ncol = n)
colnames(g_tot) <- paste0("v-", 1:n)
rownames(g_tot) <- paste0("v-", 1:n)
# Prep lists for data collection within simulation
taskTally <- list()
thresh1time <- list()
thresh2time <- list()
thresh1time[[1]] <- threshMat[ ,1]
thresh2time[[1]] <- threshMat[ ,2]
####################
# Simulate individual run
####################
# Run simulation
for (t in 1:gens) {
# Current timestep is actually t+1 in this formulation, because first row is timestep 0
# Update stimuli
stimMat <- update_stim(stim_matrix = stimMat,
deltas = deltas,
alpha = alpha,
state_matrix = X_g,
time_step = t)
# Calculate task demand based on global stimuli
P_g <- calc_determ_thresh(time_step        = t + 1, # first row is generation 0
threshold_matrix = threshMat,
stimulus_matrix  = stimMat)
# Update task performance
X_g <- update_task_performance(task_probs   = P_g,
state_matrix = X_g,
quit_prob    = quitP)
# Update social network (previously this was before probability/task update)
g_adj <- temporalNetwork(X_sub_g = X_g,
prob_interact = p,
bias = beta)
g_tot <- g_tot + g_adj
# Adjust thresholds
threshMat <- adjust_thresholds_social_capped(social_network = g_adj,
threshold_matrix = threshMat,
state_matrix = X_g,
epsilon = epsilon,
threshold_max = 2 * ThreshM[1])
# Capture threshold values
thresh1time[[t + 1]] <- threshMat[,1]
thresh2time[[t + 1]] <- threshMat[,2]
# Update total task performance profile
X_tot <- X_tot + X_g
# Capture current task performance tally
tally <- matrix(c(t, colSums(X_g)), ncol = ncol(X_g) + 1)
colnames(tally) <- c("t", colnames(X_g))
taskTally[[t]] <- tally
}
gens
social_network = g_adj
threshold_matrix = threshMat
state_matrix = X_g
epsilon = epsilon
threshold_max = 2 * ThreshM[1]
active_neighbors <- t(social_network) %*% state_matrix #active neighbors by category
total_neighbors <- rowSums(active_neighbors) #total active neighbors
active_neighbors
g_adj
state_matrix
not_sums <- total_neighbors - active_neighbors
not_sums
net_effect <- not_sums - active_neighbors
net_effect
X_sub_g = X_g
prob_interact = p
p
bias = beta
bias
dimension <- nrow(X_sub_g)
g_adj <- matrix(data = rep(0, dimension*dimension), ncol = dimension)
g_adj
interact <- sample(x = c(1, 0), size = 1, prob = c(prob_interact, 1 - prob_interact))
interact <- sample(x = c(1, 0), size = 1, prob = c(prob_interact, 1 - prob_interact))
interact <- sample(x = c(1, 0), size = 1, prob = c(prob_interact, 1 - prob_interact))
interact <- sample(x = c(1, 0), size = 1, prob = c(prob_interact, 1 - prob_interact))
interact <- sample(x = c(1, 0), size = 1, prob = c(prob_interact, 1 - prob_interact))
task <- which(X_sub_g[i, ] == 1)
i = 1
task <- which(X_sub_g[i, ] == 1)
task
potential <- seq(1:dimension)
baseline_prob <- rep(1, length(potential))
potential
same <- which(X_sub_g[ , task] == 1)
baseline_prob[same] <- baseline_prob[same] * bias
same
baseline_prob
X_sub_g
potential <- potential[-i] #remove self
baseline_prob <- baseline_prob[-i] #remove self
potential
baseline_prob
sample(x = potential, size = 1, prob = baseline_prob)
sample(x = potential, size = 1, prob = baseline_prob)
sample(x = potential, size = 1, prob = baseline_prob)
sample(x = potential, size = 1, prob = baseline_prob)
sample(x = potential, size = 1, prob = baseline_prob)
sample(x = potential, size = 1, prob = baseline_prob)
sample(x = potential, size = 1, prob = baseline_prob)
sample(x = potential, size = 1, prob = baseline_prob)
sample(x = potential, size = 1, prob = baseline_prob)
sample(x = potential, size = 1, prob = baseline_prob)
sample(x = potential, size = 1, prob = baseline_prob)
sample(x = potential, size = 1, prob = baseline_prob)
sample(x = potential, size = 1, prob = baseline_prob)
sample(x = potential, size = 1, prob = baseline_prob)
sample(x = potential, size = 1, prob = baseline_prob)
sample(x = potential, size = 1, prob = baseline_prob)
sample(x = potential, size = 1, prob = baseline_prob)
sample(x = potential, size = 1, prob = baseline_prob)
sample(x = potential, size = 1, prob = baseline_prob)
sample(x = potential, size = 1, prob = baseline_prob)
