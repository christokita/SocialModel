{
    "collab_server" : "",
    "contents" : "################################################################################\n#\n# Analyze Networks of Social Interactions\n#\n################################################################################\n\nrm(list = ls())\nsource(\"scripts/__Util__MASTER.R\")\nlibrary(RColorBrewer)\nlibrary(scales)\nlibrary(igraph)\n\nfilename <- \"Sigma001-Eps001--Bias1.1\"\n\n# Cutoff for threshold ratio to allow easier plotting\nThreshCutoffValue <- 10\nThreshCutoffReplacement <- Inf\nThreshCutoffReplacementColor <- 10\n\n####################\n# Load data\n####################\n# Load social\nload(\"output/Rdata/Sigma0.01-Epsilon0.01-Bias1.1.Rdata\")\n\nsoc_graphs <- unlist(groups_graphs, recursive = FALSE)\nsoc_threshMat <- unlist(groups_thresh, recursive = FALSE)\nsoc_actMat <- unlist(groups_taskDist, recursive = FALSE)\n\nsocial_graphs <- lapply(1:length(soc_graphs), function(i) {\n  # Calculated degree\n  degree <- rowSums(soc_graphs[[i]])\n  degree <- as.data.frame(degree)\n  degree$Id <- row.names(degree)\n  # Calculate thresholds\n  thresh <- soc_threshMat[[i]] %>% \n    as.data.frame(.) %>% \n    mutate(ThreshRatio = log(Thresh1 / Thresh2),\n           Id = row.names(.))\n  thresh$ThreshRatio[thresh$ThreshRatio > ThreshCutoffValue] <- ThreshCutoffReplacement\n  thresh$ThreshRatio[thresh$ThreshRatio < -ThreshCutoffValue] <- -ThreshCutoffReplacement\n  thresh$ThreshRatioColor <- thresh$ThreshRatio\n  thresh$ThreshRatioColor[thresh$ThreshRatio > ThreshCutoffValue] <- ThreshCutoffReplacementColor\n  thresh$ThreshRatioColor[thresh$ThreshRatio < -ThreshCutoffValue] <- -ThreshCutoffReplacementColor\n  # Calculate actibity\n  activity <- soc_actMat[[i]] %>% \n    as.data.frame(.) %>% \n    mutate(ActRatio = log(Task1 / Task2),\n           ActTotal = Task1 + Task2,\n           Id = row.names(.))\n  # Merge and return\n  mergedNodes <- merge(degree, thresh)\n  mergedNodes <- merge(mergedNodes, activity)\n  return(mergedNodes)\n})\n\nsocial_graphs <- do.call(\"rbind\", social_graphs)\n\n# Load fixed\nload(\"output/Rdata/Sigma0.01-FIXED-Bias1.1.Rdata\")\n\nfix_graphs <- unlist(groups_graphs, recursive = FALSE)\nfix_threshMat <- unlist(groups_thresh, recursive = FALSE)\nfix_actMat <- unlist(groups_taskDist, recursive = FALSE)\n\nfixed_graphs <- lapply(1:length(fix_graphs), function(i) {\n  # Calculated degree\n  degree <- rowSums(fix_graphs[[i]])\n  degree <- as.data.frame(degree)\n  degree$Id <- row.names(degree)\n  # Calculate thresholds\n  thresh <- fix_threshMat[[i]] %>% \n    as.data.frame(.) %>% \n    mutate(ThreshRatio = log(Thresh1 / Thresh2),\n           Id = row.names(.))\n  thresh$ThreshRatio[thresh$ThreshRatio > ThreshCutoffValue] <- ThreshCutoffReplacement\n  thresh$ThreshRatio[thresh$ThreshRatio < -ThreshCutoffValue] <- -ThreshCutoffReplacement\n  thresh$ThreshRatioColor <- thresh$ThreshRatio\n  thresh$ThreshRatioColor[thresh$ThreshRatio > ThreshCutoffValue] <- ThreshCutoffReplacementColor\n  thresh$ThreshRatioColor[thresh$ThreshRatio < -ThreshCutoffValue] <- -ThreshCutoffReplacementColor\n  # Calculate actibity\n  activity <- fix_actMat[[i]] %>% \n    as.data.frame(.) %>% \n    mutate(ActRatio = log(Task1 / Task2),\n           ActTotal = Task1 + Task2,\n           Id = row.names(.))\n  # Merge and return\n  mergedNodes <- merge(degree, thresh)\n  mergedNodes <- merge(mergedNodes, activity)\n  return(mergedNodes)\n})\n\nfixed_graphs <- do.call(\"rbind\", fixed_graphs)\n\n\n####################\n# Compare social network features\n####################\n\n###### Network \"dispersion\" (? - standard deviation over mean degree) ###### \nsoc_dispersion <- lapply(soc_graphs, function(graph) {\n  # Group size\n  n <- nrow(graph)\n  # Degrees\n  degrees <- rowSums(graph)\n  deg_mean <- mean(degrees)\n  deg_sd <- sd(degrees)\n  # compile and return\n  to_return <- data.frame(n = n, DegreeMean = deg_mean, DegreeSD = deg_sd)\n})\ndispersion <- do.call(\"rbind\", soc_dispersion)\ndispersion <- dispersion %>% \n  mutate(Dispersion = DegreeSD / DegreeMean)\ndispersionSummary <- dispersion %>% \n  mutate(Model = \"Social\") %>% \n  group_by(n, Model) %>% \n  summarise(Dispersion = mean(Dispersion))\n\nfixed_dispersion <- lapply(fix_graphs, function(graph) {\n  # Group size\n  n <- nrow(graph)\n  # Degrees\n  degrees <- rowSums(graph)\n  deg_mean <- mean(degrees)\n  deg_sd <- sd(degrees)\n  # compile and return\n  to_return <- data.frame(n = n, DegreeMean = deg_mean, DegreeSD = deg_sd)\n})\nfixed_dispersion <- do.call(\"rbind\", fixed_dispersion)\nfixed_dispersion <- fixed_dispersion %>% \n  mutate(Dispersion = DegreeSD / DegreeMean)\nfixed_dispersionSummary <- fixed_dispersion %>% \n  mutate(Model = \"Fixed\") %>% \n  group_by(n, Model) %>% \n  summarise(Dispersion = mean(Dispersion))\n\ndispersionSummary <- rbind(dispersionSummary, fixed_dispersionSummary)\nrm(fixed_dispersion, fixed_dispersionSummary)\n\ngg_dispersion <- ggplot(data = dispersionSummary, aes(x = n, y = Dispersion, group = Model, color = Model)) +\n  geom_line(aes(linetype = Model)) +\n  geom_point(size = 2) +\n  theme_classic(base_size = 10) +\n  scale_color_manual(values = c(\"black\", \"mediumseagreen\")) +\n  scale_linetype_manual(values = c(\"dashed\", \"solid\")) +\n  theme(aspect.ratio = 1,\n        axis.text = element_text(color = \"black\")) \ngg_dispersion\n\n\n###### Network homophily ###### \nweighted_ratios <- lapply(1:length(soc_graphs), function(i) {\n  # Social\n  # Get graph and thresh matrix for simulation\n  graph <- soc_graphs[[i]]\n  thresh <- as.data.frame(soc_threshMat[[i]])\n  # Calculate thresh ratio\n  threshRatio <- log(thresh$Thresh1 / thresh$Thresh2)\n  # Calculate weighted neighbor sum for each individual\n  weighted_sum <- graph %*% threshRatio\n  # Calculate weighted neighbor sum for each individual\n  strength <- rowSums(graph)\n  disparity <- rowSums((graph / strength)^2)\n  # Construct dataframe to return\n  to_return <- data.frame(Id = row.names(weighted_sum), \n                          n = length(weighted_sum),\n                          ThreshRatio = threshRatio,\n                          WeightNeighbor = weighted_sum,\n                          Disparity = disparity,\n                          Model = \"Social\")\n  row.names(to_return) <- NULL\n  # Fixed\n  # Get graph and thresh matrix for simulation\n  graph <- fix_graphs[[i]]\n  thresh <- as.data.frame(fix_threshMat[[i]])\n  # Calculate thresh ratio\n  threshRatio <- log(thresh$Thresh1 / thresh$Thresh2)\n  # Calculate weighted neighbor sum for each individual\n  weighted_sum <- graph %*% threshRatio\n  # Calculate weighted neighbor sum for each individual\n  strength <- rowSums(graph)\n  disparity <- rowSums((graph / strength)^2)\n  # Construct dataframe to return\n  to_return2 <- data.frame(Id = row.names(weighted_sum), \n                          n = length(weighted_sum),\n                          ThreshRatio = threshRatio,\n                          WeightNeighbor = weighted_sum,\n                          Disparity = disparity,\n                          Model = \"Fixed\")\n  row.names(to_return) <- NULL\n  # Return\n  to_return$Model <- as.character(to_return$Model)\n  to_return <- rbind(to_return, to_return2)\n  return(to_return)\n})\nweighted_ratios <- do.call(\"rbind\", weighted_ratios)\n\ngg_weighted_ratios <- ggplot(data = weighted_ratios, aes(x = ThreshRatio, y = WeightNeighbor)) +\n  geom_point() +\n  theme_classic(base_size = 10) +\n  theme(aspect.ratio = 1,\n        axis.text = element_text(color = \"black\"))  +\n  facet_wrap(~n, scales = \"free\")\ngg_weighted_ratios\n\nweighted_summary <- weighted_ratios %>% \n  group_by(n, Model) %>% \n  summarise(CorrelationThresholds = cor(ThreshRatio, WeightNeighbor))\n\ngg_weighted_corr <- ggplot(data = weighted_summary, aes(x = n, y = CorrelationThresholds, group = Model, color = Model)) +\n  geom_line(aes(linetype = Model)) +\n  geom_point(size = 2) +\n  theme_classic(base_size = 10) +\n  scale_color_manual(values = c(\"black\", \"mediumseagreen\")) +\n  scale_linetype_manual(values = c(\"dashed\", \"solid\")) +\n  theme(aspect.ratio = 1,\n        axis.text = element_text(color = \"black\")) \ngg_weighted_corr\n\n\n###### Network disparity ###### \ngg_disparity <- ggplot(data = weighted_ratios, aes(x = ThreshRatio, y = Disparity)) +\n  geom_point(size = 0.2) +\n  theme_classic(base_size = 10) +\n  theme(aspect.ratio = 1,\n        axis.text = element_text(color = \"black\"))  +\n  facet_wrap(~n, scales = \"free\")\ngg_disparity\n\n\n###### Modularity ###### \n",
    "created" : 1512590661223.000,
    "dirty" : false,
    "encoding" : "UTF-8",
    "folds" : "",
    "hash" : "1881024611",
    "id" : "41A956B3",
    "lastKnownWriteTime" : 1512681946,
    "last_content_update" : 1512681946370,
    "path" : "~/Documents/Research/Tarnita Lab/Social Interaction DOL/SocialModel/scripts/AnalyzeNetworks.R",
    "project_path" : "scripts/AnalyzeNetworks.R",
    "properties" : {
        "tempName" : "Untitled1"
    },
    "relative_order" : 5,
    "source_on_save" : false,
    "source_window" : "",
    "type" : "r_source"
}