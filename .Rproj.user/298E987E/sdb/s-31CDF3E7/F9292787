{
    "collab_server" : "",
    "contents" : "##################################################\n#\n# Threshold Probability of Performance \n#\n##################################################\n\n\n####################\n# Seed task thresholds\n####################\nseedThresholds <- function(n, m, ThresholdMeans = NULL, ThresholdSDs = NULL) {\n  # Loop through tasks and sample thresholds from normal dist\n  threshMat <- lapply(1:length(ThresholdMeans), function(i) {\n    threshList <- rtnorm(n = n, \n                         mean = ThresholdMeans[i], \n                         sd = ThresholdSDs[i], \n                         lower = 0)\n    return(threshList)\n  })\n  threshMat <- do.call(\"cbind\", threshMat)\n  # Fix names\n  colnames(threshMat) <- paste0(\"Thresh\", 1:length(ThresholdMeans))\n  rownames(threshMat) <- paste0(\"v-\", 1:n)\n  # Return\n  return(threshMat)\n}\n\n\n####################\n# Threshold function\n####################\nthreshProb <- function(s, phi, nSlope) {\n  T_vi <- (s^nSlope) / (s^nSlope + phi^nSlope)\n}\n\n\n####################\n# Output Threshold Demands\n####################\ncalcThresholdProbMat <- function(TimeStep, ThresholdMatrix, StimulusMatrix, nSlope) {\n  # select proper stimulus for this time step\n  stimulusThisStep <- StimulusMatrix[TimeStep, ]\n  # calculate threshold probabilities for one individual\n  thresholdP <- lapply(1:nrow(ThresholdMatrix), function(i) {\n    # select row for individual in threshold matrix\n    indThresh <- ThresholdMatrix[i, ]\n    # create task vector to be output and bound\n    taskThresh <- rep(NA, length(indThresh))\n    # loop through each task within individual\n    for (j in 1:length(taskThresh)) {\n      taskThresh[j] <- threshProb(s = stimulusThisStep[j], phi = indThresh[j], nSlope = nSlope)\n    }\n    return(taskThresh)\n  })\n  # bind and return\n  thresholdP <- do.call(\"rbind\", thresholdP)\n  thresholdP[is.na(thresholdP)] <- 0 #fix NAs where thresh was 0 and stim was 0\n  colnames(thresholdP) <- paste0(\"ThreshProb\", 1:ncol(thresholdP))\n  rownames(thresholdP) <- paste0(\"v-\", 1:nrow(thresholdP))\n  return(thresholdP)\n}\n\n####################\n# Output Threshold Demands\n####################\ncalcThresholdDetermMat <- function(TimeStep, ThresholdMatrix, StimulusMatrix) {\n  # select proper stimulus for this time step\n  stimulusThisStep <- StimulusMatrix[TimeStep, ]\n  # calculate threshold probabilities for one individual\n  thresholdP <- lapply(1:nrow(ThresholdMatrix), function(i) {\n    # select row for individual in threshold matrix\n    indThresh <- ThresholdMatrix[i, ]\n    # create task vector to be output and bound\n    taskThresh <- rep(0, length(indThresh))\n    # loop through each task within individual\n    for (j in 1:length(taskThresh)) {\n      stim <- stimulusThisStep[j]\n      thresh <- indThresh[j]\n      if (stim > thresh) {\n        taskThresh[j] <- 1\n      }\n    }\n    return(taskThresh)\n  })\n  # bind and return\n  thresholdP <- do.call(\"rbind\", thresholdP)\n  colnames(thresholdP) <- paste0(\"ThreshProb\", 1:ncol(thresholdP))\n  rownames(thresholdP) <- paste0(\"v-\", 1:nrow(thresholdP))\n  return(thresholdP)\n}\n\n\n####################\n# Exhaustion Threshold Function\n####################\ncalcExhaustDemand <- function(ExhaustStim, ExhaustThreshVector, nSlope) {\n  # Create output matrix\n  exhaustUpdate <- matrix(rep(NA, length(ExhaustStim)), ncol = 1)\n  colnames(exhaustUpdate) <- \"ExhaustProb\"\n  rownames(exhaustUpdate) <- paste0(\"v-\", 1:length(ExhaustStim))\n  # Loop through individuals\n  for (i in 1:length(exhaustUpdate)) {\n    exhaustUpdate[i] <- threshProb(s = ExhaustStim[i], phi = ExhaustThreshVector[i], nSlope = nSlope)\n  }\n  # Return\n  return(exhaustUpdate)\n}\n\n####################\n# Self-reinforcement of Threshold\n####################\nadjustThresholds <- function(ThresholdMatrix, X_sub_g, phi, gamma, lowerThresh, upperThresh) {\n  for (i in 1:nrow(X_sub_g)) {\n    for (j in 1:ncol(X_sub_g)) {\n      adjust <- ((1 - X_sub_g[i, j]) * phi - X_sub_g[i, j] * gamma)\n      ThresholdMatrix[i, j] <- ThresholdMatrix[i, j] + adjust\n      if (ThresholdMatrix[i, j] < lowerThresh) {\n        ThresholdMatrix[i, j] <- lowerThresh\n      } else if (ThresholdMatrix[i, j] > upperThresh) {\n        ThresholdMatrix[i, j] <- upperThresh\n      }\n    }\n  }\n  return(ThresholdMatrix)\n}\n\n####################\n# Self-reinforcement of Threshold\n####################\nadjustThresholdsSocial <- function(ThresholdMatrix, X_sub_g, phi, gamma, c, d, SocialNetwork, lowerThresh, upperThresh, Average) {\n  # Calculate \"sum\" of task states/probs of neighbors\n  NeighborSums <- SocialNetwork %*% X_sub_g\n  # Calculate total neighbors (degree of individual)\n  DegSum <- rowSums(SocialNetwork)\n  # Calculate frequency performing\n  freqPerforming <- NeighborSums / DegSum\n  freqPerforming[is.na(freqPerforming)] <- 0\n  # Loop through individuals\n  # If summing interactions\n  if (Average == FALSE) {\n    for (i in 1:nrow(X_sub_g)) {\n      for (j in 1:ncol(X_sub_g)) {\n        # Establish variables\n        state <-  X_sub_g[i, j]\n        sum <- NeighborSums[i, j]\n        # Adjust\n        adjust <- ( ((1 - state) * phi * (1 - d * sum)) - (state * gamma * (1 + c * sum)) )\n        ThresholdMatrix[i, j] <- ThresholdMatrix[i, j] + adjust\n        if (ThresholdMatrix[i, j] < lowerThresh) {\n          ThresholdMatrix[i, j] <- lowerThresh\n        } else if (ThresholdMatrix[i, j] > upperThresh) {\n          ThresholdMatrix[i, j] <- upperThresh\n        }\n      }\n    }\n  } else if (Average == TRUE) {\n    for (i in 1:nrow(X_sub_g)) {\n      for (j in 1:ncol(X_sub_g)) {\n        # Establish variables\n        state <-  X_sub_g[i, j]\n        freq <- freqPerforming[i, j]\n        # Adjust\n        adjust <- ( ((1 - state) * phi * (1 - d * freq)) - (state * gamma * (1 + c * freq)) )\n        ThresholdMatrix[i, j] <- ThresholdMatrix[i, j] + adjust\n        if (ThresholdMatrix[i, j] < lowerThresh) {\n          ThresholdMatrix[i, j] <- lowerThresh\n        } else if (ThresholdMatrix[i, j] > upperThresh) {\n          ThresholdMatrix[i, j] <- upperThresh\n        }\n      }\n    }\n  }\n  return(ThresholdMatrix)\n}\n\n####################\n# Self-reinforcement of Threshold\n####################\nadjustThresholdsSocial_bound <- function(ThresholdMatrix, X_sub_g, phi, gamma, c, d, SocialNetwork, lowerThresh, upperThresh, Average) {\n  # Calculate \"sum\" of task states/probs of neighbors\n  NeighborSums <- SocialNetwork %*% X_sub_g\n  # Calculate total neighbors (degree of individual)\n  DegSum <- rowSums(SocialNetwork)\n  # Calculate frequency performing\n  freqPerforming <- NeighborSums / DegSum\n  freqPerforming[is.na(freqPerforming)] <- 0\n  # Loop through individuals\n  # If summing interactions\n  if (Average == FALSE) {\n    for (i in 1:nrow(X_sub_g)) {\n      for (j in 1:ncol(X_sub_g)) {\n        # Establish variables\n        state <-  X_sub_g[i, j]\n        sum <- NeighborSums[i, j]\n        # Adjust\n        adjust <- ( ((1 - state) * phi * (1 - d * sum)) - (state * gamma * (1 + c * sum)) )\n        ThresholdMatrix[i, j] <- ThresholdMatrix[i, j] + adjust\n        if (ThresholdMatrix[i, j] < lowerThresh[i, j]) {\n          ThresholdMatrix[i, j] <- lowerThresh[i, j]\n        } else if (ThresholdMatrix[i, j] > upperThresh[i, j]) {\n          ThresholdMatrix[i, j] <- upperThresh[i, j]\n        }\n      }\n    }\n  } else if (Average == TRUE) {\n    for (i in 1:nrow(X_sub_g)) {\n      for (j in 1:ncol(X_sub_g)) {\n        # Establish variables\n        state <-  X_sub_g[i, j]\n        freq <- freqPerforming[i, j]\n        # Adjust\n        adjust <- ( ((1 - state) * phi * (1 - d * freq)) - (state * gamma * (1 + c * freq)) )\n        ThresholdMatrix[i, j] <- ThresholdMatrix[i, j] + adjust\n        if (ThresholdMatrix[i, j] < lowerThresh[i, j]) {\n          ThresholdMatrix[i, j] <- lowerThresh[i, j]\n        } else if (ThresholdMatrix[i, j] > upperThresh[i, j]) {\n          ThresholdMatrix[i, j] <- upperThresh[i, j]\n        }\n      }\n    }\n  }\n  return(ThresholdMatrix)\n}\n\n####################\n# Self-reinforcement of Threshold\n####################\nadjustThresholdsSocialInhibition <- function(ThresholdMatrix, X_sub_g, phi, gamma, c, d, SocialNetwork, lowerThresh, upperThresh, Average) {\n  # Calculate \"sum\" of task states/probs of neighbors\n  NeighborSums <- SocialNetwork %*% X_sub_g\n  # Calculate total neighbors (degree of individual)\n  DegSum <- rowSums(SocialNetwork)\n  # Calculate Inactive\n  Inactive <- DegSum - rowSums(NeighborSums)\n  InactiveFreq <- Inactive / DegSum\n  InactiveFreq[is.na(InactiveFreq)] <- 0\n  # Calculate frequency performing\n  freqPerforming <- NeighborSums / DegSum\n  freqPerforming[is.na(freqPerforming)] <- 0\n  # Loop through individuals\n  # If summing interactions\n  if (Average == FALSE) {\n    for (i in 1:nrow(X_sub_g)) {\n      for (j in 1:ncol(X_sub_g)) {\n        # Establish variables\n        state <-  X_sub_g[i, j]\n        absDiff <- NeighborSums[i, j] - (DegSum[i] - Inactive[i] - NeighborSums[i, j])\n        # Adjust\n        adjust <- ( ((1 - state) * phi * (1 - d * absDiff)) - (state * gamma * (1 + c * absDiff)) )\n        ThresholdMatrix[i, j] <- ThresholdMatrix[i, j] + adjust\n        if (ThresholdMatrix[i, j] < lowerThresh) {\n          ThresholdMatrix[i, j] <- lowerThresh\n        } else if (ThresholdMatrix[i, j] > upperThresh) {\n          ThresholdMatrix[i, j] <- upperThresh\n        }\n      }\n    }\n  } else if (Average == TRUE) {\n    for (i in 1:nrow(X_sub_g)) {\n      for (j in 1:ncol(X_sub_g)) {\n        # Establish variables\n        state <-  X_sub_g[i, j]\n        freqDiff <- freqPerforming[i, j] - (1 - InactiveFreq[i] - freqPerforming[i, j])\n        # Adjust\n        adjust <- ( ((1 - state) * phi * (1 - d * freqDiff)) - (state * gamma * (1 + c * freqDiff)) )\n        ThresholdMatrix[i, j] <- ThresholdMatrix[i, j] + adjust\n        if (ThresholdMatrix[i, j] < lowerThresh) {\n          ThresholdMatrix[i, j] <- lowerThresh\n        } else if (ThresholdMatrix[i, j] > upperThresh) {\n          ThresholdMatrix[i, j] <- upperThresh\n        }\n      }\n    }\n  }\n  return(ThresholdMatrix)\n}\n\n\n####################\n# Plastic bound self-reinforcement of Threshold\n####################\nadjustThresholdsSocialInhibition_Bound <- function(ThresholdMatrix, X_sub_g, phi, gamma, c, d, SocialNetwork, lowerThresh, upperThresh, Average) {\n  # Calculate \"sum\" of task states/probs of neighbors\n  NeighborSums <- SocialNetwork %*% X_sub_g\n  # Calculate total neighbors (degree of individual)\n  DegSum <- rowSums(SocialNetwork)\n  # Calculate Inactive\n  Inactive <- DegSum - rowSums(NeighborSums)\n  InactiveFreq <- Inactive / DegSum\n  InactiveFreq[is.na(InactiveFreq)] <- 0\n  # Calculate frequency performing\n  freqPerforming <- NeighborSums / DegSum\n  freqPerforming[is.na(freqPerforming)] <- 0\n  # Loop through individuals\n  # If summing interactions\n  if (Average == FALSE) {\n    for (i in 1:nrow(X_sub_g)) {\n      for (j in 1:ncol(X_sub_g)) {\n        # Establish variables\n        state <-  X_sub_g[i, j]\n        absDiff <- NeighborSums[i, j] - (DegSum[i] - Inactive[i] - NeighborSums[i, j])\n        # Adjust\n        adjust <- ( ((1 - state) * phi * (1 - d * absDiff)) - (state * gamma * (1 + c * absDiff)) )\n        ThresholdMatrix[i, j] <- ThresholdMatrix[i, j] + adjust\n        if (ThresholdMatrix[i, j] < lowerThresh[i, j]) {\n          ThresholdMatrix[i, j] <- lowerThresh[i, j]\n        } else if (ThresholdMatrix[i, j] > upperThresh[i, j]) {\n          ThresholdMatrix[i, j] <- upperThresh[i, j]\n        }\n      }\n    }\n  } else if (Average == TRUE) {\n    for (i in 1:nrow(X_sub_g)) {\n      for (j in 1:ncol(X_sub_g)) {\n        # Establish variables\n        state <-  X_sub_g[i, j]\n        freqDiff <- freqPerforming[i, j] - (1 - InactiveFreq[i] - freqPerforming[i, j])\n        # Adjust\n        adjust <- ( ((1 - state) * phi * (1 - d * freqDiff)) - (state * gamma * (1 + c * freqDiff)) )\n        ThresholdMatrix[i, j] <- ThresholdMatrix[i, j] + adjust\n        if (ThresholdMatrix[i, j] < lowerThresh[i, j]) {\n          ThresholdMatrix[i, j] <- lowerThresh[i, j]\n        } else if (ThresholdMatrix[i, j] > upperThresh[i, j]) {\n          ThresholdMatrix[i, j] <- upperThresh[i, j]\n        }\n      }\n    }\n  }\n  return(ThresholdMatrix)\n}\n\n\n\n\n",
    "created" : 1509227847089.000,
    "dirty" : false,
    "encoding" : "UTF-8",
    "folds" : "",
    "hash" : "3484181368",
    "id" : "F9292787",
    "lastKnownWriteTime" : 1496246313,
    "last_content_update" : 1496246313,
    "path" : "~/Documents/Research/Tarnita Lab/Social Interaction DOL/SocialModel/scripts/__Util_ThresholdFunctions.R",
    "project_path" : "scripts/__Util_ThresholdFunctions.R",
    "properties" : {
    },
    "relative_order" : 5,
    "source_on_save" : false,
    "source_window" : "",
    "type" : "r_source"
}